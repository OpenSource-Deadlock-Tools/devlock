// @generated by protobuf-ts 2.9.4 with parameter use_proto_field_name
// @generated from protobuf file "steamnetworkingsockets_messages.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CMsgSteamDatagramCertificateSigned } from "./steamnetworkingsockets_messages_certs.js";
/**
 * @generated from protobuf message CMsgSteamDatagramSessionCryptInfo
 */
export interface CMsgSteamDatagramSessionCryptInfo {
  /**
   * @generated from protobuf field: optional CMsgSteamDatagramSessionCryptInfo.EKeyType key_type = 1;
   */
  key_type?: CMsgSteamDatagramSessionCryptInfo_EKeyType;
  /**
   * @generated from protobuf field: optional bytes key_data = 2;
   */
  key_data?: Uint8Array;
  /**
   * @generated from protobuf field: optional fixed64 nonce = 3;
   */
  nonce?: bigint;
  /**
   * @generated from protobuf field: optional uint32 protocol_version = 4;
   */
  protocol_version?: number;
  /**
   * @generated from protobuf field: repeated ESteamNetworkingSocketsCipher ciphers = 5;
   */
  ciphers: ESteamNetworkingSocketsCipher[];
}
/**
 * @generated from protobuf enum CMsgSteamDatagramSessionCryptInfo.EKeyType
 */
export enum CMsgSteamDatagramSessionCryptInfo_EKeyType {
  /**
   * @generated from protobuf enum value: INVALID = 0;
   */
  INVALID = 0,
  /**
   * @generated from protobuf enum value: CURVE25519 = 1;
   */
  CURVE25519 = 1,
}
/**
 * @generated from protobuf message CMsgSteamDatagramSessionCryptInfoSigned
 */
export interface CMsgSteamDatagramSessionCryptInfoSigned {
  /**
   * @generated from protobuf field: optional bytes info = 1;
   */
  info?: Uint8Array;
  /**
   * @generated from protobuf field: optional bytes signature = 2;
   */
  signature?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSteamDatagramDiagnostic
 */
export interface CMsgSteamDatagramDiagnostic {
  /**
   * @generated from protobuf field: optional uint32 severity = 1;
   */
  severity?: number;
  /**
   * @generated from protobuf field: optional string text = 2;
   */
  text?: string;
}
/**
 * @generated from protobuf message CMsgSteamDatagramLinkInstantaneousStats
 */
export interface CMsgSteamDatagramLinkInstantaneousStats {
  /**
   * @generated from protobuf field: optional uint32 out_packets_per_sec_x10 = 1;
   */
  out_packets_per_sec_x10?: number;
  /**
   * @generated from protobuf field: optional uint32 out_bytes_per_sec = 2;
   */
  out_bytes_per_sec?: number;
  /**
   * @generated from protobuf field: optional uint32 in_packets_per_sec_x10 = 3;
   */
  in_packets_per_sec_x10?: number;
  /**
   * @generated from protobuf field: optional uint32 in_bytes_per_sec = 4;
   */
  in_bytes_per_sec?: number;
  /**
   * @generated from protobuf field: optional uint32 ping_ms = 5;
   */
  ping_ms?: number;
  /**
   * @generated from protobuf field: optional uint32 packets_dropped_pct = 6;
   */
  packets_dropped_pct?: number;
  /**
   * @generated from protobuf field: optional uint32 packets_weird_sequence_pct = 7;
   */
  packets_weird_sequence_pct?: number;
  /**
   * @generated from protobuf field: optional uint32 peak_jitter_usec = 8;
   */
  peak_jitter_usec?: number;
}
/**
 * @generated from protobuf message CMsgSteamDatagramLinkLifetimeStats
 */
export interface CMsgSteamDatagramLinkLifetimeStats {
  /**
   * @generated from protobuf field: optional uint32 connected_seconds = 2;
   */
  connected_seconds?: number;
  /**
   * @generated from protobuf field: optional uint64 packets_sent = 3;
   */
  packets_sent?: bigint;
  /**
   * @generated from protobuf field: optional uint64 kb_sent = 4;
   */
  kb_sent?: bigint;
  /**
   * @generated from protobuf field: optional uint64 packets_recv = 5;
   */
  packets_recv?: bigint;
  /**
   * @generated from protobuf field: optional uint64 kb_recv = 6;
   */
  kb_recv?: bigint;
  /**
   * @generated from protobuf field: optional uint64 packets_recv_sequenced = 7;
   */
  packets_recv_sequenced?: bigint;
  /**
   * @generated from protobuf field: optional uint64 packets_recv_dropped = 8;
   */
  packets_recv_dropped?: bigint;
  /**
   * @generated from protobuf field: optional uint64 packets_recv_out_of_order = 9;
   */
  packets_recv_out_of_order?: bigint;
  /**
   * @generated from protobuf field: optional uint64 packets_recv_out_of_order_corrected = 15;
   */
  packets_recv_out_of_order_corrected?: bigint;
  /**
   * @generated from protobuf field: optional uint64 packets_recv_duplicate = 10;
   */
  packets_recv_duplicate?: bigint;
  /**
   * @generated from protobuf field: optional uint64 packets_recv_lurch = 11;
   */
  packets_recv_lurch?: bigint;
  /**
   * @generated from protobuf field: repeated uint64 multipath_packets_recv_sequenced = 12;
   */
  multipath_packets_recv_sequenced: bigint[];
  /**
   * @generated from protobuf field: repeated uint64 multipath_packets_recv_later = 13;
   */
  multipath_packets_recv_later: bigint[];
  /**
   * @generated from protobuf field: optional uint32 multipath_send_enabled = 14;
   */
  multipath_send_enabled?: number;
  /**
   * @generated from protobuf field: optional uint32 quality_histogram_100 = 21;
   */
  quality_histogram_100?: number;
  /**
   * @generated from protobuf field: optional uint32 quality_histogram_99 = 22;
   */
  quality_histogram_99?: number;
  /**
   * @generated from protobuf field: optional uint32 quality_histogram_97 = 23;
   */
  quality_histogram_97?: number;
  /**
   * @generated from protobuf field: optional uint32 quality_histogram_95 = 24;
   */
  quality_histogram_95?: number;
  /**
   * @generated from protobuf field: optional uint32 quality_histogram_90 = 25;
   */
  quality_histogram_90?: number;
  /**
   * @generated from protobuf field: optional uint32 quality_histogram_75 = 26;
   */
  quality_histogram_75?: number;
  /**
   * @generated from protobuf field: optional uint32 quality_histogram_50 = 27;
   */
  quality_histogram_50?: number;
  /**
   * @generated from protobuf field: optional uint32 quality_histogram_1 = 28;
   */
  quality_histogram_1?: number;
  /**
   * @generated from protobuf field: optional uint32 quality_histogram_dead = 29;
   */
  quality_histogram_dead?: number;
  /**
   * @generated from protobuf field: optional uint32 quality_ntile_2nd = 30 [json_name = "qualityNtile2nd"];
   */
  quality_ntile_2nd?: number;
  /**
   * @generated from protobuf field: optional uint32 quality_ntile_5th = 31 [json_name = "qualityNtile5th"];
   */
  quality_ntile_5th?: number;
  /**
   * @generated from protobuf field: optional uint32 quality_ntile_25th = 32 [json_name = "qualityNtile25th"];
   */
  quality_ntile_25th?: number;
  /**
   * @generated from protobuf field: optional uint32 quality_ntile_50th = 33 [json_name = "qualityNtile50th"];
   */
  quality_ntile_50th?: number;
  /**
   * @generated from protobuf field: optional uint32 ping_histogram_25 = 41;
   */
  ping_histogram_25?: number;
  /**
   * @generated from protobuf field: optional uint32 ping_histogram_50 = 42;
   */
  ping_histogram_50?: number;
  /**
   * @generated from protobuf field: optional uint32 ping_histogram_75 = 43;
   */
  ping_histogram_75?: number;
  /**
   * @generated from protobuf field: optional uint32 ping_histogram_100 = 44;
   */
  ping_histogram_100?: number;
  /**
   * @generated from protobuf field: optional uint32 ping_histogram_125 = 45;
   */
  ping_histogram_125?: number;
  /**
   * @generated from protobuf field: optional uint32 ping_histogram_150 = 46;
   */
  ping_histogram_150?: number;
  /**
   * @generated from protobuf field: optional uint32 ping_histogram_200 = 47;
   */
  ping_histogram_200?: number;
  /**
   * @generated from protobuf field: optional uint32 ping_histogram_300 = 48;
   */
  ping_histogram_300?: number;
  /**
   * @generated from protobuf field: optional uint32 ping_histogram_max = 49;
   */
  ping_histogram_max?: number;
  /**
   * @generated from protobuf field: optional uint32 ping_ntile_5th = 50 [json_name = "pingNtile5th"];
   */
  ping_ntile_5th?: number;
  /**
   * @generated from protobuf field: optional uint32 ping_ntile_50th = 51 [json_name = "pingNtile50th"];
   */
  ping_ntile_50th?: number;
  /**
   * @generated from protobuf field: optional uint32 ping_ntile_75th = 52 [json_name = "pingNtile75th"];
   */
  ping_ntile_75th?: number;
  /**
   * @generated from protobuf field: optional uint32 ping_ntile_95th = 53 [json_name = "pingNtile95th"];
   */
  ping_ntile_95th?: number;
  /**
   * @generated from protobuf field: optional uint32 ping_ntile_98th = 54 [json_name = "pingNtile98th"];
   */
  ping_ntile_98th?: number;
  /**
   * @generated from protobuf field: optional uint32 jitter_histogram_negligible = 61;
   */
  jitter_histogram_negligible?: number;
  /**
   * @generated from protobuf field: optional uint32 jitter_histogram_1 = 62;
   */
  jitter_histogram_1?: number;
  /**
   * @generated from protobuf field: optional uint32 jitter_histogram_2 = 63;
   */
  jitter_histogram_2?: number;
  /**
   * @generated from protobuf field: optional uint32 jitter_histogram_5 = 64;
   */
  jitter_histogram_5?: number;
  /**
   * @generated from protobuf field: optional uint32 jitter_histogram_10 = 65;
   */
  jitter_histogram_10?: number;
  /**
   * @generated from protobuf field: optional uint32 jitter_histogram_20 = 66;
   */
  jitter_histogram_20?: number;
}
/**
 * @generated from protobuf message CMsgSteamDatagramConnectionQuality
 */
export interface CMsgSteamDatagramConnectionQuality {
  /**
   * @generated from protobuf field: optional CMsgSteamDatagramLinkInstantaneousStats instantaneous = 1;
   */
  instantaneous?: CMsgSteamDatagramLinkInstantaneousStats;
  /**
   * @generated from protobuf field: optional CMsgSteamDatagramLinkLifetimeStats lifetime = 2;
   */
  lifetime?: CMsgSteamDatagramLinkLifetimeStats;
}
/**
 * @generated from protobuf message CMsgICECandidate
 */
export interface CMsgICECandidate {
  /**
   * @generated from protobuf field: optional string candidate = 3;
   */
  candidate?: string;
}
/**
 * @generated from protobuf message CMsgICERendezvous
 */
export interface CMsgICERendezvous {
  /**
   * @generated from protobuf field: optional CMsgICERendezvous.Auth auth = 2;
   */
  auth?: CMsgICERendezvous_Auth;
  /**
   * @generated from protobuf field: optional CMsgICECandidate add_candidate = 1;
   */
  add_candidate?: CMsgICECandidate;
}
/**
 * @generated from protobuf message CMsgICERendezvous.Auth
 */
export interface CMsgICERendezvous_Auth {
  /**
   * @generated from protobuf field: optional string pwd_frag = 1;
   */
  pwd_frag?: string;
}
/**
 * @generated from protobuf message CMsgSteamNetworkingP2PRendezvous
 */
export interface CMsgSteamNetworkingP2PRendezvous {
  /**
   * @generated from protobuf field: optional string from_identity = 8;
   */
  from_identity?: string;
  /**
   * @generated from protobuf field: optional fixed32 from_connection_id = 9;
   */
  from_connection_id?: number;
  /**
   * @generated from protobuf field: optional string to_identity = 10;
   */
  to_identity?: string;
  /**
   * @generated from protobuf field: optional fixed32 to_connection_id = 1;
   */
  to_connection_id?: number;
  /**
   * @generated from protobuf field: optional bytes sdr_routes = 2;
   */
  sdr_routes?: Uint8Array;
  /**
   * @generated from protobuf field: optional uint32 ack_peer_routes_revision = 3;
   */
  ack_peer_routes_revision?: number;
  /**
   * @generated from protobuf field: optional bool ice_enabled = 7;
   */
  ice_enabled?: boolean;
  /**
   * @generated from protobuf field: optional bytes hosted_server_ticket = 14;
   */
  hosted_server_ticket?: Uint8Array;
  /**
   * @generated from protobuf field: optional CMsgSteamNetworkingP2PRendezvous.ConnectRequest connect_request = 4;
   */
  connect_request?: CMsgSteamNetworkingP2PRendezvous_ConnectRequest;
  /**
   * @generated from protobuf field: optional CMsgSteamNetworkingP2PRendezvous.ConnectOK connect_ok = 5;
   */
  connect_ok?: CMsgSteamNetworkingP2PRendezvous_ConnectOK;
  /**
   * @generated from protobuf field: optional CMsgSteamNetworkingP2PRendezvous.ConnectionClosed connection_closed = 6;
   */
  connection_closed?: CMsgSteamNetworkingP2PRendezvous_ConnectionClosed;
  /**
   * @generated from protobuf field: optional uint32 ack_reliable_msg = 11;
   */
  ack_reliable_msg?: number;
  /**
   * @generated from protobuf field: optional uint32 first_reliable_msg = 12;
   */
  first_reliable_msg?: number;
  /**
   * @generated from protobuf field: repeated CMsgSteamNetworkingP2PRendezvous.ReliableMessage reliable_messages = 13;
   */
  reliable_messages: CMsgSteamNetworkingP2PRendezvous_ReliableMessage[];
  /**
   * @generated from protobuf field: repeated CMsgSteamNetworkingP2PRendezvous.ApplicationMessage application_messages = 15;
   */
  application_messages: CMsgSteamNetworkingP2PRendezvous_ApplicationMessage[];
}
/**
 * @generated from protobuf message CMsgSteamNetworkingP2PRendezvous.ConnectRequest
 */
export interface CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
  /**
   * @generated from protobuf field: optional CMsgSteamDatagramSessionCryptInfoSigned crypt = 6;
   */
  crypt?: CMsgSteamDatagramSessionCryptInfoSigned;
  /**
   * @generated from protobuf field: optional CMsgSteamDatagramCertificateSigned cert = 7;
   */
  cert?: CMsgSteamDatagramCertificateSigned;
  /**
   * @generated from protobuf field: optional uint32 to_virtual_port = 9;
   */
  to_virtual_port?: number;
  /**
   * @generated from protobuf field: optional uint32 from_virtual_port = 10;
   */
  from_virtual_port?: number;
  /**
   * @generated from protobuf field: optional string from_fakeip = 11;
   */
  from_fakeip?: string;
}
/**
 * @generated from protobuf message CMsgSteamNetworkingP2PRendezvous.ConnectOK
 */
export interface CMsgSteamNetworkingP2PRendezvous_ConnectOK {
  /**
   * @generated from protobuf field: optional CMsgSteamDatagramSessionCryptInfoSigned crypt = 5;
   */
  crypt?: CMsgSteamDatagramSessionCryptInfoSigned;
  /**
   * @generated from protobuf field: optional CMsgSteamDatagramCertificateSigned cert = 6;
   */
  cert?: CMsgSteamDatagramCertificateSigned;
}
/**
 * @generated from protobuf message CMsgSteamNetworkingP2PRendezvous.ConnectionClosed
 */
export interface CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
  /**
   * @generated from protobuf field: optional string debug = 5;
   */
  debug?: string;
  /**
   * @generated from protobuf field: optional uint32 reason_code = 6;
   */
  reason_code?: number;
}
/**
 * @generated from protobuf message CMsgSteamNetworkingP2PRendezvous.ReliableMessage
 */
export interface CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
  /**
   * @generated from protobuf field: optional CMsgICERendezvous ice = 1;
   */
  ice?: CMsgICERendezvous;
}
/**
 * @generated from protobuf message CMsgSteamNetworkingP2PRendezvous.ApplicationMessage
 */
export interface CMsgSteamNetworkingP2PRendezvous_ApplicationMessage {
  /**
   * @generated from protobuf field: optional bytes data = 1;
   */
  data?: Uint8Array;
  /**
   * @generated from protobuf field: optional uint64 msg_num = 2;
   */
  msg_num?: bigint;
  /**
   * @generated from protobuf field: optional uint32 flags = 3;
   */
  flags?: number;
  /**
   * @generated from protobuf field: optional uint32 lane_idx = 4;
   */
  lane_idx?: number;
}
/**
 * @generated from protobuf message CMsgSteamNetworkingICESessionSummary
 */
export interface CMsgSteamNetworkingICESessionSummary {
  /**
   * @generated from protobuf field: optional uint32 failure_reason_code = 7;
   */
  failure_reason_code?: number;
  /**
   * @generated from protobuf field: optional uint32 local_candidate_types = 1;
   */
  local_candidate_types?: number;
  /**
   * @generated from protobuf field: optional uint32 remote_candidate_types = 2;
   */
  remote_candidate_types?: number;
  /**
   * @generated from protobuf field: optional uint32 initial_route_kind = 3;
   */
  initial_route_kind?: number;
  /**
   * @generated from protobuf field: optional uint32 initial_ping = 4;
   */
  initial_ping?: number;
  /**
   * @generated from protobuf field: optional uint32 initial_score = 6;
   */
  initial_score?: number;
  /**
   * @generated from protobuf field: optional uint32 negotiation_ms = 5;
   */
  negotiation_ms?: number;
  /**
   * @generated from protobuf field: optional uint32 best_route_kind = 16;
   */
  best_route_kind?: number;
  /**
   * @generated from protobuf field: optional uint32 best_ping = 17;
   */
  best_ping?: number;
  /**
   * @generated from protobuf field: optional uint32 best_score = 18;
   */
  best_score?: number;
  /**
   * @generated from protobuf field: optional uint32 best_time = 19;
   */
  best_time?: number;
  /**
   * @generated from protobuf field: optional uint32 selected_seconds = 12;
   */
  selected_seconds?: number;
  /**
   * @generated from protobuf field: optional uint32 user_settings = 13;
   */
  user_settings?: number;
  /**
   * @generated from protobuf field: optional uint32 ice_enable_var = 14;
   */
  ice_enable_var?: number;
  /**
   * @generated from protobuf field: optional uint32 local_candidate_types_allowed = 15;
   */
  local_candidate_types_allowed?: number;
}
/**
 * @generated from protobuf enum ESteamNetworkingSocketsCipher
 */
export enum ESteamNetworkingSocketsCipher {
  /**
   * @generated from protobuf enum value: k_ESteamNetworkingSocketsCipher_INVALID = 0;
   */
  k_ESteamNetworkingSocketsCipher_INVALID = 0,
  /**
   * @generated from protobuf enum value: k_ESteamNetworkingSocketsCipher_NULL = 1;
   */
  k_ESteamNetworkingSocketsCipher_NULL = 1,
  /**
   * @generated from protobuf enum value: k_ESteamNetworkingSocketsCipher_AES_256_GCM = 2;
   */
  k_ESteamNetworkingSocketsCipher_AES_256_GCM = 2,
}
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramSessionCryptInfo$Type extends MessageType<CMsgSteamDatagramSessionCryptInfo> {
  constructor() {
    super("CMsgSteamDatagramSessionCryptInfo", [
      {
        no: 1,
        name: "key_type",
        kind: "enum",
        localName: "key_type",
        opt: true,
        T: () => ["CMsgSteamDatagramSessionCryptInfo.EKeyType", CMsgSteamDatagramSessionCryptInfo_EKeyType],
      },
      {
        no: 2,
        name: "key_data",
        kind: "scalar",
        localName: "key_data",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 3,
        name: "nonce",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 4,
        name: "protocol_version",
        kind: "scalar",
        localName: "protocol_version",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "ciphers",
        kind: "enum",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ["ESteamNetworkingSocketsCipher", ESteamNetworkingSocketsCipher],
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSteamDatagramSessionCryptInfo>): CMsgSteamDatagramSessionCryptInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.ciphers = [];
    if (value !== undefined) reflectionMergePartial<CMsgSteamDatagramSessionCryptInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSteamDatagramSessionCryptInfo,
  ): CMsgSteamDatagramSessionCryptInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgSteamDatagramSessionCryptInfo.EKeyType key_type */ 1:
          message.key_type = reader.int32();
          break;
        case /* optional bytes key_data */ 2:
          message.key_data = reader.bytes();
          break;
        case /* optional fixed64 nonce */ 3:
          message.nonce = reader.fixed64().toBigInt();
          break;
        case /* optional uint32 protocol_version */ 4:
          message.protocol_version = reader.uint32();
          break;
        case /* repeated ESteamNetworkingSocketsCipher ciphers */ 5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.ciphers.push(reader.int32());
          else message.ciphers.push(reader.int32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSteamDatagramSessionCryptInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgSteamDatagramSessionCryptInfo.EKeyType key_type = 1; */
    if (message.key_type !== undefined) writer.tag(1, WireType.Varint).int32(message.key_type);
    /* optional bytes key_data = 2; */
    if (message.key_data !== undefined) writer.tag(2, WireType.LengthDelimited).bytes(message.key_data);
    /* optional fixed64 nonce = 3; */
    if (message.nonce !== undefined) writer.tag(3, WireType.Bit64).fixed64(message.nonce);
    /* optional uint32 protocol_version = 4; */
    if (message.protocol_version !== undefined) writer.tag(4, WireType.Varint).uint32(message.protocol_version);
    /* repeated ESteamNetworkingSocketsCipher ciphers = 5; */
    for (let i = 0; i < message.ciphers.length; i++) writer.tag(5, WireType.Varint).int32(message.ciphers[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramSessionCryptInfo
 */
export const CMsgSteamDatagramSessionCryptInfo = new CMsgSteamDatagramSessionCryptInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramSessionCryptInfoSigned$Type extends MessageType<CMsgSteamDatagramSessionCryptInfoSigned> {
  constructor() {
    super("CMsgSteamDatagramSessionCryptInfoSigned", [
      {
        no: 1,
        name: "info",
        kind: "scalar",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 2,
        name: "signature",
        kind: "scalar",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSteamDatagramSessionCryptInfoSigned>): CMsgSteamDatagramSessionCryptInfoSigned {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSteamDatagramSessionCryptInfoSigned>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSteamDatagramSessionCryptInfoSigned,
  ): CMsgSteamDatagramSessionCryptInfoSigned {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bytes info */ 1:
          message.info = reader.bytes();
          break;
        case /* optional bytes signature */ 2:
          message.signature = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSteamDatagramSessionCryptInfoSigned,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional bytes info = 1; */
    if (message.info !== undefined) writer.tag(1, WireType.LengthDelimited).bytes(message.info);
    /* optional bytes signature = 2; */
    if (message.signature !== undefined) writer.tag(2, WireType.LengthDelimited).bytes(message.signature);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramSessionCryptInfoSigned
 */
export const CMsgSteamDatagramSessionCryptInfoSigned = new CMsgSteamDatagramSessionCryptInfoSigned$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramDiagnostic$Type extends MessageType<CMsgSteamDatagramDiagnostic> {
  constructor() {
    super("CMsgSteamDatagramDiagnostic", [
      {
        no: 1,
        name: "severity",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "text",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSteamDatagramDiagnostic>): CMsgSteamDatagramDiagnostic {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSteamDatagramDiagnostic>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSteamDatagramDiagnostic,
  ): CMsgSteamDatagramDiagnostic {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 severity */ 1:
          message.severity = reader.uint32();
          break;
        case /* optional string text */ 2:
          message.text = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSteamDatagramDiagnostic,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 severity = 1; */
    if (message.severity !== undefined) writer.tag(1, WireType.Varint).uint32(message.severity);
    /* optional string text = 2; */
    if (message.text !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.text);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramDiagnostic
 */
export const CMsgSteamDatagramDiagnostic = new CMsgSteamDatagramDiagnostic$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramLinkInstantaneousStats$Type extends MessageType<CMsgSteamDatagramLinkInstantaneousStats> {
  constructor() {
    super("CMsgSteamDatagramLinkInstantaneousStats", [
      {
        no: 1,
        name: "out_packets_per_sec_x10",
        kind: "scalar",
        localName: "out_packets_per_sec_x10",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "out_bytes_per_sec",
        kind: "scalar",
        localName: "out_bytes_per_sec",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "in_packets_per_sec_x10",
        kind: "scalar",
        localName: "in_packets_per_sec_x10",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "in_bytes_per_sec",
        kind: "scalar",
        localName: "in_bytes_per_sec",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "ping_ms",
        kind: "scalar",
        localName: "ping_ms",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "packets_dropped_pct",
        kind: "scalar",
        localName: "packets_dropped_pct",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 7,
        name: "packets_weird_sequence_pct",
        kind: "scalar",
        localName: "packets_weird_sequence_pct",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 8,
        name: "peak_jitter_usec",
        kind: "scalar",
        localName: "peak_jitter_usec",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSteamDatagramLinkInstantaneousStats>): CMsgSteamDatagramLinkInstantaneousStats {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSteamDatagramLinkInstantaneousStats>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSteamDatagramLinkInstantaneousStats,
  ): CMsgSteamDatagramLinkInstantaneousStats {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 out_packets_per_sec_x10 */ 1:
          message.out_packets_per_sec_x10 = reader.uint32();
          break;
        case /* optional uint32 out_bytes_per_sec */ 2:
          message.out_bytes_per_sec = reader.uint32();
          break;
        case /* optional uint32 in_packets_per_sec_x10 */ 3:
          message.in_packets_per_sec_x10 = reader.uint32();
          break;
        case /* optional uint32 in_bytes_per_sec */ 4:
          message.in_bytes_per_sec = reader.uint32();
          break;
        case /* optional uint32 ping_ms */ 5:
          message.ping_ms = reader.uint32();
          break;
        case /* optional uint32 packets_dropped_pct */ 6:
          message.packets_dropped_pct = reader.uint32();
          break;
        case /* optional uint32 packets_weird_sequence_pct */ 7:
          message.packets_weird_sequence_pct = reader.uint32();
          break;
        case /* optional uint32 peak_jitter_usec */ 8:
          message.peak_jitter_usec = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSteamDatagramLinkInstantaneousStats,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 out_packets_per_sec_x10 = 1; */
    if (message.out_packets_per_sec_x10 !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.out_packets_per_sec_x10);
    /* optional uint32 out_bytes_per_sec = 2; */
    if (message.out_bytes_per_sec !== undefined) writer.tag(2, WireType.Varint).uint32(message.out_bytes_per_sec);
    /* optional uint32 in_packets_per_sec_x10 = 3; */
    if (message.in_packets_per_sec_x10 !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.in_packets_per_sec_x10);
    /* optional uint32 in_bytes_per_sec = 4; */
    if (message.in_bytes_per_sec !== undefined) writer.tag(4, WireType.Varint).uint32(message.in_bytes_per_sec);
    /* optional uint32 ping_ms = 5; */
    if (message.ping_ms !== undefined) writer.tag(5, WireType.Varint).uint32(message.ping_ms);
    /* optional uint32 packets_dropped_pct = 6; */
    if (message.packets_dropped_pct !== undefined) writer.tag(6, WireType.Varint).uint32(message.packets_dropped_pct);
    /* optional uint32 packets_weird_sequence_pct = 7; */
    if (message.packets_weird_sequence_pct !== undefined)
      writer.tag(7, WireType.Varint).uint32(message.packets_weird_sequence_pct);
    /* optional uint32 peak_jitter_usec = 8; */
    if (message.peak_jitter_usec !== undefined) writer.tag(8, WireType.Varint).uint32(message.peak_jitter_usec);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramLinkInstantaneousStats
 */
export const CMsgSteamDatagramLinkInstantaneousStats = new CMsgSteamDatagramLinkInstantaneousStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramLinkLifetimeStats$Type extends MessageType<CMsgSteamDatagramLinkLifetimeStats> {
  constructor() {
    super("CMsgSteamDatagramLinkLifetimeStats", [
      {
        no: 2,
        name: "connected_seconds",
        kind: "scalar",
        localName: "connected_seconds",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "packets_sent",
        kind: "scalar",
        localName: "packets_sent",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 4,
        name: "kb_sent",
        kind: "scalar",
        localName: "kb_sent",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 5,
        name: "packets_recv",
        kind: "scalar",
        localName: "packets_recv",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 6,
        name: "kb_recv",
        kind: "scalar",
        localName: "kb_recv",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 7,
        name: "packets_recv_sequenced",
        kind: "scalar",
        localName: "packets_recv_sequenced",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 8,
        name: "packets_recv_dropped",
        kind: "scalar",
        localName: "packets_recv_dropped",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 9,
        name: "packets_recv_out_of_order",
        kind: "scalar",
        localName: "packets_recv_out_of_order",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 15,
        name: "packets_recv_out_of_order_corrected",
        kind: "scalar",
        localName: "packets_recv_out_of_order_corrected",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 10,
        name: "packets_recv_duplicate",
        kind: "scalar",
        localName: "packets_recv_duplicate",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 11,
        name: "packets_recv_lurch",
        kind: "scalar",
        localName: "packets_recv_lurch",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 12,
        name: "multipath_packets_recv_sequenced",
        kind: "scalar",
        localName: "multipath_packets_recv_sequenced",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 13,
        name: "multipath_packets_recv_later",
        kind: "scalar",
        localName: "multipath_packets_recv_later",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 14,
        name: "multipath_send_enabled",
        kind: "scalar",
        localName: "multipath_send_enabled",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 21,
        name: "quality_histogram_100",
        kind: "scalar",
        localName: "quality_histogram_100",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 22,
        name: "quality_histogram_99",
        kind: "scalar",
        localName: "quality_histogram_99",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 23,
        name: "quality_histogram_97",
        kind: "scalar",
        localName: "quality_histogram_97",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 24,
        name: "quality_histogram_95",
        kind: "scalar",
        localName: "quality_histogram_95",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 25,
        name: "quality_histogram_90",
        kind: "scalar",
        localName: "quality_histogram_90",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 26,
        name: "quality_histogram_75",
        kind: "scalar",
        localName: "quality_histogram_75",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 27,
        name: "quality_histogram_50",
        kind: "scalar",
        localName: "quality_histogram_50",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 28,
        name: "quality_histogram_1",
        kind: "scalar",
        localName: "quality_histogram_1",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 29,
        name: "quality_histogram_dead",
        kind: "scalar",
        localName: "quality_histogram_dead",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 30,
        name: "quality_ntile_2nd",
        kind: "scalar",
        localName: "quality_ntile_2nd",
        jsonName: "qualityNtile2nd",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 31,
        name: "quality_ntile_5th",
        kind: "scalar",
        localName: "quality_ntile_5th",
        jsonName: "qualityNtile5th",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 32,
        name: "quality_ntile_25th",
        kind: "scalar",
        localName: "quality_ntile_25th",
        jsonName: "qualityNtile25th",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 33,
        name: "quality_ntile_50th",
        kind: "scalar",
        localName: "quality_ntile_50th",
        jsonName: "qualityNtile50th",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 41,
        name: "ping_histogram_25",
        kind: "scalar",
        localName: "ping_histogram_25",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 42,
        name: "ping_histogram_50",
        kind: "scalar",
        localName: "ping_histogram_50",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 43,
        name: "ping_histogram_75",
        kind: "scalar",
        localName: "ping_histogram_75",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 44,
        name: "ping_histogram_100",
        kind: "scalar",
        localName: "ping_histogram_100",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 45,
        name: "ping_histogram_125",
        kind: "scalar",
        localName: "ping_histogram_125",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 46,
        name: "ping_histogram_150",
        kind: "scalar",
        localName: "ping_histogram_150",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 47,
        name: "ping_histogram_200",
        kind: "scalar",
        localName: "ping_histogram_200",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 48,
        name: "ping_histogram_300",
        kind: "scalar",
        localName: "ping_histogram_300",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 49,
        name: "ping_histogram_max",
        kind: "scalar",
        localName: "ping_histogram_max",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 50,
        name: "ping_ntile_5th",
        kind: "scalar",
        localName: "ping_ntile_5th",
        jsonName: "pingNtile5th",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 51,
        name: "ping_ntile_50th",
        kind: "scalar",
        localName: "ping_ntile_50th",
        jsonName: "pingNtile50th",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 52,
        name: "ping_ntile_75th",
        kind: "scalar",
        localName: "ping_ntile_75th",
        jsonName: "pingNtile75th",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 53,
        name: "ping_ntile_95th",
        kind: "scalar",
        localName: "ping_ntile_95th",
        jsonName: "pingNtile95th",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 54,
        name: "ping_ntile_98th",
        kind: "scalar",
        localName: "ping_ntile_98th",
        jsonName: "pingNtile98th",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 61,
        name: "jitter_histogram_negligible",
        kind: "scalar",
        localName: "jitter_histogram_negligible",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 62,
        name: "jitter_histogram_1",
        kind: "scalar",
        localName: "jitter_histogram_1",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 63,
        name: "jitter_histogram_2",
        kind: "scalar",
        localName: "jitter_histogram_2",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 64,
        name: "jitter_histogram_5",
        kind: "scalar",
        localName: "jitter_histogram_5",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 65,
        name: "jitter_histogram_10",
        kind: "scalar",
        localName: "jitter_histogram_10",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 66,
        name: "jitter_histogram_20",
        kind: "scalar",
        localName: "jitter_histogram_20",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSteamDatagramLinkLifetimeStats>): CMsgSteamDatagramLinkLifetimeStats {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.multipath_packets_recv_sequenced = [];
    message.multipath_packets_recv_later = [];
    if (value !== undefined) reflectionMergePartial<CMsgSteamDatagramLinkLifetimeStats>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSteamDatagramLinkLifetimeStats,
  ): CMsgSteamDatagramLinkLifetimeStats {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 connected_seconds */ 2:
          message.connected_seconds = reader.uint32();
          break;
        case /* optional uint64 packets_sent */ 3:
          message.packets_sent = reader.uint64().toBigInt();
          break;
        case /* optional uint64 kb_sent */ 4:
          message.kb_sent = reader.uint64().toBigInt();
          break;
        case /* optional uint64 packets_recv */ 5:
          message.packets_recv = reader.uint64().toBigInt();
          break;
        case /* optional uint64 kb_recv */ 6:
          message.kb_recv = reader.uint64().toBigInt();
          break;
        case /* optional uint64 packets_recv_sequenced */ 7:
          message.packets_recv_sequenced = reader.uint64().toBigInt();
          break;
        case /* optional uint64 packets_recv_dropped */ 8:
          message.packets_recv_dropped = reader.uint64().toBigInt();
          break;
        case /* optional uint64 packets_recv_out_of_order */ 9:
          message.packets_recv_out_of_order = reader.uint64().toBigInt();
          break;
        case /* optional uint64 packets_recv_out_of_order_corrected */ 15:
          message.packets_recv_out_of_order_corrected = reader.uint64().toBigInt();
          break;
        case /* optional uint64 packets_recv_duplicate */ 10:
          message.packets_recv_duplicate = reader.uint64().toBigInt();
          break;
        case /* optional uint64 packets_recv_lurch */ 11:
          message.packets_recv_lurch = reader.uint64().toBigInt();
          break;
        case /* repeated uint64 multipath_packets_recv_sequenced */ 12:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.multipath_packets_recv_sequenced.push(reader.uint64().toBigInt());
          else message.multipath_packets_recv_sequenced.push(reader.uint64().toBigInt());
          break;
        case /* repeated uint64 multipath_packets_recv_later */ 13:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.multipath_packets_recv_later.push(reader.uint64().toBigInt());
          else message.multipath_packets_recv_later.push(reader.uint64().toBigInt());
          break;
        case /* optional uint32 multipath_send_enabled */ 14:
          message.multipath_send_enabled = reader.uint32();
          break;
        case /* optional uint32 quality_histogram_100 */ 21:
          message.quality_histogram_100 = reader.uint32();
          break;
        case /* optional uint32 quality_histogram_99 */ 22:
          message.quality_histogram_99 = reader.uint32();
          break;
        case /* optional uint32 quality_histogram_97 */ 23:
          message.quality_histogram_97 = reader.uint32();
          break;
        case /* optional uint32 quality_histogram_95 */ 24:
          message.quality_histogram_95 = reader.uint32();
          break;
        case /* optional uint32 quality_histogram_90 */ 25:
          message.quality_histogram_90 = reader.uint32();
          break;
        case /* optional uint32 quality_histogram_75 */ 26:
          message.quality_histogram_75 = reader.uint32();
          break;
        case /* optional uint32 quality_histogram_50 */ 27:
          message.quality_histogram_50 = reader.uint32();
          break;
        case /* optional uint32 quality_histogram_1 */ 28:
          message.quality_histogram_1 = reader.uint32();
          break;
        case /* optional uint32 quality_histogram_dead */ 29:
          message.quality_histogram_dead = reader.uint32();
          break;
        case /* optional uint32 quality_ntile_2nd = 30 [json_name = "qualityNtile2nd"];*/ 30:
          message.quality_ntile_2nd = reader.uint32();
          break;
        case /* optional uint32 quality_ntile_5th = 31 [json_name = "qualityNtile5th"];*/ 31:
          message.quality_ntile_5th = reader.uint32();
          break;
        case /* optional uint32 quality_ntile_25th = 32 [json_name = "qualityNtile25th"];*/ 32:
          message.quality_ntile_25th = reader.uint32();
          break;
        case /* optional uint32 quality_ntile_50th = 33 [json_name = "qualityNtile50th"];*/ 33:
          message.quality_ntile_50th = reader.uint32();
          break;
        case /* optional uint32 ping_histogram_25 */ 41:
          message.ping_histogram_25 = reader.uint32();
          break;
        case /* optional uint32 ping_histogram_50 */ 42:
          message.ping_histogram_50 = reader.uint32();
          break;
        case /* optional uint32 ping_histogram_75 */ 43:
          message.ping_histogram_75 = reader.uint32();
          break;
        case /* optional uint32 ping_histogram_100 */ 44:
          message.ping_histogram_100 = reader.uint32();
          break;
        case /* optional uint32 ping_histogram_125 */ 45:
          message.ping_histogram_125 = reader.uint32();
          break;
        case /* optional uint32 ping_histogram_150 */ 46:
          message.ping_histogram_150 = reader.uint32();
          break;
        case /* optional uint32 ping_histogram_200 */ 47:
          message.ping_histogram_200 = reader.uint32();
          break;
        case /* optional uint32 ping_histogram_300 */ 48:
          message.ping_histogram_300 = reader.uint32();
          break;
        case /* optional uint32 ping_histogram_max */ 49:
          message.ping_histogram_max = reader.uint32();
          break;
        case /* optional uint32 ping_ntile_5th = 50 [json_name = "pingNtile5th"];*/ 50:
          message.ping_ntile_5th = reader.uint32();
          break;
        case /* optional uint32 ping_ntile_50th = 51 [json_name = "pingNtile50th"];*/ 51:
          message.ping_ntile_50th = reader.uint32();
          break;
        case /* optional uint32 ping_ntile_75th = 52 [json_name = "pingNtile75th"];*/ 52:
          message.ping_ntile_75th = reader.uint32();
          break;
        case /* optional uint32 ping_ntile_95th = 53 [json_name = "pingNtile95th"];*/ 53:
          message.ping_ntile_95th = reader.uint32();
          break;
        case /* optional uint32 ping_ntile_98th = 54 [json_name = "pingNtile98th"];*/ 54:
          message.ping_ntile_98th = reader.uint32();
          break;
        case /* optional uint32 jitter_histogram_negligible */ 61:
          message.jitter_histogram_negligible = reader.uint32();
          break;
        case /* optional uint32 jitter_histogram_1 */ 62:
          message.jitter_histogram_1 = reader.uint32();
          break;
        case /* optional uint32 jitter_histogram_2 */ 63:
          message.jitter_histogram_2 = reader.uint32();
          break;
        case /* optional uint32 jitter_histogram_5 */ 64:
          message.jitter_histogram_5 = reader.uint32();
          break;
        case /* optional uint32 jitter_histogram_10 */ 65:
          message.jitter_histogram_10 = reader.uint32();
          break;
        case /* optional uint32 jitter_histogram_20 */ 66:
          message.jitter_histogram_20 = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSteamDatagramLinkLifetimeStats,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 connected_seconds = 2; */
    if (message.connected_seconds !== undefined) writer.tag(2, WireType.Varint).uint32(message.connected_seconds);
    /* optional uint64 packets_sent = 3; */
    if (message.packets_sent !== undefined) writer.tag(3, WireType.Varint).uint64(message.packets_sent);
    /* optional uint64 kb_sent = 4; */
    if (message.kb_sent !== undefined) writer.tag(4, WireType.Varint).uint64(message.kb_sent);
    /* optional uint64 packets_recv = 5; */
    if (message.packets_recv !== undefined) writer.tag(5, WireType.Varint).uint64(message.packets_recv);
    /* optional uint64 kb_recv = 6; */
    if (message.kb_recv !== undefined) writer.tag(6, WireType.Varint).uint64(message.kb_recv);
    /* optional uint64 packets_recv_sequenced = 7; */
    if (message.packets_recv_sequenced !== undefined)
      writer.tag(7, WireType.Varint).uint64(message.packets_recv_sequenced);
    /* optional uint64 packets_recv_dropped = 8; */
    if (message.packets_recv_dropped !== undefined) writer.tag(8, WireType.Varint).uint64(message.packets_recv_dropped);
    /* optional uint64 packets_recv_out_of_order = 9; */
    if (message.packets_recv_out_of_order !== undefined)
      writer.tag(9, WireType.Varint).uint64(message.packets_recv_out_of_order);
    /* optional uint64 packets_recv_out_of_order_corrected = 15; */
    if (message.packets_recv_out_of_order_corrected !== undefined)
      writer.tag(15, WireType.Varint).uint64(message.packets_recv_out_of_order_corrected);
    /* optional uint64 packets_recv_duplicate = 10; */
    if (message.packets_recv_duplicate !== undefined)
      writer.tag(10, WireType.Varint).uint64(message.packets_recv_duplicate);
    /* optional uint64 packets_recv_lurch = 11; */
    if (message.packets_recv_lurch !== undefined) writer.tag(11, WireType.Varint).uint64(message.packets_recv_lurch);
    /* repeated uint64 multipath_packets_recv_sequenced = 12; */
    for (let i = 0; i < message.multipath_packets_recv_sequenced.length; i++)
      writer.tag(12, WireType.Varint).uint64(message.multipath_packets_recv_sequenced[i]);
    /* repeated uint64 multipath_packets_recv_later = 13; */
    for (let i = 0; i < message.multipath_packets_recv_later.length; i++)
      writer.tag(13, WireType.Varint).uint64(message.multipath_packets_recv_later[i]);
    /* optional uint32 multipath_send_enabled = 14; */
    if (message.multipath_send_enabled !== undefined)
      writer.tag(14, WireType.Varint).uint32(message.multipath_send_enabled);
    /* optional uint32 quality_histogram_100 = 21; */
    if (message.quality_histogram_100 !== undefined)
      writer.tag(21, WireType.Varint).uint32(message.quality_histogram_100);
    /* optional uint32 quality_histogram_99 = 22; */
    if (message.quality_histogram_99 !== undefined)
      writer.tag(22, WireType.Varint).uint32(message.quality_histogram_99);
    /* optional uint32 quality_histogram_97 = 23; */
    if (message.quality_histogram_97 !== undefined)
      writer.tag(23, WireType.Varint).uint32(message.quality_histogram_97);
    /* optional uint32 quality_histogram_95 = 24; */
    if (message.quality_histogram_95 !== undefined)
      writer.tag(24, WireType.Varint).uint32(message.quality_histogram_95);
    /* optional uint32 quality_histogram_90 = 25; */
    if (message.quality_histogram_90 !== undefined)
      writer.tag(25, WireType.Varint).uint32(message.quality_histogram_90);
    /* optional uint32 quality_histogram_75 = 26; */
    if (message.quality_histogram_75 !== undefined)
      writer.tag(26, WireType.Varint).uint32(message.quality_histogram_75);
    /* optional uint32 quality_histogram_50 = 27; */
    if (message.quality_histogram_50 !== undefined)
      writer.tag(27, WireType.Varint).uint32(message.quality_histogram_50);
    /* optional uint32 quality_histogram_1 = 28; */
    if (message.quality_histogram_1 !== undefined) writer.tag(28, WireType.Varint).uint32(message.quality_histogram_1);
    /* optional uint32 quality_histogram_dead = 29; */
    if (message.quality_histogram_dead !== undefined)
      writer.tag(29, WireType.Varint).uint32(message.quality_histogram_dead);
    /* optional uint32 quality_ntile_2nd = 30 [json_name = "qualityNtile2nd"]; */
    if (message.quality_ntile_2nd !== undefined) writer.tag(30, WireType.Varint).uint32(message.quality_ntile_2nd);
    /* optional uint32 quality_ntile_5th = 31 [json_name = "qualityNtile5th"]; */
    if (message.quality_ntile_5th !== undefined) writer.tag(31, WireType.Varint).uint32(message.quality_ntile_5th);
    /* optional uint32 quality_ntile_25th = 32 [json_name = "qualityNtile25th"]; */
    if (message.quality_ntile_25th !== undefined) writer.tag(32, WireType.Varint).uint32(message.quality_ntile_25th);
    /* optional uint32 quality_ntile_50th = 33 [json_name = "qualityNtile50th"]; */
    if (message.quality_ntile_50th !== undefined) writer.tag(33, WireType.Varint).uint32(message.quality_ntile_50th);
    /* optional uint32 ping_histogram_25 = 41; */
    if (message.ping_histogram_25 !== undefined) writer.tag(41, WireType.Varint).uint32(message.ping_histogram_25);
    /* optional uint32 ping_histogram_50 = 42; */
    if (message.ping_histogram_50 !== undefined) writer.tag(42, WireType.Varint).uint32(message.ping_histogram_50);
    /* optional uint32 ping_histogram_75 = 43; */
    if (message.ping_histogram_75 !== undefined) writer.tag(43, WireType.Varint).uint32(message.ping_histogram_75);
    /* optional uint32 ping_histogram_100 = 44; */
    if (message.ping_histogram_100 !== undefined) writer.tag(44, WireType.Varint).uint32(message.ping_histogram_100);
    /* optional uint32 ping_histogram_125 = 45; */
    if (message.ping_histogram_125 !== undefined) writer.tag(45, WireType.Varint).uint32(message.ping_histogram_125);
    /* optional uint32 ping_histogram_150 = 46; */
    if (message.ping_histogram_150 !== undefined) writer.tag(46, WireType.Varint).uint32(message.ping_histogram_150);
    /* optional uint32 ping_histogram_200 = 47; */
    if (message.ping_histogram_200 !== undefined) writer.tag(47, WireType.Varint).uint32(message.ping_histogram_200);
    /* optional uint32 ping_histogram_300 = 48; */
    if (message.ping_histogram_300 !== undefined) writer.tag(48, WireType.Varint).uint32(message.ping_histogram_300);
    /* optional uint32 ping_histogram_max = 49; */
    if (message.ping_histogram_max !== undefined) writer.tag(49, WireType.Varint).uint32(message.ping_histogram_max);
    /* optional uint32 ping_ntile_5th = 50 [json_name = "pingNtile5th"]; */
    if (message.ping_ntile_5th !== undefined) writer.tag(50, WireType.Varint).uint32(message.ping_ntile_5th);
    /* optional uint32 ping_ntile_50th = 51 [json_name = "pingNtile50th"]; */
    if (message.ping_ntile_50th !== undefined) writer.tag(51, WireType.Varint).uint32(message.ping_ntile_50th);
    /* optional uint32 ping_ntile_75th = 52 [json_name = "pingNtile75th"]; */
    if (message.ping_ntile_75th !== undefined) writer.tag(52, WireType.Varint).uint32(message.ping_ntile_75th);
    /* optional uint32 ping_ntile_95th = 53 [json_name = "pingNtile95th"]; */
    if (message.ping_ntile_95th !== undefined) writer.tag(53, WireType.Varint).uint32(message.ping_ntile_95th);
    /* optional uint32 ping_ntile_98th = 54 [json_name = "pingNtile98th"]; */
    if (message.ping_ntile_98th !== undefined) writer.tag(54, WireType.Varint).uint32(message.ping_ntile_98th);
    /* optional uint32 jitter_histogram_negligible = 61; */
    if (message.jitter_histogram_negligible !== undefined)
      writer.tag(61, WireType.Varint).uint32(message.jitter_histogram_negligible);
    /* optional uint32 jitter_histogram_1 = 62; */
    if (message.jitter_histogram_1 !== undefined) writer.tag(62, WireType.Varint).uint32(message.jitter_histogram_1);
    /* optional uint32 jitter_histogram_2 = 63; */
    if (message.jitter_histogram_2 !== undefined) writer.tag(63, WireType.Varint).uint32(message.jitter_histogram_2);
    /* optional uint32 jitter_histogram_5 = 64; */
    if (message.jitter_histogram_5 !== undefined) writer.tag(64, WireType.Varint).uint32(message.jitter_histogram_5);
    /* optional uint32 jitter_histogram_10 = 65; */
    if (message.jitter_histogram_10 !== undefined) writer.tag(65, WireType.Varint).uint32(message.jitter_histogram_10);
    /* optional uint32 jitter_histogram_20 = 66; */
    if (message.jitter_histogram_20 !== undefined) writer.tag(66, WireType.Varint).uint32(message.jitter_histogram_20);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramLinkLifetimeStats
 */
export const CMsgSteamDatagramLinkLifetimeStats = new CMsgSteamDatagramLinkLifetimeStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramConnectionQuality$Type extends MessageType<CMsgSteamDatagramConnectionQuality> {
  constructor() {
    super("CMsgSteamDatagramConnectionQuality", [
      {
        no: 1,
        name: "instantaneous",
        kind: "message",
        T: () => CMsgSteamDatagramLinkInstantaneousStats,
      },
      {
        no: 2,
        name: "lifetime",
        kind: "message",
        T: () => CMsgSteamDatagramLinkLifetimeStats,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSteamDatagramConnectionQuality>): CMsgSteamDatagramConnectionQuality {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSteamDatagramConnectionQuality>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSteamDatagramConnectionQuality,
  ): CMsgSteamDatagramConnectionQuality {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgSteamDatagramLinkInstantaneousStats instantaneous */ 1:
          message.instantaneous = CMsgSteamDatagramLinkInstantaneousStats.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.instantaneous,
          );
          break;
        case /* optional CMsgSteamDatagramLinkLifetimeStats lifetime */ 2:
          message.lifetime = CMsgSteamDatagramLinkLifetimeStats.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.lifetime,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSteamDatagramConnectionQuality,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgSteamDatagramLinkInstantaneousStats instantaneous = 1; */
    if (message.instantaneous)
      CMsgSteamDatagramLinkInstantaneousStats.internalBinaryWrite(
        message.instantaneous,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgSteamDatagramLinkLifetimeStats lifetime = 2; */
    if (message.lifetime)
      CMsgSteamDatagramLinkLifetimeStats.internalBinaryWrite(
        message.lifetime,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramConnectionQuality
 */
export const CMsgSteamDatagramConnectionQuality = new CMsgSteamDatagramConnectionQuality$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgICECandidate$Type extends MessageType<CMsgICECandidate> {
  constructor() {
    super("CMsgICECandidate", [
      {
        no: 3,
        name: "candidate",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgICECandidate>): CMsgICECandidate {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgICECandidate>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgICECandidate,
  ): CMsgICECandidate {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string candidate */ 3:
          message.candidate = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgICECandidate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional string candidate = 3; */
    if (message.candidate !== undefined) writer.tag(3, WireType.LengthDelimited).string(message.candidate);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgICECandidate
 */
export const CMsgICECandidate = new CMsgICECandidate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgICERendezvous$Type extends MessageType<CMsgICERendezvous> {
  constructor() {
    super("CMsgICERendezvous", [
      { no: 2, name: "auth", kind: "message", T: () => CMsgICERendezvous_Auth },
      {
        no: 1,
        name: "add_candidate",
        kind: "message",
        localName: "add_candidate",
        T: () => CMsgICECandidate,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgICERendezvous>): CMsgICERendezvous {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgICERendezvous>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgICERendezvous,
  ): CMsgICERendezvous {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgICERendezvous.Auth auth */ 2:
          message.auth = CMsgICERendezvous_Auth.internalBinaryRead(reader, reader.uint32(), options, message.auth);
          break;
        case /* optional CMsgICECandidate add_candidate */ 1:
          message.add_candidate = CMsgICECandidate.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.add_candidate,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgICERendezvous, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional CMsgICERendezvous.Auth auth = 2; */
    if (message.auth)
      CMsgICERendezvous_Auth.internalBinaryWrite(
        message.auth,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgICECandidate add_candidate = 1; */
    if (message.add_candidate)
      CMsgICECandidate.internalBinaryWrite(
        message.add_candidate,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgICERendezvous
 */
export const CMsgICERendezvous = new CMsgICERendezvous$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgICERendezvous_Auth$Type extends MessageType<CMsgICERendezvous_Auth> {
  constructor() {
    super("CMsgICERendezvous.Auth", [
      {
        no: 1,
        name: "pwd_frag",
        kind: "scalar",
        localName: "pwd_frag",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgICERendezvous_Auth>): CMsgICERendezvous_Auth {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgICERendezvous_Auth>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgICERendezvous_Auth,
  ): CMsgICERendezvous_Auth {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string pwd_frag */ 1:
          message.pwd_frag = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgICERendezvous_Auth,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string pwd_frag = 1; */
    if (message.pwd_frag !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.pwd_frag);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgICERendezvous.Auth
 */
export const CMsgICERendezvous_Auth = new CMsgICERendezvous_Auth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingP2PRendezvous$Type extends MessageType<CMsgSteamNetworkingP2PRendezvous> {
  constructor() {
    super("CMsgSteamNetworkingP2PRendezvous", [
      {
        no: 8,
        name: "from_identity",
        kind: "scalar",
        localName: "from_identity",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 9,
        name: "from_connection_id",
        kind: "scalar",
        localName: "from_connection_id",
        opt: true,
        T: 7 /*ScalarType.FIXED32*/,
      },
      {
        no: 10,
        name: "to_identity",
        kind: "scalar",
        localName: "to_identity",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 1,
        name: "to_connection_id",
        kind: "scalar",
        localName: "to_connection_id",
        opt: true,
        T: 7 /*ScalarType.FIXED32*/,
      },
      {
        no: 2,
        name: "sdr_routes",
        kind: "scalar",
        localName: "sdr_routes",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 3,
        name: "ack_peer_routes_revision",
        kind: "scalar",
        localName: "ack_peer_routes_revision",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 7,
        name: "ice_enabled",
        kind: "scalar",
        localName: "ice_enabled",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 14,
        name: "hosted_server_ticket",
        kind: "scalar",
        localName: "hosted_server_ticket",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 4,
        name: "connect_request",
        kind: "message",
        localName: "connect_request",
        T: () => CMsgSteamNetworkingP2PRendezvous_ConnectRequest,
      },
      {
        no: 5,
        name: "connect_ok",
        kind: "message",
        localName: "connect_ok",
        T: () => CMsgSteamNetworkingP2PRendezvous_ConnectOK,
      },
      {
        no: 6,
        name: "connection_closed",
        kind: "message",
        localName: "connection_closed",
        T: () => CMsgSteamNetworkingP2PRendezvous_ConnectionClosed,
      },
      {
        no: 11,
        name: "ack_reliable_msg",
        kind: "scalar",
        localName: "ack_reliable_msg",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 12,
        name: "first_reliable_msg",
        kind: "scalar",
        localName: "first_reliable_msg",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 13,
        name: "reliable_messages",
        kind: "message",
        localName: "reliable_messages",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgSteamNetworkingP2PRendezvous_ReliableMessage,
      },
      {
        no: 15,
        name: "application_messages",
        kind: "message",
        localName: "application_messages",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgSteamNetworkingP2PRendezvous_ApplicationMessage,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSteamNetworkingP2PRendezvous>): CMsgSteamNetworkingP2PRendezvous {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.reliable_messages = [];
    message.application_messages = [];
    if (value !== undefined) reflectionMergePartial<CMsgSteamNetworkingP2PRendezvous>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSteamNetworkingP2PRendezvous,
  ): CMsgSteamNetworkingP2PRendezvous {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string from_identity */ 8:
          message.from_identity = reader.string();
          break;
        case /* optional fixed32 from_connection_id */ 9:
          message.from_connection_id = reader.fixed32();
          break;
        case /* optional string to_identity */ 10:
          message.to_identity = reader.string();
          break;
        case /* optional fixed32 to_connection_id */ 1:
          message.to_connection_id = reader.fixed32();
          break;
        case /* optional bytes sdr_routes */ 2:
          message.sdr_routes = reader.bytes();
          break;
        case /* optional uint32 ack_peer_routes_revision */ 3:
          message.ack_peer_routes_revision = reader.uint32();
          break;
        case /* optional bool ice_enabled */ 7:
          message.ice_enabled = reader.bool();
          break;
        case /* optional bytes hosted_server_ticket */ 14:
          message.hosted_server_ticket = reader.bytes();
          break;
        case /* optional CMsgSteamNetworkingP2PRendezvous.ConnectRequest connect_request */ 4:
          message.connect_request = CMsgSteamNetworkingP2PRendezvous_ConnectRequest.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.connect_request,
          );
          break;
        case /* optional CMsgSteamNetworkingP2PRendezvous.ConnectOK connect_ok */ 5:
          message.connect_ok = CMsgSteamNetworkingP2PRendezvous_ConnectOK.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.connect_ok,
          );
          break;
        case /* optional CMsgSteamNetworkingP2PRendezvous.ConnectionClosed connection_closed */ 6:
          message.connection_closed = CMsgSteamNetworkingP2PRendezvous_ConnectionClosed.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.connection_closed,
          );
          break;
        case /* optional uint32 ack_reliable_msg */ 11:
          message.ack_reliable_msg = reader.uint32();
          break;
        case /* optional uint32 first_reliable_msg */ 12:
          message.first_reliable_msg = reader.uint32();
          break;
        case /* repeated CMsgSteamNetworkingP2PRendezvous.ReliableMessage reliable_messages */ 13:
          message.reliable_messages.push(
            CMsgSteamNetworkingP2PRendezvous_ReliableMessage.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated CMsgSteamNetworkingP2PRendezvous.ApplicationMessage application_messages */ 15:
          message.application_messages.push(
            CMsgSteamNetworkingP2PRendezvous_ApplicationMessage.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSteamNetworkingP2PRendezvous,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string from_identity = 8; */
    if (message.from_identity !== undefined) writer.tag(8, WireType.LengthDelimited).string(message.from_identity);
    /* optional fixed32 from_connection_id = 9; */
    if (message.from_connection_id !== undefined) writer.tag(9, WireType.Bit32).fixed32(message.from_connection_id);
    /* optional string to_identity = 10; */
    if (message.to_identity !== undefined) writer.tag(10, WireType.LengthDelimited).string(message.to_identity);
    /* optional fixed32 to_connection_id = 1; */
    if (message.to_connection_id !== undefined) writer.tag(1, WireType.Bit32).fixed32(message.to_connection_id);
    /* optional bytes sdr_routes = 2; */
    if (message.sdr_routes !== undefined) writer.tag(2, WireType.LengthDelimited).bytes(message.sdr_routes);
    /* optional uint32 ack_peer_routes_revision = 3; */
    if (message.ack_peer_routes_revision !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.ack_peer_routes_revision);
    /* optional bool ice_enabled = 7; */
    if (message.ice_enabled !== undefined) writer.tag(7, WireType.Varint).bool(message.ice_enabled);
    /* optional bytes hosted_server_ticket = 14; */
    if (message.hosted_server_ticket !== undefined)
      writer.tag(14, WireType.LengthDelimited).bytes(message.hosted_server_ticket);
    /* optional CMsgSteamNetworkingP2PRendezvous.ConnectRequest connect_request = 4; */
    if (message.connect_request)
      CMsgSteamNetworkingP2PRendezvous_ConnectRequest.internalBinaryWrite(
        message.connect_request,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgSteamNetworkingP2PRendezvous.ConnectOK connect_ok = 5; */
    if (message.connect_ok)
      CMsgSteamNetworkingP2PRendezvous_ConnectOK.internalBinaryWrite(
        message.connect_ok,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgSteamNetworkingP2PRendezvous.ConnectionClosed connection_closed = 6; */
    if (message.connection_closed)
      CMsgSteamNetworkingP2PRendezvous_ConnectionClosed.internalBinaryWrite(
        message.connection_closed,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 ack_reliable_msg = 11; */
    if (message.ack_reliable_msg !== undefined) writer.tag(11, WireType.Varint).uint32(message.ack_reliable_msg);
    /* optional uint32 first_reliable_msg = 12; */
    if (message.first_reliable_msg !== undefined) writer.tag(12, WireType.Varint).uint32(message.first_reliable_msg);
    /* repeated CMsgSteamNetworkingP2PRendezvous.ReliableMessage reliable_messages = 13; */
    for (let i = 0; i < message.reliable_messages.length; i++)
      CMsgSteamNetworkingP2PRendezvous_ReliableMessage.internalBinaryWrite(
        message.reliable_messages[i],
        writer.tag(13, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated CMsgSteamNetworkingP2PRendezvous.ApplicationMessage application_messages = 15; */
    for (let i = 0; i < message.application_messages.length; i++)
      CMsgSteamNetworkingP2PRendezvous_ApplicationMessage.internalBinaryWrite(
        message.application_messages[i],
        writer.tag(15, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingP2PRendezvous
 */
export const CMsgSteamNetworkingP2PRendezvous = new CMsgSteamNetworkingP2PRendezvous$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingP2PRendezvous_ConnectRequest$Type extends MessageType<CMsgSteamNetworkingP2PRendezvous_ConnectRequest> {
  constructor() {
    super("CMsgSteamNetworkingP2PRendezvous.ConnectRequest", [
      {
        no: 6,
        name: "crypt",
        kind: "message",
        T: () => CMsgSteamDatagramSessionCryptInfoSigned,
      },
      {
        no: 7,
        name: "cert",
        kind: "message",
        T: () => CMsgSteamDatagramCertificateSigned,
      },
      {
        no: 9,
        name: "to_virtual_port",
        kind: "scalar",
        localName: "to_virtual_port",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 10,
        name: "from_virtual_port",
        kind: "scalar",
        localName: "from_virtual_port",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 11,
        name: "from_fakeip",
        kind: "scalar",
        localName: "from_fakeip",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgSteamNetworkingP2PRendezvous_ConnectRequest>,
  ): CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgSteamNetworkingP2PRendezvous_ConnectRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSteamNetworkingP2PRendezvous_ConnectRequest,
  ): CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgSteamDatagramSessionCryptInfoSigned crypt */ 6:
          message.crypt = CMsgSteamDatagramSessionCryptInfoSigned.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.crypt,
          );
          break;
        case /* optional CMsgSteamDatagramCertificateSigned cert */ 7:
          message.cert = CMsgSteamDatagramCertificateSigned.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.cert,
          );
          break;
        case /* optional uint32 to_virtual_port */ 9:
          message.to_virtual_port = reader.uint32();
          break;
        case /* optional uint32 from_virtual_port */ 10:
          message.from_virtual_port = reader.uint32();
          break;
        case /* optional string from_fakeip */ 11:
          message.from_fakeip = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSteamNetworkingP2PRendezvous_ConnectRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgSteamDatagramSessionCryptInfoSigned crypt = 6; */
    if (message.crypt)
      CMsgSteamDatagramSessionCryptInfoSigned.internalBinaryWrite(
        message.crypt,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgSteamDatagramCertificateSigned cert = 7; */
    if (message.cert)
      CMsgSteamDatagramCertificateSigned.internalBinaryWrite(
        message.cert,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 to_virtual_port = 9; */
    if (message.to_virtual_port !== undefined) writer.tag(9, WireType.Varint).uint32(message.to_virtual_port);
    /* optional uint32 from_virtual_port = 10; */
    if (message.from_virtual_port !== undefined) writer.tag(10, WireType.Varint).uint32(message.from_virtual_port);
    /* optional string from_fakeip = 11; */
    if (message.from_fakeip !== undefined) writer.tag(11, WireType.LengthDelimited).string(message.from_fakeip);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingP2PRendezvous.ConnectRequest
 */
export const CMsgSteamNetworkingP2PRendezvous_ConnectRequest =
  new CMsgSteamNetworkingP2PRendezvous_ConnectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingP2PRendezvous_ConnectOK$Type extends MessageType<CMsgSteamNetworkingP2PRendezvous_ConnectOK> {
  constructor() {
    super("CMsgSteamNetworkingP2PRendezvous.ConnectOK", [
      {
        no: 5,
        name: "crypt",
        kind: "message",
        T: () => CMsgSteamDatagramSessionCryptInfoSigned,
      },
      {
        no: 6,
        name: "cert",
        kind: "message",
        T: () => CMsgSteamDatagramCertificateSigned,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgSteamNetworkingP2PRendezvous_ConnectOK>,
  ): CMsgSteamNetworkingP2PRendezvous_ConnectOK {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSteamNetworkingP2PRendezvous_ConnectOK>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSteamNetworkingP2PRendezvous_ConnectOK,
  ): CMsgSteamNetworkingP2PRendezvous_ConnectOK {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgSteamDatagramSessionCryptInfoSigned crypt */ 5:
          message.crypt = CMsgSteamDatagramSessionCryptInfoSigned.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.crypt,
          );
          break;
        case /* optional CMsgSteamDatagramCertificateSigned cert */ 6:
          message.cert = CMsgSteamDatagramCertificateSigned.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.cert,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSteamNetworkingP2PRendezvous_ConnectOK,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgSteamDatagramSessionCryptInfoSigned crypt = 5; */
    if (message.crypt)
      CMsgSteamDatagramSessionCryptInfoSigned.internalBinaryWrite(
        message.crypt,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgSteamDatagramCertificateSigned cert = 6; */
    if (message.cert)
      CMsgSteamDatagramCertificateSigned.internalBinaryWrite(
        message.cert,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingP2PRendezvous.ConnectOK
 */
export const CMsgSteamNetworkingP2PRendezvous_ConnectOK = new CMsgSteamNetworkingP2PRendezvous_ConnectOK$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingP2PRendezvous_ConnectionClosed$Type extends MessageType<CMsgSteamNetworkingP2PRendezvous_ConnectionClosed> {
  constructor() {
    super("CMsgSteamNetworkingP2PRendezvous.ConnectionClosed", [
      {
        no: 5,
        name: "debug",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 6,
        name: "reason_code",
        kind: "scalar",
        localName: "reason_code",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgSteamNetworkingP2PRendezvous_ConnectionClosed>,
  ): CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgSteamNetworkingP2PRendezvous_ConnectionClosed>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSteamNetworkingP2PRendezvous_ConnectionClosed,
  ): CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string debug */ 5:
          message.debug = reader.string();
          break;
        case /* optional uint32 reason_code */ 6:
          message.reason_code = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSteamNetworkingP2PRendezvous_ConnectionClosed,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string debug = 5; */
    if (message.debug !== undefined) writer.tag(5, WireType.LengthDelimited).string(message.debug);
    /* optional uint32 reason_code = 6; */
    if (message.reason_code !== undefined) writer.tag(6, WireType.Varint).uint32(message.reason_code);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingP2PRendezvous.ConnectionClosed
 */
export const CMsgSteamNetworkingP2PRendezvous_ConnectionClosed =
  new CMsgSteamNetworkingP2PRendezvous_ConnectionClosed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingP2PRendezvous_ReliableMessage$Type extends MessageType<CMsgSteamNetworkingP2PRendezvous_ReliableMessage> {
  constructor() {
    super("CMsgSteamNetworkingP2PRendezvous.ReliableMessage", [
      { no: 1, name: "ice", kind: "message", T: () => CMsgICERendezvous },
    ]);
  }
  create(
    value?: PartialMessage<CMsgSteamNetworkingP2PRendezvous_ReliableMessage>,
  ): CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgSteamNetworkingP2PRendezvous_ReliableMessage>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSteamNetworkingP2PRendezvous_ReliableMessage,
  ): CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgICERendezvous ice */ 1:
          message.ice = CMsgICERendezvous.internalBinaryRead(reader, reader.uint32(), options, message.ice);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSteamNetworkingP2PRendezvous_ReliableMessage,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgICERendezvous ice = 1; */
    if (message.ice)
      CMsgICERendezvous.internalBinaryWrite(
        message.ice,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingP2PRendezvous.ReliableMessage
 */
export const CMsgSteamNetworkingP2PRendezvous_ReliableMessage =
  new CMsgSteamNetworkingP2PRendezvous_ReliableMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingP2PRendezvous_ApplicationMessage$Type extends MessageType<CMsgSteamNetworkingP2PRendezvous_ApplicationMessage> {
  constructor() {
    super("CMsgSteamNetworkingP2PRendezvous.ApplicationMessage", [
      {
        no: 1,
        name: "data",
        kind: "scalar",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 2,
        name: "msg_num",
        kind: "scalar",
        localName: "msg_num",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "flags",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "lane_idx",
        kind: "scalar",
        localName: "lane_idx",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgSteamNetworkingP2PRendezvous_ApplicationMessage>,
  ): CMsgSteamNetworkingP2PRendezvous_ApplicationMessage {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgSteamNetworkingP2PRendezvous_ApplicationMessage>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSteamNetworkingP2PRendezvous_ApplicationMessage,
  ): CMsgSteamNetworkingP2PRendezvous_ApplicationMessage {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bytes data */ 1:
          message.data = reader.bytes();
          break;
        case /* optional uint64 msg_num */ 2:
          message.msg_num = reader.uint64().toBigInt();
          break;
        case /* optional uint32 flags */ 3:
          message.flags = reader.uint32();
          break;
        case /* optional uint32 lane_idx */ 4:
          message.lane_idx = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSteamNetworkingP2PRendezvous_ApplicationMessage,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional bytes data = 1; */
    if (message.data !== undefined) writer.tag(1, WireType.LengthDelimited).bytes(message.data);
    /* optional uint64 msg_num = 2; */
    if (message.msg_num !== undefined) writer.tag(2, WireType.Varint).uint64(message.msg_num);
    /* optional uint32 flags = 3; */
    if (message.flags !== undefined) writer.tag(3, WireType.Varint).uint32(message.flags);
    /* optional uint32 lane_idx = 4; */
    if (message.lane_idx !== undefined) writer.tag(4, WireType.Varint).uint32(message.lane_idx);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingP2PRendezvous.ApplicationMessage
 */
export const CMsgSteamNetworkingP2PRendezvous_ApplicationMessage =
  new CMsgSteamNetworkingP2PRendezvous_ApplicationMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingICESessionSummary$Type extends MessageType<CMsgSteamNetworkingICESessionSummary> {
  constructor() {
    super("CMsgSteamNetworkingICESessionSummary", [
      {
        no: 7,
        name: "failure_reason_code",
        kind: "scalar",
        localName: "failure_reason_code",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 1,
        name: "local_candidate_types",
        kind: "scalar",
        localName: "local_candidate_types",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "remote_candidate_types",
        kind: "scalar",
        localName: "remote_candidate_types",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "initial_route_kind",
        kind: "scalar",
        localName: "initial_route_kind",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "initial_ping",
        kind: "scalar",
        localName: "initial_ping",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "initial_score",
        kind: "scalar",
        localName: "initial_score",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "negotiation_ms",
        kind: "scalar",
        localName: "negotiation_ms",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 16,
        name: "best_route_kind",
        kind: "scalar",
        localName: "best_route_kind",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 17,
        name: "best_ping",
        kind: "scalar",
        localName: "best_ping",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 18,
        name: "best_score",
        kind: "scalar",
        localName: "best_score",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 19,
        name: "best_time",
        kind: "scalar",
        localName: "best_time",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 12,
        name: "selected_seconds",
        kind: "scalar",
        localName: "selected_seconds",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 13,
        name: "user_settings",
        kind: "scalar",
        localName: "user_settings",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 14,
        name: "ice_enable_var",
        kind: "scalar",
        localName: "ice_enable_var",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 15,
        name: "local_candidate_types_allowed",
        kind: "scalar",
        localName: "local_candidate_types_allowed",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSteamNetworkingICESessionSummary>): CMsgSteamNetworkingICESessionSummary {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSteamNetworkingICESessionSummary>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSteamNetworkingICESessionSummary,
  ): CMsgSteamNetworkingICESessionSummary {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 failure_reason_code */ 7:
          message.failure_reason_code = reader.uint32();
          break;
        case /* optional uint32 local_candidate_types */ 1:
          message.local_candidate_types = reader.uint32();
          break;
        case /* optional uint32 remote_candidate_types */ 2:
          message.remote_candidate_types = reader.uint32();
          break;
        case /* optional uint32 initial_route_kind */ 3:
          message.initial_route_kind = reader.uint32();
          break;
        case /* optional uint32 initial_ping */ 4:
          message.initial_ping = reader.uint32();
          break;
        case /* optional uint32 initial_score */ 6:
          message.initial_score = reader.uint32();
          break;
        case /* optional uint32 negotiation_ms */ 5:
          message.negotiation_ms = reader.uint32();
          break;
        case /* optional uint32 best_route_kind */ 16:
          message.best_route_kind = reader.uint32();
          break;
        case /* optional uint32 best_ping */ 17:
          message.best_ping = reader.uint32();
          break;
        case /* optional uint32 best_score */ 18:
          message.best_score = reader.uint32();
          break;
        case /* optional uint32 best_time */ 19:
          message.best_time = reader.uint32();
          break;
        case /* optional uint32 selected_seconds */ 12:
          message.selected_seconds = reader.uint32();
          break;
        case /* optional uint32 user_settings */ 13:
          message.user_settings = reader.uint32();
          break;
        case /* optional uint32 ice_enable_var */ 14:
          message.ice_enable_var = reader.uint32();
          break;
        case /* optional uint32 local_candidate_types_allowed */ 15:
          message.local_candidate_types_allowed = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSteamNetworkingICESessionSummary,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 failure_reason_code = 7; */
    if (message.failure_reason_code !== undefined) writer.tag(7, WireType.Varint).uint32(message.failure_reason_code);
    /* optional uint32 local_candidate_types = 1; */
    if (message.local_candidate_types !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.local_candidate_types);
    /* optional uint32 remote_candidate_types = 2; */
    if (message.remote_candidate_types !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.remote_candidate_types);
    /* optional uint32 initial_route_kind = 3; */
    if (message.initial_route_kind !== undefined) writer.tag(3, WireType.Varint).uint32(message.initial_route_kind);
    /* optional uint32 initial_ping = 4; */
    if (message.initial_ping !== undefined) writer.tag(4, WireType.Varint).uint32(message.initial_ping);
    /* optional uint32 initial_score = 6; */
    if (message.initial_score !== undefined) writer.tag(6, WireType.Varint).uint32(message.initial_score);
    /* optional uint32 negotiation_ms = 5; */
    if (message.negotiation_ms !== undefined) writer.tag(5, WireType.Varint).uint32(message.negotiation_ms);
    /* optional uint32 best_route_kind = 16; */
    if (message.best_route_kind !== undefined) writer.tag(16, WireType.Varint).uint32(message.best_route_kind);
    /* optional uint32 best_ping = 17; */
    if (message.best_ping !== undefined) writer.tag(17, WireType.Varint).uint32(message.best_ping);
    /* optional uint32 best_score = 18; */
    if (message.best_score !== undefined) writer.tag(18, WireType.Varint).uint32(message.best_score);
    /* optional uint32 best_time = 19; */
    if (message.best_time !== undefined) writer.tag(19, WireType.Varint).uint32(message.best_time);
    /* optional uint32 selected_seconds = 12; */
    if (message.selected_seconds !== undefined) writer.tag(12, WireType.Varint).uint32(message.selected_seconds);
    /* optional uint32 user_settings = 13; */
    if (message.user_settings !== undefined) writer.tag(13, WireType.Varint).uint32(message.user_settings);
    /* optional uint32 ice_enable_var = 14; */
    if (message.ice_enable_var !== undefined) writer.tag(14, WireType.Varint).uint32(message.ice_enable_var);
    /* optional uint32 local_candidate_types_allowed = 15; */
    if (message.local_candidate_types_allowed !== undefined)
      writer.tag(15, WireType.Varint).uint32(message.local_candidate_types_allowed);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingICESessionSummary
 */
export const CMsgSteamNetworkingICESessionSummary = new CMsgSteamNetworkingICESessionSummary$Type();

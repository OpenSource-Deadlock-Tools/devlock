// @generated by protobuf-ts 2.9.4 with parameter use_proto_field_name
// @generated from protobuf file "base_gcmessages.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { EGCPlatform } from "./steammessages.js";
import { CExtraMsgBlock } from "./gcsdk_gcmessages.js";
/**
 * @generated from protobuf message CGCStorePurchaseInit_LineItem
 */
export interface CGCStorePurchaseInit_LineItem {
  /**
   * @generated from protobuf field: optional uint32 item_def_id = 1;
   */
  item_def_id?: number;
  /**
   * @generated from protobuf field: optional uint32 quantity = 2;
   */
  quantity?: number;
  /**
   * @generated from protobuf field: optional uint32 cost_in_local_currency = 3;
   */
  cost_in_local_currency?: number;
  /**
   * @generated from protobuf field: optional uint32 purchase_type = 4;
   */
  purchase_type?: number;
  /**
   * @generated from protobuf field: optional uint64 source_reference_id = 5;
   */
  source_reference_id?: bigint;
  /**
   * @generated from protobuf field: optional int32 price_index = 6;
   */
  price_index?: number;
}
/**
 * @generated from protobuf message CMsgGCStorePurchaseInit
 */
export interface CMsgGCStorePurchaseInit {
  /**
   * @generated from protobuf field: optional string country = 1;
   */
  country?: string;
  /**
   * @generated from protobuf field: optional int32 language = 2;
   */
  language?: number;
  /**
   * @generated from protobuf field: optional int32 currency = 3;
   */
  currency?: number;
  /**
   * @generated from protobuf field: repeated CGCStorePurchaseInit_LineItem line_items = 4;
   */
  line_items: CGCStorePurchaseInit_LineItem[];
}
/**
 * @generated from protobuf message CMsgGCStorePurchaseInitResponse
 */
export interface CMsgGCStorePurchaseInitResponse {
  /**
   * @generated from protobuf field: optional int32 result = 1;
   */
  result?: number;
  /**
   * @generated from protobuf field: optional uint64 txn_id = 2;
   */
  txn_id?: bigint;
}
/**
 * @generated from protobuf message CMsgClientPingData
 */
export interface CMsgClientPingData {
  /**
   * @generated from protobuf field: repeated fixed32 relay_codes = 4 [packed = true];
   */
  relay_codes: number[];
  /**
   * @generated from protobuf field: repeated uint32 relay_pings = 5 [packed = true];
   */
  relay_pings: number[];
  /**
   * @generated from protobuf field: repeated uint32 region_codes = 8 [packed = true];
   */
  region_codes: number[];
  /**
   * @generated from protobuf field: repeated uint32 region_pings = 9 [packed = true];
   */
  region_pings: number[];
  /**
   * @generated from protobuf field: optional uint32 region_ping_failed_bitmask = 10;
   */
  region_ping_failed_bitmask?: number;
}
/**
 * @generated from protobuf message CMsgInviteToParty
 */
export interface CMsgInviteToParty {
  /**
   * @generated from protobuf field: optional fixed64 steam_id = 1;
   */
  steam_id?: bigint;
  /**
   * @generated from protobuf field: optional uint32 client_version = 2;
   */
  client_version?: number;
  /**
   * @generated from protobuf field: optional uint32 team_id = 3;
   */
  team_id?: number;
  /**
   * @generated from protobuf field: optional bool as_coach = 4;
   */
  as_coach?: boolean;
  /**
   * @generated from protobuf field: optional CMsgClientPingData ping_data = 5;
   */
  ping_data?: CMsgClientPingData;
}
/**
 * @generated from protobuf message CMsgInviteToLobby
 */
export interface CMsgInviteToLobby {
  /**
   * @generated from protobuf field: optional fixed64 steam_id = 1;
   */
  steam_id?: bigint;
  /**
   * @generated from protobuf field: optional uint32 client_version = 2;
   */
  client_version?: number;
}
/**
 * @generated from protobuf message CMsgInvitationCreated
 */
export interface CMsgInvitationCreated {
  /**
   * @generated from protobuf field: optional uint64 group_id = 1;
   */
  group_id?: bigint;
  /**
   * @generated from protobuf field: optional fixed64 steam_id = 2;
   */
  steam_id?: bigint;
  /**
   * @generated from protobuf field: optional bool user_offline = 3;
   */
  user_offline?: boolean;
}
/**
 * @generated from protobuf message CMsgPartyInviteResponse
 */
export interface CMsgPartyInviteResponse {
  /**
   * @generated from protobuf field: optional uint64 party_id = 1;
   */
  party_id?: bigint;
  /**
   * @generated from protobuf field: optional bool accept = 2;
   */
  accept?: boolean;
  /**
   * @generated from protobuf field: optional uint32 client_version = 3;
   */
  client_version?: number;
  /**
   * @generated from protobuf field: optional CMsgClientPingData ping_data = 8;
   */
  ping_data?: CMsgClientPingData;
}
/**
 * @generated from protobuf message CMsgLobbyInviteResponse
 */
export interface CMsgLobbyInviteResponse {
  /**
   * @generated from protobuf field: optional fixed64 lobby_id = 1;
   */
  lobby_id?: bigint;
  /**
   * @generated from protobuf field: optional bool accept = 2;
   */
  accept?: boolean;
  /**
   * @generated from protobuf field: optional uint32 client_version = 3;
   */
  client_version?: number;
  /**
   * @generated from protobuf field: optional fixed64 custom_game_crc = 6;
   */
  custom_game_crc?: bigint;
  /**
   * @generated from protobuf field: optional fixed32 custom_game_timestamp = 7;
   */
  custom_game_timestamp?: number;
}
/**
 * @generated from protobuf message CMsgKickFromParty
 */
export interface CMsgKickFromParty {
  /**
   * @generated from protobuf field: optional fixed64 steam_id = 1;
   */
  steam_id?: bigint;
}
/**
 * @generated from protobuf message CMsgLeaveParty
 */
export interface CMsgLeaveParty {}
/**
 * @generated from protobuf message CMsgCustomGameInstallStatus
 */
export interface CMsgCustomGameInstallStatus {
  /**
   * @generated from protobuf field: optional ECustomGameInstallStatus status = 1;
   */
  status?: ECustomGameInstallStatus;
  /**
   * @generated from protobuf field: optional string message = 2;
   */
  message?: string;
  /**
   * @generated from protobuf field: optional fixed32 latest_timestamp_from_steam = 3;
   */
  latest_timestamp_from_steam?: number;
}
/**
 * @generated from protobuf message CMsgServerAvailable
 */
export interface CMsgServerAvailable {
  /**
   * @generated from protobuf field: optional CMsgCustomGameInstallStatus custom_game_install_status = 1;
   */
  custom_game_install_status?: CMsgCustomGameInstallStatus;
}
/**
 * @generated from protobuf message CMsgLANServerAvailable
 */
export interface CMsgLANServerAvailable {
  /**
   * @generated from protobuf field: optional fixed64 lobby_id = 1;
   */
  lobby_id?: bigint;
}
/**
 * @generated from protobuf message CSOEconGameAccountClient
 */
export interface CSOEconGameAccountClient {
  /**
   * @generated from protobuf field: optional uint32 additional_backpack_slots = 1;
   */
  additional_backpack_slots?: number;
  /**
   * @generated from protobuf field: optional bool trial_account = 2;
   */
  trial_account?: boolean;
  /**
   * @generated from protobuf field: optional bool eligible_for_online_play = 3;
   */
  eligible_for_online_play?: boolean;
  /**
   * @generated from protobuf field: optional bool need_to_choose_most_helpful_friend = 4;
   */
  need_to_choose_most_helpful_friend?: boolean;
  /**
   * @generated from protobuf field: optional bool in_coaches_list = 5;
   */
  in_coaches_list?: boolean;
  /**
   * @generated from protobuf field: optional fixed32 trade_ban_expiration = 6;
   */
  trade_ban_expiration?: number;
  /**
   * @generated from protobuf field: optional fixed32 duel_ban_expiration = 7;
   */
  duel_ban_expiration?: number;
  /**
   * @generated from protobuf field: optional bool made_first_purchase = 9;
   */
  made_first_purchase?: boolean;
}
/**
 * @generated from protobuf message CMsgApplyStrangePart
 */
export interface CMsgApplyStrangePart {
  /**
   * @generated from protobuf field: optional uint64 strange_part_item_id = 1;
   */
  strange_part_item_id?: bigint;
  /**
   * @generated from protobuf field: optional uint64 item_item_id = 2;
   */
  item_item_id?: bigint;
}
/**
 * @generated from protobuf message CMsgApplyPennantUpgrade
 */
export interface CMsgApplyPennantUpgrade {
  /**
   * @generated from protobuf field: optional uint64 upgrade_item_id = 1;
   */
  upgrade_item_id?: bigint;
  /**
   * @generated from protobuf field: optional uint64 pennant_item_id = 2;
   */
  pennant_item_id?: bigint;
}
/**
 * @generated from protobuf message CMsgApplyEggEssence
 */
export interface CMsgApplyEggEssence {
  /**
   * @generated from protobuf field: optional uint64 essence_item_id = 1;
   */
  essence_item_id?: bigint;
  /**
   * @generated from protobuf field: optional uint64 egg_item_id = 2;
   */
  egg_item_id?: bigint;
}
/**
 * @generated from protobuf message CSOEconItemAttribute
 */
export interface CSOEconItemAttribute {
  /**
   * @generated from protobuf field: optional uint32 def_index = 1;
   */
  def_index?: number;
  /**
   * @generated from protobuf field: optional uint32 value = 2;
   */
  value?: number;
  /**
   * @generated from protobuf field: optional bytes value_bytes = 3;
   */
  value_bytes?: Uint8Array;
}
/**
 * @generated from protobuf message CSOEconItemEquipped
 */
export interface CSOEconItemEquipped {
  /**
   * @generated from protobuf field: optional uint32 new_class = 1;
   */
  new_class?: number;
  /**
   * @generated from protobuf field: optional uint32 new_slot = 2;
   */
  new_slot?: number;
}
/**
 * @generated from protobuf message CSOEconItem
 */
export interface CSOEconItem {
  /**
   * @generated from protobuf field: optional uint64 id = 1;
   */
  id?: bigint;
  /**
   * @generated from protobuf field: optional uint32 account_id = 2;
   */
  account_id?: number;
  /**
   * @generated from protobuf field: optional uint32 inventory = 3;
   */
  inventory?: number;
  /**
   * @generated from protobuf field: optional uint32 def_index = 4;
   */
  def_index?: number;
  /**
   * @generated from protobuf field: optional uint32 quantity = 5;
   */
  quantity?: number;
  /**
   * @generated from protobuf field: optional uint32 level = 6;
   */
  level?: number;
  /**
   * @generated from protobuf field: optional uint32 quality = 7;
   */
  quality?: number;
  /**
   * @generated from protobuf field: optional uint32 flags = 8;
   */
  flags?: number;
  /**
   * @generated from protobuf field: optional uint32 origin = 9;
   */
  origin?: number;
  /**
   * @generated from protobuf field: repeated CSOEconItemAttribute attribute = 12;
   */
  attribute: CSOEconItemAttribute[];
  /**
   * @generated from protobuf field: optional CSOEconItem interior_item = 13;
   */
  interior_item?: CSOEconItem;
  /**
   * @generated from protobuf field: optional uint32 style = 15;
   */
  style?: number;
  /**
   * @generated from protobuf field: optional uint64 original_id = 16;
   */
  original_id?: bigint;
  /**
   * @generated from protobuf field: repeated CSOEconItemEquipped equipped_state = 18;
   */
  equipped_state: CSOEconItemEquipped[];
}
/**
 * @generated from protobuf message CMsgSortItems
 */
export interface CMsgSortItems {
  /**
   * @generated from protobuf field: optional uint32 sort_type = 1;
   */
  sort_type?: number;
}
/**
 * @generated from protobuf message CMsgItemAcknowledged
 */
export interface CMsgItemAcknowledged {
  /**
   * @generated from protobuf field: optional uint32 account_id = 1;
   */
  account_id?: number;
  /**
   * @generated from protobuf field: optional uint32 inventory = 2;
   */
  inventory?: number;
  /**
   * @generated from protobuf field: optional uint32 def_index = 3;
   */
  def_index?: number;
  /**
   * @generated from protobuf field: optional uint32 quality = 4;
   */
  quality?: number;
  /**
   * @generated from protobuf field: optional uint32 rarity = 5;
   */
  rarity?: number;
  /**
   * @generated from protobuf field: optional uint32 origin = 6;
   */
  origin?: number;
}
/**
 * @generated from protobuf message CMsgSetItemPositions
 */
export interface CMsgSetItemPositions {
  /**
   * @generated from protobuf field: repeated CMsgSetItemPositions.ItemPosition item_positions = 1;
   */
  item_positions: CMsgSetItemPositions_ItemPosition[];
}
/**
 * @generated from protobuf message CMsgSetItemPositions.ItemPosition
 */
export interface CMsgSetItemPositions_ItemPosition {
  /**
   * @generated from protobuf field: optional uint64 item_id = 1;
   */
  item_id?: bigint;
  /**
   * @generated from protobuf field: optional uint32 position = 2;
   */
  position?: number;
}
/**
 * @generated from protobuf message CMsgGCStorePurchaseCancel
 */
export interface CMsgGCStorePurchaseCancel {
  /**
   * @generated from protobuf field: optional uint64 txn_id = 1;
   */
  txn_id?: bigint;
}
/**
 * @generated from protobuf message CMsgGCStorePurchaseCancelResponse
 */
export interface CMsgGCStorePurchaseCancelResponse {
  /**
   * @generated from protobuf field: optional uint32 result = 1;
   */
  result?: number;
}
/**
 * @generated from protobuf message CMsgGCStorePurchaseFinalize
 */
export interface CMsgGCStorePurchaseFinalize {
  /**
   * @generated from protobuf field: optional uint64 txn_id = 1;
   */
  txn_id?: bigint;
}
/**
 * @generated from protobuf message CMsgGCStorePurchaseFinalizeResponse
 */
export interface CMsgGCStorePurchaseFinalizeResponse {
  /**
   * @generated from protobuf field: optional uint32 result = 1;
   */
  result?: number;
  /**
   * @generated from protobuf field: repeated uint64 item_ids = 2;
   */
  item_ids: bigint[];
}
/**
 * @generated from protobuf message CMsgGCToGCBannedWordListUpdated
 */
export interface CMsgGCToGCBannedWordListUpdated {
  /**
   * @generated from protobuf field: optional uint32 group_id = 1;
   */
  group_id?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCDirtySDOCache
 */
export interface CMsgGCToGCDirtySDOCache {
  /**
   * @generated from protobuf field: optional uint32 sdo_type = 1;
   */
  sdo_type?: number;
  /**
   * @generated from protobuf field: optional uint64 key_uint64 = 2;
   */
  key_uint64?: bigint;
}
/**
 * @generated from protobuf message CMsgSDONoMemcached
 */
export interface CMsgSDONoMemcached {}
/**
 * @generated from protobuf message CMsgGCToGCUpdateSQLKeyValue
 */
export interface CMsgGCToGCUpdateSQLKeyValue {
  /**
   * @generated from protobuf field: optional string key_name = 1;
   */
  key_name?: string;
}
/**
 * @generated from protobuf message CMsgGCServerVersionUpdated
 */
export interface CMsgGCServerVersionUpdated {
  /**
   * @generated from protobuf field: optional uint32 server_version = 1;
   */
  server_version?: number;
}
/**
 * @generated from protobuf message CMsgGCClientVersionUpdated
 */
export interface CMsgGCClientVersionUpdated {
  /**
   * @generated from protobuf field: optional uint32 client_version = 1;
   */
  client_version?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCWebAPIAccountChanged
 */
export interface CMsgGCToGCWebAPIAccountChanged {}
/**
 * @generated from protobuf message CMsgExtractGems
 */
export interface CMsgExtractGems {
  /**
   * @generated from protobuf field: optional uint64 tool_item_id = 1;
   */
  tool_item_id?: bigint;
  /**
   * @generated from protobuf field: optional uint64 item_item_id = 2;
   */
  item_item_id?: bigint;
  /**
   * @generated from protobuf field: optional uint32 item_socket_id = 3;
   */
  item_socket_id?: number;
}
/**
 * @generated from protobuf message CMsgExtractGemsResponse
 */
export interface CMsgExtractGemsResponse {
  /**
   * @generated from protobuf field: optional uint64 item_id = 1;
   */
  item_id?: bigint;
  /**
   * @generated from protobuf field: optional CMsgExtractGemsResponse.EExtractGems response = 2;
   */
  response?: CMsgExtractGemsResponse_EExtractGems;
}
/**
 * @generated from protobuf enum CMsgExtractGemsResponse.EExtractGems
 */
export enum CMsgExtractGemsResponse_EExtractGems {
  /**
   * @generated from protobuf enum value: k_ExtractGems_Succeeded = 0;
   */
  k_ExtractGems_Succeeded = 0,
  /**
   * @generated from protobuf enum value: k_ExtractGems_Failed_ToolIsInvalid = 1;
   */
  k_ExtractGems_Failed_ToolIsInvalid = 1,
  /**
   * @generated from protobuf enum value: k_ExtractGems_Failed_ItemIsInvalid = 2;
   */
  k_ExtractGems_Failed_ItemIsInvalid = 2,
  /**
   * @generated from protobuf enum value: k_ExtractGems_Failed_ToolCannotRemoveGem = 3;
   */
  k_ExtractGems_Failed_ToolCannotRemoveGem = 3,
  /**
   * @generated from protobuf enum value: k_ExtractGems_Failed_FailedToRemoveGem = 4;
   */
  k_ExtractGems_Failed_FailedToRemoveGem = 4,
}
/**
 * @generated from protobuf message CMsgAddSocket
 */
export interface CMsgAddSocket {
  /**
   * @generated from protobuf field: optional uint64 tool_item_id = 1;
   */
  tool_item_id?: bigint;
  /**
   * @generated from protobuf field: optional uint64 item_item_id = 2;
   */
  item_item_id?: bigint;
  /**
   * @generated from protobuf field: optional bool unusual = 3;
   */
  unusual?: boolean;
}
/**
 * @generated from protobuf message CMsgAddSocketResponse
 */
export interface CMsgAddSocketResponse {
  /**
   * @generated from protobuf field: optional uint64 item_id = 1;
   */
  item_id?: bigint;
  /**
   * @generated from protobuf field: repeated uint32 updated_socket_index = 2;
   */
  updated_socket_index: number[];
  /**
   * @generated from protobuf field: optional CMsgAddSocketResponse.EAddSocket response = 3;
   */
  response?: CMsgAddSocketResponse_EAddSocket;
}
/**
 * @generated from protobuf enum CMsgAddSocketResponse.EAddSocket
 */
export enum CMsgAddSocketResponse_EAddSocket {
  /**
   * @generated from protobuf enum value: k_AddSocket_Succeeded = 0;
   */
  k_AddSocket_Succeeded = 0,
  /**
   * @generated from protobuf enum value: k_AddSocket_Failed_ToolIsInvalid = 1;
   */
  k_AddSocket_Failed_ToolIsInvalid = 1,
  /**
   * @generated from protobuf enum value: k_AddSocket_Failed_ItemCannotBeSocketed = 2;
   */
  k_AddSocket_Failed_ItemCannotBeSocketed = 2,
  /**
   * @generated from protobuf enum value: k_AddSocket_Failed_FailedToAddSocket = 3;
   */
  k_AddSocket_Failed_FailedToAddSocket = 3,
}
/**
 * @generated from protobuf message CMsgAddItemToSocketData
 */
export interface CMsgAddItemToSocketData {
  /**
   * @generated from protobuf field: optional uint64 gem_item_id = 1;
   */
  gem_item_id?: bigint;
  /**
   * @generated from protobuf field: optional uint32 socket_index = 2;
   */
  socket_index?: number;
}
/**
 * @generated from protobuf message CMsgAddItemToSocket
 */
export interface CMsgAddItemToSocket {
  /**
   * @generated from protobuf field: optional uint64 item_item_id = 1;
   */
  item_item_id?: bigint;
  /**
   * @generated from protobuf field: repeated CMsgAddItemToSocketData gems_to_socket = 2;
   */
  gems_to_socket: CMsgAddItemToSocketData[];
}
/**
 * @generated from protobuf message CMsgAddItemToSocketResponse
 */
export interface CMsgAddItemToSocketResponse {
  /**
   * @generated from protobuf field: optional uint64 item_item_id = 1;
   */
  item_item_id?: bigint;
  /**
   * @generated from protobuf field: repeated uint32 updated_socket_index = 2;
   */
  updated_socket_index: number[];
  /**
   * @generated from protobuf field: optional CMsgAddItemToSocketResponse.EAddGem response = 3;
   */
  response?: CMsgAddItemToSocketResponse_EAddGem;
}
/**
 * @generated from protobuf enum CMsgAddItemToSocketResponse.EAddGem
 */
export enum CMsgAddItemToSocketResponse_EAddGem {
  /**
   * @generated from protobuf enum value: k_AddGem_Succeeded = 0;
   */
  k_AddGem_Succeeded = 0,
  /**
   * @generated from protobuf enum value: k_AddGem_Failed_GemIsInvalid = 1;
   */
  k_AddGem_Failed_GemIsInvalid = 1,
  /**
   * @generated from protobuf enum value: k_AddGem_Failed_ItemIsInvalid = 2;
   */
  k_AddGem_Failed_ItemIsInvalid = 2,
  /**
   * @generated from protobuf enum value: k_AddGem_Failed_FailedToAddGem = 3;
   */
  k_AddGem_Failed_FailedToAddGem = 3,
  /**
   * @generated from protobuf enum value: k_AddGem_Failed_InvalidGemTypeForSocket = 4;
   */
  k_AddGem_Failed_InvalidGemTypeForSocket = 4,
  /**
   * @generated from protobuf enum value: k_AddGem_Failed_InvalidGemTypeForHero = 5;
   */
  k_AddGem_Failed_InvalidGemTypeForHero = 5,
  /**
   * @generated from protobuf enum value: k_AddGem_Failed_InvalidGemTypeForSlot = 6;
   */
  k_AddGem_Failed_InvalidGemTypeForSlot = 6,
  /**
   * @generated from protobuf enum value: k_AddGem_Failed_SocketContainsUnremovableGem = 7;
   */
  k_AddGem_Failed_SocketContainsUnremovableGem = 7,
}
/**
 * @generated from protobuf message CMsgResetStrangeGemCount
 */
export interface CMsgResetStrangeGemCount {
  /**
   * @generated from protobuf field: optional uint64 item_item_id = 1;
   */
  item_item_id?: bigint;
  /**
   * @generated from protobuf field: optional uint32 socket_index = 2;
   */
  socket_index?: number;
}
/**
 * @generated from protobuf message CMsgResetStrangeGemCountResponse
 */
export interface CMsgResetStrangeGemCountResponse {
  /**
   * @generated from protobuf field: optional CMsgResetStrangeGemCountResponse.EResetGem response = 1;
   */
  response?: CMsgResetStrangeGemCountResponse_EResetGem;
}
/**
 * @generated from protobuf enum CMsgResetStrangeGemCountResponse.EResetGem
 */
export enum CMsgResetStrangeGemCountResponse_EResetGem {
  /**
   * @generated from protobuf enum value: k_ResetGem_Succeeded = 0;
   */
  k_ResetGem_Succeeded = 0,
  /**
   * @generated from protobuf enum value: k_ResetGem_Failed_FailedToResetGem = 1;
   */
  k_ResetGem_Failed_FailedToResetGem = 1,
  /**
   * @generated from protobuf enum value: k_ResetGem_Failed_ItemIsInvalid = 2;
   */
  k_ResetGem_Failed_ItemIsInvalid = 2,
  /**
   * @generated from protobuf enum value: k_ResetGem_Failed_InvalidSocketId = 3;
   */
  k_ResetGem_Failed_InvalidSocketId = 3,
  /**
   * @generated from protobuf enum value: k_ResetGem_Failed_SocketCannotBeReset = 4;
   */
  k_ResetGem_Failed_SocketCannotBeReset = 4,
}
/**
 * @generated from protobuf message CMsgGCToClientPollFileRequest
 */
export interface CMsgGCToClientPollFileRequest {
  /**
   * @generated from protobuf field: optional string file_name = 1;
   */
  file_name?: string;
  /**
   * @generated from protobuf field: optional uint32 client_version = 2;
   */
  client_version?: number;
  /**
   * @generated from protobuf field: optional uint32 poll_id = 3;
   */
  poll_id?: number;
}
/**
 * @generated from protobuf message CMsgGCToClientPollFileResponse
 */
export interface CMsgGCToClientPollFileResponse {
  /**
   * @generated from protobuf field: optional uint32 poll_id = 1;
   */
  poll_id?: number;
  /**
   * @generated from protobuf field: optional uint32 file_size = 2;
   */
  file_size?: number;
  /**
   * @generated from protobuf field: optional uint32 file_crc = 3;
   */
  file_crc?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCPerformManualOp
 */
export interface CMsgGCToGCPerformManualOp {
  /**
   * @generated from protobuf field: optional uint64 op_id = 1;
   */
  op_id?: bigint;
  /**
   * @generated from protobuf field: optional uint32 group_code = 2;
   */
  group_code?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCPerformManualOpCompleted
 */
export interface CMsgGCToGCPerformManualOpCompleted {
  /**
   * @generated from protobuf field: optional bool success = 1;
   */
  success?: boolean;
  /**
   * @generated from protobuf field: optional int32 source_gc = 2;
   */
  source_gc?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCReloadServerRegionSettings
 */
export interface CMsgGCToGCReloadServerRegionSettings {}
/**
 * @generated from protobuf message CMsgGCAdditionalWelcomeMsgList
 */
export interface CMsgGCAdditionalWelcomeMsgList {
  /**
   * @generated from protobuf field: repeated CExtraMsgBlock welcome_messages = 1;
   */
  welcome_messages: CExtraMsgBlock[];
}
/**
 * @generated from protobuf message CMsgApplyRemoteConVars
 */
export interface CMsgApplyRemoteConVars {
  /**
   * @generated from protobuf field: repeated CMsgApplyRemoteConVars.ConVar con_vars = 1;
   */
  con_vars: CMsgApplyRemoteConVars_ConVar[];
}
/**
 * @generated from protobuf message CMsgApplyRemoteConVars.ConVar
 */
export interface CMsgApplyRemoteConVars_ConVar {
  /**
   * @generated from protobuf field: optional string name = 1;
   */
  name?: string;
  /**
   * @generated from protobuf field: optional string value = 2;
   */
  value?: string;
  /**
   * @generated from protobuf field: optional uint32 version_min = 3;
   */
  version_min?: number;
  /**
   * @generated from protobuf field: optional uint32 version_max = 4;
   */
  version_max?: number;
  /**
   * @generated from protobuf field: optional EGCPlatform platform = 5;
   */
  platform?: EGCPlatform;
}
/**
 * @generated from protobuf message CMsgGCToClientApplyRemoteConVars
 */
export interface CMsgGCToClientApplyRemoteConVars {
  /**
   * @generated from protobuf field: optional CMsgApplyRemoteConVars msg = 1;
   */
  msg?: CMsgApplyRemoteConVars;
}
/**
 * @generated from protobuf message CMsgGCToServerApplyRemoteConVars
 */
export interface CMsgGCToServerApplyRemoteConVars {
  /**
   * @generated from protobuf field: optional CMsgApplyRemoteConVars msg = 1;
   */
  msg?: CMsgApplyRemoteConVars;
}
/**
 * @generated from protobuf message CMsgClientToGCIntegrityStatus
 */
export interface CMsgClientToGCIntegrityStatus {
  /**
   * @generated from protobuf field: optional string report = 1;
   */
  report?: string;
  /**
   * @generated from protobuf field: optional bool secure_allowed = 2;
   */
  secure_allowed?: boolean;
  /**
   * @generated from protobuf field: repeated CMsgClientToGCIntegrityStatus.keyvalue diagnostics = 3;
   */
  diagnostics: CMsgClientToGCIntegrityStatus_keyvalue[];
}
/**
 * @generated from protobuf message CMsgClientToGCIntegrityStatus.keyvalue
 */
export interface CMsgClientToGCIntegrityStatus_keyvalue {
  /**
   * @generated from protobuf field: optional uint32 id = 1;
   */
  id?: number;
  /**
   * @generated from protobuf field: optional uint32 extended = 2;
   */
  extended?: number;
  /**
   * @generated from protobuf field: optional uint64 value = 3;
   */
  value?: bigint;
  /**
   * @generated from protobuf field: optional string string_value = 4;
   */
  string_value?: string;
}
/**
 * @generated from protobuf message CMsgClientToGCAggregateMetrics
 */
export interface CMsgClientToGCAggregateMetrics {
  /**
   * @generated from protobuf field: repeated CMsgClientToGCAggregateMetrics.SingleMetric metrics = 1;
   */
  metrics: CMsgClientToGCAggregateMetrics_SingleMetric[];
}
/**
 * @generated from protobuf message CMsgClientToGCAggregateMetrics.SingleMetric
 */
export interface CMsgClientToGCAggregateMetrics_SingleMetric {
  /**
   * @generated from protobuf field: optional string metric_name = 1;
   */
  metric_name?: string;
  /**
   * @generated from protobuf field: optional uint32 metric_count = 2;
   */
  metric_count?: number;
}
/**
 * @generated from protobuf message CMsgGCToClientAggregateMetricsBackoff
 */
export interface CMsgGCToClientAggregateMetricsBackoff {
  /**
   * @generated from protobuf field: optional float upload_rate_modifier = 1;
   */
  upload_rate_modifier?: number;
}
/**
 * @generated from protobuf enum EGCBaseMsg
 */
export enum EGCBaseMsg {
  /**
   * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
   */
  UNSPECIFIED$ = 0,
  /**
   * @generated from protobuf enum value: k_EMsgGCInviteToParty = 4501;
   */
  k_EMsgGCInviteToParty = 4501,
  /**
   * @generated from protobuf enum value: k_EMsgGCInvitationCreated = 4502;
   */
  k_EMsgGCInvitationCreated = 4502,
  /**
   * @generated from protobuf enum value: k_EMsgGCPartyInviteResponse = 4503;
   */
  k_EMsgGCPartyInviteResponse = 4503,
  /**
   * @generated from protobuf enum value: k_EMsgGCKickFromParty = 4504;
   */
  k_EMsgGCKickFromParty = 4504,
  /**
   * @generated from protobuf enum value: k_EMsgGCLeaveParty = 4505;
   */
  k_EMsgGCLeaveParty = 4505,
  /**
   * @generated from protobuf enum value: k_EMsgGCServerAvailable = 4506;
   */
  k_EMsgGCServerAvailable = 4506,
  /**
   * @generated from protobuf enum value: k_EMsgGCClientConnectToServer = 4507;
   */
  k_EMsgGCClientConnectToServer = 4507,
  /**
   * @generated from protobuf enum value: k_EMsgGCGameServerInfo = 4508;
   */
  k_EMsgGCGameServerInfo = 4508,
  /**
   * @generated from protobuf enum value: k_EMsgGCLANServerAvailable = 4511;
   */
  k_EMsgGCLANServerAvailable = 4511,
  /**
   * @generated from protobuf enum value: k_EMsgGCInviteToLobby = 4512;
   */
  k_EMsgGCInviteToLobby = 4512,
  /**
   * @generated from protobuf enum value: k_EMsgGCLobbyInviteResponse = 4513;
   */
  k_EMsgGCLobbyInviteResponse = 4513,
  /**
   * @generated from protobuf enum value: k_EMsgGCToClientPollFileRequest = 4514;
   */
  k_EMsgGCToClientPollFileRequest = 4514,
  /**
   * @generated from protobuf enum value: k_EMsgGCToClientPollFileResponse = 4515;
   */
  k_EMsgGCToClientPollFileResponse = 4515,
  /**
   * @generated from protobuf enum value: k_EMsgGCToGCPerformManualOp = 4516;
   */
  k_EMsgGCToGCPerformManualOp = 4516,
  /**
   * @generated from protobuf enum value: k_EMsgGCToGCPerformManualOpCompleted = 4517;
   */
  k_EMsgGCToGCPerformManualOpCompleted = 4517,
  /**
   * @generated from protobuf enum value: k_EMsgGCToGCReloadServerRegionSettings = 4518;
   */
  k_EMsgGCToGCReloadServerRegionSettings = 4518,
  /**
   * @generated from protobuf enum value: k_EMsgGCAdditionalWelcomeMsgList = 4519;
   */
  k_EMsgGCAdditionalWelcomeMsgList = 4519,
  /**
   * @generated from protobuf enum value: k_EMsgGCToClientApplyRemoteConVars = 4520;
   */
  k_EMsgGCToClientApplyRemoteConVars = 4520,
  /**
   * @generated from protobuf enum value: k_EMsgGCToServerApplyRemoteConVars = 4521;
   */
  k_EMsgGCToServerApplyRemoteConVars = 4521,
  /**
   * @generated from protobuf enum value: k_EMsgClientToGCIntegrityStatus = 4522;
   */
  k_EMsgClientToGCIntegrityStatus = 4522,
  /**
   * @generated from protobuf enum value: k_EMsgClientToGCAggregateMetrics = 4523;
   */
  k_EMsgClientToGCAggregateMetrics = 4523,
  /**
   * @generated from protobuf enum value: k_EMsgGCToClientAggregateMetricsBackoff = 4524;
   */
  k_EMsgGCToClientAggregateMetricsBackoff = 4524,
}
/**
 * @generated from protobuf enum ECustomGameInstallStatus
 */
export enum ECustomGameInstallStatus {
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_Unknown = 0;
   */
  k_ECustomGameInstallStatus_Unknown = 0,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_Ready = 1;
   */
  k_ECustomGameInstallStatus_Ready = 1,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_Busy = 2;
   */
  k_ECustomGameInstallStatus_Busy = 2,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_FailedGeneric = 101;
   */
  k_ECustomGameInstallStatus_FailedGeneric = 101,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_FailedInternalError = 102;
   */
  k_ECustomGameInstallStatus_FailedInternalError = 102,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_RequestedTimestampTooOld = 103;
   */
  k_ECustomGameInstallStatus_RequestedTimestampTooOld = 103,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_RequestedTimestampTooNew = 104;
   */
  k_ECustomGameInstallStatus_RequestedTimestampTooNew = 104,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_CRCMismatch = 105;
   */
  k_ECustomGameInstallStatus_CRCMismatch = 105,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_FailedSteam = 106;
   */
  k_ECustomGameInstallStatus_FailedSteam = 106,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_FailedCanceled = 107;
   */
  k_ECustomGameInstallStatus_FailedCanceled = 107,
}
// @generated message type with reflection information, may provide speed optimized methods
class CGCStorePurchaseInit_LineItem$Type extends MessageType<CGCStorePurchaseInit_LineItem> {
  constructor() {
    super("CGCStorePurchaseInit_LineItem", [
      {
        no: 1,
        name: "item_def_id",
        kind: "scalar",
        localName: "item_def_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "quantity",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "cost_in_local_currency",
        kind: "scalar",
        localName: "cost_in_local_currency",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "purchase_type",
        kind: "scalar",
        localName: "purchase_type",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "source_reference_id",
        kind: "scalar",
        localName: "source_reference_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 6,
        name: "price_index",
        kind: "scalar",
        localName: "price_index",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CGCStorePurchaseInit_LineItem>): CGCStorePurchaseInit_LineItem {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CGCStorePurchaseInit_LineItem>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CGCStorePurchaseInit_LineItem,
  ): CGCStorePurchaseInit_LineItem {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 item_def_id */ 1:
          message.item_def_id = reader.uint32();
          break;
        case /* optional uint32 quantity */ 2:
          message.quantity = reader.uint32();
          break;
        case /* optional uint32 cost_in_local_currency */ 3:
          message.cost_in_local_currency = reader.uint32();
          break;
        case /* optional uint32 purchase_type */ 4:
          message.purchase_type = reader.uint32();
          break;
        case /* optional uint64 source_reference_id */ 5:
          message.source_reference_id = reader.uint64().toBigInt();
          break;
        case /* optional int32 price_index */ 6:
          message.price_index = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CGCStorePurchaseInit_LineItem,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 item_def_id = 1; */
    if (message.item_def_id !== undefined) writer.tag(1, WireType.Varint).uint32(message.item_def_id);
    /* optional uint32 quantity = 2; */
    if (message.quantity !== undefined) writer.tag(2, WireType.Varint).uint32(message.quantity);
    /* optional uint32 cost_in_local_currency = 3; */
    if (message.cost_in_local_currency !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.cost_in_local_currency);
    /* optional uint32 purchase_type = 4; */
    if (message.purchase_type !== undefined) writer.tag(4, WireType.Varint).uint32(message.purchase_type);
    /* optional uint64 source_reference_id = 5; */
    if (message.source_reference_id !== undefined) writer.tag(5, WireType.Varint).uint64(message.source_reference_id);
    /* optional int32 price_index = 6; */
    if (message.price_index !== undefined) writer.tag(6, WireType.Varint).int32(message.price_index);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CGCStorePurchaseInit_LineItem
 */
export const CGCStorePurchaseInit_LineItem = new CGCStorePurchaseInit_LineItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCStorePurchaseInit$Type extends MessageType<CMsgGCStorePurchaseInit> {
  constructor() {
    super("CMsgGCStorePurchaseInit", [
      {
        no: 1,
        name: "country",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "language",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "currency",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 4,
        name: "line_items",
        kind: "message",
        localName: "line_items",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CGCStorePurchaseInit_LineItem,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCStorePurchaseInit>): CMsgGCStorePurchaseInit {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.line_items = [];
    if (value !== undefined) reflectionMergePartial<CMsgGCStorePurchaseInit>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCStorePurchaseInit,
  ): CMsgGCStorePurchaseInit {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string country */ 1:
          message.country = reader.string();
          break;
        case /* optional int32 language */ 2:
          message.language = reader.int32();
          break;
        case /* optional int32 currency */ 3:
          message.currency = reader.int32();
          break;
        case /* repeated CGCStorePurchaseInit_LineItem line_items */ 4:
          message.line_items.push(CGCStorePurchaseInit_LineItem.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCStorePurchaseInit,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string country = 1; */
    if (message.country !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.country);
    /* optional int32 language = 2; */
    if (message.language !== undefined) writer.tag(2, WireType.Varint).int32(message.language);
    /* optional int32 currency = 3; */
    if (message.currency !== undefined) writer.tag(3, WireType.Varint).int32(message.currency);
    /* repeated CGCStorePurchaseInit_LineItem line_items = 4; */
    for (let i = 0; i < message.line_items.length; i++)
      CGCStorePurchaseInit_LineItem.internalBinaryWrite(
        message.line_items[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCStorePurchaseInit
 */
export const CMsgGCStorePurchaseInit = new CMsgGCStorePurchaseInit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCStorePurchaseInitResponse$Type extends MessageType<CMsgGCStorePurchaseInitResponse> {
  constructor() {
    super("CMsgGCStorePurchaseInitResponse", [
      {
        no: 1,
        name: "result",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "txn_id",
        kind: "scalar",
        localName: "txn_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCStorePurchaseInitResponse>): CMsgGCStorePurchaseInitResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCStorePurchaseInitResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCStorePurchaseInitResponse,
  ): CMsgGCStorePurchaseInitResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 result */ 1:
          message.result = reader.int32();
          break;
        case /* optional uint64 txn_id */ 2:
          message.txn_id = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCStorePurchaseInitResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 result = 1; */
    if (message.result !== undefined) writer.tag(1, WireType.Varint).int32(message.result);
    /* optional uint64 txn_id = 2; */
    if (message.txn_id !== undefined) writer.tag(2, WireType.Varint).uint64(message.txn_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCStorePurchaseInitResponse
 */
export const CMsgGCStorePurchaseInitResponse = new CMsgGCStorePurchaseInitResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPingData$Type extends MessageType<CMsgClientPingData> {
  constructor() {
    super("CMsgClientPingData", [
      {
        no: 4,
        name: "relay_codes",
        kind: "scalar",
        localName: "relay_codes",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 7 /*ScalarType.FIXED32*/,
      },
      {
        no: 5,
        name: "relay_pings",
        kind: "scalar",
        localName: "relay_pings",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 8,
        name: "region_codes",
        kind: "scalar",
        localName: "region_codes",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 9,
        name: "region_pings",
        kind: "scalar",
        localName: "region_pings",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 10,
        name: "region_ping_failed_bitmask",
        kind: "scalar",
        localName: "region_ping_failed_bitmask",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgClientPingData>): CMsgClientPingData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.relay_codes = [];
    message.relay_pings = [];
    message.region_codes = [];
    message.region_pings = [];
    if (value !== undefined) reflectionMergePartial<CMsgClientPingData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgClientPingData,
  ): CMsgClientPingData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated fixed32 relay_codes = 4 [packed = true];*/ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.relay_codes.push(reader.fixed32());
          else message.relay_codes.push(reader.fixed32());
          break;
        case /* repeated uint32 relay_pings = 5 [packed = true];*/ 5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.relay_pings.push(reader.uint32());
          else message.relay_pings.push(reader.uint32());
          break;
        case /* repeated uint32 region_codes = 8 [packed = true];*/ 8:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.region_codes.push(reader.uint32());
          else message.region_codes.push(reader.uint32());
          break;
        case /* repeated uint32 region_pings = 9 [packed = true];*/ 9:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.region_pings.push(reader.uint32());
          else message.region_pings.push(reader.uint32());
          break;
        case /* optional uint32 region_ping_failed_bitmask */ 10:
          message.region_ping_failed_bitmask = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgClientPingData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* repeated fixed32 relay_codes = 4 [packed = true]; */
    if (message.relay_codes.length) {
      writer.tag(4, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.relay_codes.length; i++) writer.fixed32(message.relay_codes[i]);
      writer.join();
    }
    /* repeated uint32 relay_pings = 5 [packed = true]; */
    if (message.relay_pings.length) {
      writer.tag(5, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.relay_pings.length; i++) writer.uint32(message.relay_pings[i]);
      writer.join();
    }
    /* repeated uint32 region_codes = 8 [packed = true]; */
    if (message.region_codes.length) {
      writer.tag(8, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.region_codes.length; i++) writer.uint32(message.region_codes[i]);
      writer.join();
    }
    /* repeated uint32 region_pings = 9 [packed = true]; */
    if (message.region_pings.length) {
      writer.tag(9, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.region_pings.length; i++) writer.uint32(message.region_pings[i]);
      writer.join();
    }
    /* optional uint32 region_ping_failed_bitmask = 10; */
    if (message.region_ping_failed_bitmask !== undefined)
      writer.tag(10, WireType.Varint).uint32(message.region_ping_failed_bitmask);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgClientPingData
 */
export const CMsgClientPingData = new CMsgClientPingData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgInviteToParty$Type extends MessageType<CMsgInviteToParty> {
  constructor() {
    super("CMsgInviteToParty", [
      {
        no: 1,
        name: "steam_id",
        kind: "scalar",
        localName: "steam_id",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "client_version",
        kind: "scalar",
        localName: "client_version",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "team_id",
        kind: "scalar",
        localName: "team_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "as_coach",
        kind: "scalar",
        localName: "as_coach",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 5,
        name: "ping_data",
        kind: "message",
        localName: "ping_data",
        T: () => CMsgClientPingData,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgInviteToParty>): CMsgInviteToParty {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgInviteToParty>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgInviteToParty,
  ): CMsgInviteToParty {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 steam_id */ 1:
          message.steam_id = reader.fixed64().toBigInt();
          break;
        case /* optional uint32 client_version */ 2:
          message.client_version = reader.uint32();
          break;
        case /* optional uint32 team_id */ 3:
          message.team_id = reader.uint32();
          break;
        case /* optional bool as_coach */ 4:
          message.as_coach = reader.bool();
          break;
        case /* optional CMsgClientPingData ping_data */ 5:
          message.ping_data = CMsgClientPingData.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.ping_data,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgInviteToParty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional fixed64 steam_id = 1; */
    if (message.steam_id !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steam_id);
    /* optional uint32 client_version = 2; */
    if (message.client_version !== undefined) writer.tag(2, WireType.Varint).uint32(message.client_version);
    /* optional uint32 team_id = 3; */
    if (message.team_id !== undefined) writer.tag(3, WireType.Varint).uint32(message.team_id);
    /* optional bool as_coach = 4; */
    if (message.as_coach !== undefined) writer.tag(4, WireType.Varint).bool(message.as_coach);
    /* optional CMsgClientPingData ping_data = 5; */
    if (message.ping_data)
      CMsgClientPingData.internalBinaryWrite(
        message.ping_data,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgInviteToParty
 */
export const CMsgInviteToParty = new CMsgInviteToParty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgInviteToLobby$Type extends MessageType<CMsgInviteToLobby> {
  constructor() {
    super("CMsgInviteToLobby", [
      {
        no: 1,
        name: "steam_id",
        kind: "scalar",
        localName: "steam_id",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "client_version",
        kind: "scalar",
        localName: "client_version",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgInviteToLobby>): CMsgInviteToLobby {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgInviteToLobby>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgInviteToLobby,
  ): CMsgInviteToLobby {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 steam_id */ 1:
          message.steam_id = reader.fixed64().toBigInt();
          break;
        case /* optional uint32 client_version */ 2:
          message.client_version = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgInviteToLobby, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional fixed64 steam_id = 1; */
    if (message.steam_id !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steam_id);
    /* optional uint32 client_version = 2; */
    if (message.client_version !== undefined) writer.tag(2, WireType.Varint).uint32(message.client_version);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgInviteToLobby
 */
export const CMsgInviteToLobby = new CMsgInviteToLobby$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgInvitationCreated$Type extends MessageType<CMsgInvitationCreated> {
  constructor() {
    super("CMsgInvitationCreated", [
      {
        no: 1,
        name: "group_id",
        kind: "scalar",
        localName: "group_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "steam_id",
        kind: "scalar",
        localName: "steam_id",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "user_offline",
        kind: "scalar",
        localName: "user_offline",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgInvitationCreated>): CMsgInvitationCreated {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgInvitationCreated>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgInvitationCreated,
  ): CMsgInvitationCreated {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 group_id */ 1:
          message.group_id = reader.uint64().toBigInt();
          break;
        case /* optional fixed64 steam_id */ 2:
          message.steam_id = reader.fixed64().toBigInt();
          break;
        case /* optional bool user_offline */ 3:
          message.user_offline = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgInvitationCreated,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 group_id = 1; */
    if (message.group_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.group_id);
    /* optional fixed64 steam_id = 2; */
    if (message.steam_id !== undefined) writer.tag(2, WireType.Bit64).fixed64(message.steam_id);
    /* optional bool user_offline = 3; */
    if (message.user_offline !== undefined) writer.tag(3, WireType.Varint).bool(message.user_offline);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgInvitationCreated
 */
export const CMsgInvitationCreated = new CMsgInvitationCreated$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgPartyInviteResponse$Type extends MessageType<CMsgPartyInviteResponse> {
  constructor() {
    super("CMsgPartyInviteResponse", [
      {
        no: 1,
        name: "party_id",
        kind: "scalar",
        localName: "party_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "accept",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 3,
        name: "client_version",
        kind: "scalar",
        localName: "client_version",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 8,
        name: "ping_data",
        kind: "message",
        localName: "ping_data",
        T: () => CMsgClientPingData,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgPartyInviteResponse>): CMsgPartyInviteResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgPartyInviteResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgPartyInviteResponse,
  ): CMsgPartyInviteResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 party_id */ 1:
          message.party_id = reader.uint64().toBigInt();
          break;
        case /* optional bool accept */ 2:
          message.accept = reader.bool();
          break;
        case /* optional uint32 client_version */ 3:
          message.client_version = reader.uint32();
          break;
        case /* optional CMsgClientPingData ping_data */ 8:
          message.ping_data = CMsgClientPingData.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.ping_data,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgPartyInviteResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 party_id = 1; */
    if (message.party_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.party_id);
    /* optional bool accept = 2; */
    if (message.accept !== undefined) writer.tag(2, WireType.Varint).bool(message.accept);
    /* optional uint32 client_version = 3; */
    if (message.client_version !== undefined) writer.tag(3, WireType.Varint).uint32(message.client_version);
    /* optional CMsgClientPingData ping_data = 8; */
    if (message.ping_data)
      CMsgClientPingData.internalBinaryWrite(
        message.ping_data,
        writer.tag(8, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgPartyInviteResponse
 */
export const CMsgPartyInviteResponse = new CMsgPartyInviteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgLobbyInviteResponse$Type extends MessageType<CMsgLobbyInviteResponse> {
  constructor() {
    super("CMsgLobbyInviteResponse", [
      {
        no: 1,
        name: "lobby_id",
        kind: "scalar",
        localName: "lobby_id",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "accept",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 3,
        name: "client_version",
        kind: "scalar",
        localName: "client_version",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "custom_game_crc",
        kind: "scalar",
        localName: "custom_game_crc",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 7,
        name: "custom_game_timestamp",
        kind: "scalar",
        localName: "custom_game_timestamp",
        opt: true,
        T: 7 /*ScalarType.FIXED32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgLobbyInviteResponse>): CMsgLobbyInviteResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgLobbyInviteResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgLobbyInviteResponse,
  ): CMsgLobbyInviteResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 lobby_id */ 1:
          message.lobby_id = reader.fixed64().toBigInt();
          break;
        case /* optional bool accept */ 2:
          message.accept = reader.bool();
          break;
        case /* optional uint32 client_version */ 3:
          message.client_version = reader.uint32();
          break;
        case /* optional fixed64 custom_game_crc */ 6:
          message.custom_game_crc = reader.fixed64().toBigInt();
          break;
        case /* optional fixed32 custom_game_timestamp */ 7:
          message.custom_game_timestamp = reader.fixed32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgLobbyInviteResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed64 lobby_id = 1; */
    if (message.lobby_id !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.lobby_id);
    /* optional bool accept = 2; */
    if (message.accept !== undefined) writer.tag(2, WireType.Varint).bool(message.accept);
    /* optional uint32 client_version = 3; */
    if (message.client_version !== undefined) writer.tag(3, WireType.Varint).uint32(message.client_version);
    /* optional fixed64 custom_game_crc = 6; */
    if (message.custom_game_crc !== undefined) writer.tag(6, WireType.Bit64).fixed64(message.custom_game_crc);
    /* optional fixed32 custom_game_timestamp = 7; */
    if (message.custom_game_timestamp !== undefined)
      writer.tag(7, WireType.Bit32).fixed32(message.custom_game_timestamp);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgLobbyInviteResponse
 */
export const CMsgLobbyInviteResponse = new CMsgLobbyInviteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgKickFromParty$Type extends MessageType<CMsgKickFromParty> {
  constructor() {
    super("CMsgKickFromParty", [
      {
        no: 1,
        name: "steam_id",
        kind: "scalar",
        localName: "steam_id",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgKickFromParty>): CMsgKickFromParty {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgKickFromParty>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgKickFromParty,
  ): CMsgKickFromParty {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 steam_id */ 1:
          message.steam_id = reader.fixed64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgKickFromParty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional fixed64 steam_id = 1; */
    if (message.steam_id !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steam_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgKickFromParty
 */
export const CMsgKickFromParty = new CMsgKickFromParty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgLeaveParty$Type extends MessageType<CMsgLeaveParty> {
  constructor() {
    super("CMsgLeaveParty", []);
  }
  create(value?: PartialMessage<CMsgLeaveParty>): CMsgLeaveParty {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgLeaveParty>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgLeaveParty,
  ): CMsgLeaveParty {
    return target ?? this.create();
  }
  internalBinaryWrite(message: CMsgLeaveParty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgLeaveParty
 */
export const CMsgLeaveParty = new CMsgLeaveParty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgCustomGameInstallStatus$Type extends MessageType<CMsgCustomGameInstallStatus> {
  constructor() {
    super("CMsgCustomGameInstallStatus", [
      {
        no: 1,
        name: "status",
        kind: "enum",
        opt: true,
        T: () => ["ECustomGameInstallStatus", ECustomGameInstallStatus],
      },
      {
        no: 2,
        name: "message",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: "latest_timestamp_from_steam",
        kind: "scalar",
        localName: "latest_timestamp_from_steam",
        opt: true,
        T: 7 /*ScalarType.FIXED32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgCustomGameInstallStatus>): CMsgCustomGameInstallStatus {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgCustomGameInstallStatus>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgCustomGameInstallStatus,
  ): CMsgCustomGameInstallStatus {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional ECustomGameInstallStatus status */ 1:
          message.status = reader.int32();
          break;
        case /* optional string message */ 2:
          message.message = reader.string();
          break;
        case /* optional fixed32 latest_timestamp_from_steam */ 3:
          message.latest_timestamp_from_steam = reader.fixed32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgCustomGameInstallStatus,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional ECustomGameInstallStatus status = 1; */
    if (message.status !== undefined) writer.tag(1, WireType.Varint).int32(message.status);
    /* optional string message = 2; */
    if (message.message !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.message);
    /* optional fixed32 latest_timestamp_from_steam = 3; */
    if (message.latest_timestamp_from_steam !== undefined)
      writer.tag(3, WireType.Bit32).fixed32(message.latest_timestamp_from_steam);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgCustomGameInstallStatus
 */
export const CMsgCustomGameInstallStatus = new CMsgCustomGameInstallStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgServerAvailable$Type extends MessageType<CMsgServerAvailable> {
  constructor() {
    super("CMsgServerAvailable", [
      {
        no: 1,
        name: "custom_game_install_status",
        kind: "message",
        localName: "custom_game_install_status",
        T: () => CMsgCustomGameInstallStatus,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgServerAvailable>): CMsgServerAvailable {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgServerAvailable>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgServerAvailable,
  ): CMsgServerAvailable {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgCustomGameInstallStatus custom_game_install_status */ 1:
          message.custom_game_install_status = CMsgCustomGameInstallStatus.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.custom_game_install_status,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgServerAvailable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional CMsgCustomGameInstallStatus custom_game_install_status = 1; */
    if (message.custom_game_install_status)
      CMsgCustomGameInstallStatus.internalBinaryWrite(
        message.custom_game_install_status,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgServerAvailable
 */
export const CMsgServerAvailable = new CMsgServerAvailable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgLANServerAvailable$Type extends MessageType<CMsgLANServerAvailable> {
  constructor() {
    super("CMsgLANServerAvailable", [
      {
        no: 1,
        name: "lobby_id",
        kind: "scalar",
        localName: "lobby_id",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgLANServerAvailable>): CMsgLANServerAvailable {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgLANServerAvailable>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgLANServerAvailable,
  ): CMsgLANServerAvailable {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 lobby_id */ 1:
          message.lobby_id = reader.fixed64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgLANServerAvailable,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed64 lobby_id = 1; */
    if (message.lobby_id !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.lobby_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgLANServerAvailable
 */
export const CMsgLANServerAvailable = new CMsgLANServerAvailable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSOEconGameAccountClient$Type extends MessageType<CSOEconGameAccountClient> {
  constructor() {
    super("CSOEconGameAccountClient", [
      {
        no: 1,
        name: "additional_backpack_slots",
        kind: "scalar",
        localName: "additional_backpack_slots",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "trial_account",
        kind: "scalar",
        localName: "trial_account",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 3,
        name: "eligible_for_online_play",
        kind: "scalar",
        localName: "eligible_for_online_play",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 4,
        name: "need_to_choose_most_helpful_friend",
        kind: "scalar",
        localName: "need_to_choose_most_helpful_friend",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 5,
        name: "in_coaches_list",
        kind: "scalar",
        localName: "in_coaches_list",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 6,
        name: "trade_ban_expiration",
        kind: "scalar",
        localName: "trade_ban_expiration",
        opt: true,
        T: 7 /*ScalarType.FIXED32*/,
      },
      {
        no: 7,
        name: "duel_ban_expiration",
        kind: "scalar",
        localName: "duel_ban_expiration",
        opt: true,
        T: 7 /*ScalarType.FIXED32*/,
      },
      {
        no: 9,
        name: "made_first_purchase",
        kind: "scalar",
        localName: "made_first_purchase",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<CSOEconGameAccountClient>): CSOEconGameAccountClient {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CSOEconGameAccountClient>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CSOEconGameAccountClient,
  ): CSOEconGameAccountClient {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 additional_backpack_slots */ 1:
          message.additional_backpack_slots = reader.uint32();
          break;
        case /* optional bool trial_account */ 2:
          message.trial_account = reader.bool();
          break;
        case /* optional bool eligible_for_online_play */ 3:
          message.eligible_for_online_play = reader.bool();
          break;
        case /* optional bool need_to_choose_most_helpful_friend */ 4:
          message.need_to_choose_most_helpful_friend = reader.bool();
          break;
        case /* optional bool in_coaches_list */ 5:
          message.in_coaches_list = reader.bool();
          break;
        case /* optional fixed32 trade_ban_expiration */ 6:
          message.trade_ban_expiration = reader.fixed32();
          break;
        case /* optional fixed32 duel_ban_expiration */ 7:
          message.duel_ban_expiration = reader.fixed32();
          break;
        case /* optional bool made_first_purchase */ 9:
          message.made_first_purchase = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CSOEconGameAccountClient,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 additional_backpack_slots = 1; */
    if (message.additional_backpack_slots !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.additional_backpack_slots);
    /* optional bool trial_account = 2; */
    if (message.trial_account !== undefined) writer.tag(2, WireType.Varint).bool(message.trial_account);
    /* optional bool eligible_for_online_play = 3; */
    if (message.eligible_for_online_play !== undefined)
      writer.tag(3, WireType.Varint).bool(message.eligible_for_online_play);
    /* optional bool need_to_choose_most_helpful_friend = 4; */
    if (message.need_to_choose_most_helpful_friend !== undefined)
      writer.tag(4, WireType.Varint).bool(message.need_to_choose_most_helpful_friend);
    /* optional bool in_coaches_list = 5; */
    if (message.in_coaches_list !== undefined) writer.tag(5, WireType.Varint).bool(message.in_coaches_list);
    /* optional fixed32 trade_ban_expiration = 6; */
    if (message.trade_ban_expiration !== undefined) writer.tag(6, WireType.Bit32).fixed32(message.trade_ban_expiration);
    /* optional fixed32 duel_ban_expiration = 7; */
    if (message.duel_ban_expiration !== undefined) writer.tag(7, WireType.Bit32).fixed32(message.duel_ban_expiration);
    /* optional bool made_first_purchase = 9; */
    if (message.made_first_purchase !== undefined) writer.tag(9, WireType.Varint).bool(message.made_first_purchase);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CSOEconGameAccountClient
 */
export const CSOEconGameAccountClient = new CSOEconGameAccountClient$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgApplyStrangePart$Type extends MessageType<CMsgApplyStrangePart> {
  constructor() {
    super("CMsgApplyStrangePart", [
      {
        no: 1,
        name: "strange_part_item_id",
        kind: "scalar",
        localName: "strange_part_item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "item_item_id",
        kind: "scalar",
        localName: "item_item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgApplyStrangePart>): CMsgApplyStrangePart {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgApplyStrangePart>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgApplyStrangePart,
  ): CMsgApplyStrangePart {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 strange_part_item_id */ 1:
          message.strange_part_item_id = reader.uint64().toBigInt();
          break;
        case /* optional uint64 item_item_id */ 2:
          message.item_item_id = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgApplyStrangePart,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 strange_part_item_id = 1; */
    if (message.strange_part_item_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.strange_part_item_id);
    /* optional uint64 item_item_id = 2; */
    if (message.item_item_id !== undefined) writer.tag(2, WireType.Varint).uint64(message.item_item_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgApplyStrangePart
 */
export const CMsgApplyStrangePart = new CMsgApplyStrangePart$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgApplyPennantUpgrade$Type extends MessageType<CMsgApplyPennantUpgrade> {
  constructor() {
    super("CMsgApplyPennantUpgrade", [
      {
        no: 1,
        name: "upgrade_item_id",
        kind: "scalar",
        localName: "upgrade_item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "pennant_item_id",
        kind: "scalar",
        localName: "pennant_item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgApplyPennantUpgrade>): CMsgApplyPennantUpgrade {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgApplyPennantUpgrade>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgApplyPennantUpgrade,
  ): CMsgApplyPennantUpgrade {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 upgrade_item_id */ 1:
          message.upgrade_item_id = reader.uint64().toBigInt();
          break;
        case /* optional uint64 pennant_item_id */ 2:
          message.pennant_item_id = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgApplyPennantUpgrade,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 upgrade_item_id = 1; */
    if (message.upgrade_item_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.upgrade_item_id);
    /* optional uint64 pennant_item_id = 2; */
    if (message.pennant_item_id !== undefined) writer.tag(2, WireType.Varint).uint64(message.pennant_item_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgApplyPennantUpgrade
 */
export const CMsgApplyPennantUpgrade = new CMsgApplyPennantUpgrade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgApplyEggEssence$Type extends MessageType<CMsgApplyEggEssence> {
  constructor() {
    super("CMsgApplyEggEssence", [
      {
        no: 1,
        name: "essence_item_id",
        kind: "scalar",
        localName: "essence_item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "egg_item_id",
        kind: "scalar",
        localName: "egg_item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgApplyEggEssence>): CMsgApplyEggEssence {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgApplyEggEssence>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgApplyEggEssence,
  ): CMsgApplyEggEssence {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 essence_item_id */ 1:
          message.essence_item_id = reader.uint64().toBigInt();
          break;
        case /* optional uint64 egg_item_id */ 2:
          message.egg_item_id = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgApplyEggEssence, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional uint64 essence_item_id = 1; */
    if (message.essence_item_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.essence_item_id);
    /* optional uint64 egg_item_id = 2; */
    if (message.egg_item_id !== undefined) writer.tag(2, WireType.Varint).uint64(message.egg_item_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgApplyEggEssence
 */
export const CMsgApplyEggEssence = new CMsgApplyEggEssence$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSOEconItemAttribute$Type extends MessageType<CSOEconItemAttribute> {
  constructor() {
    super("CSOEconItemAttribute", [
      {
        no: 1,
        name: "def_index",
        kind: "scalar",
        localName: "def_index",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "value",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "value_bytes",
        kind: "scalar",
        localName: "value_bytes",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<CSOEconItemAttribute>): CSOEconItemAttribute {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CSOEconItemAttribute>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CSOEconItemAttribute,
  ): CSOEconItemAttribute {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 def_index */ 1:
          message.def_index = reader.uint32();
          break;
        case /* optional uint32 value */ 2:
          message.value = reader.uint32();
          break;
        case /* optional bytes value_bytes */ 3:
          message.value_bytes = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CSOEconItemAttribute,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 def_index = 1; */
    if (message.def_index !== undefined) writer.tag(1, WireType.Varint).uint32(message.def_index);
    /* optional uint32 value = 2; */
    if (message.value !== undefined) writer.tag(2, WireType.Varint).uint32(message.value);
    /* optional bytes value_bytes = 3; */
    if (message.value_bytes !== undefined) writer.tag(3, WireType.LengthDelimited).bytes(message.value_bytes);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CSOEconItemAttribute
 */
export const CSOEconItemAttribute = new CSOEconItemAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSOEconItemEquipped$Type extends MessageType<CSOEconItemEquipped> {
  constructor() {
    super("CSOEconItemEquipped", [
      {
        no: 1,
        name: "new_class",
        kind: "scalar",
        localName: "new_class",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "new_slot",
        kind: "scalar",
        localName: "new_slot",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CSOEconItemEquipped>): CSOEconItemEquipped {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CSOEconItemEquipped>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CSOEconItemEquipped,
  ): CSOEconItemEquipped {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 new_class */ 1:
          message.new_class = reader.uint32();
          break;
        case /* optional uint32 new_slot */ 2:
          message.new_slot = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CSOEconItemEquipped, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional uint32 new_class = 1; */
    if (message.new_class !== undefined) writer.tag(1, WireType.Varint).uint32(message.new_class);
    /* optional uint32 new_slot = 2; */
    if (message.new_slot !== undefined) writer.tag(2, WireType.Varint).uint32(message.new_slot);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CSOEconItemEquipped
 */
export const CSOEconItemEquipped = new CSOEconItemEquipped$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSOEconItem$Type extends MessageType<CSOEconItem> {
  constructor() {
    super("CSOEconItem", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "account_id",
        kind: "scalar",
        localName: "account_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "inventory",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "def_index",
        kind: "scalar",
        localName: "def_index",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "quantity",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "level",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 7,
        name: "quality",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 8,
        name: "flags",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 9,
        name: "origin",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 12,
        name: "attribute",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CSOEconItemAttribute,
      },
      {
        no: 13,
        name: "interior_item",
        kind: "message",
        localName: "interior_item",
        T: () => CSOEconItem,
      },
      {
        no: 15,
        name: "style",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 16,
        name: "original_id",
        kind: "scalar",
        localName: "original_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 18,
        name: "equipped_state",
        kind: "message",
        localName: "equipped_state",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CSOEconItemEquipped,
      },
    ]);
  }
  create(value?: PartialMessage<CSOEconItem>): CSOEconItem {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.attribute = [];
    message.equipped_state = [];
    if (value !== undefined) reflectionMergePartial<CSOEconItem>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CSOEconItem,
  ): CSOEconItem {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 id */ 1:
          message.id = reader.uint64().toBigInt();
          break;
        case /* optional uint32 account_id */ 2:
          message.account_id = reader.uint32();
          break;
        case /* optional uint32 inventory */ 3:
          message.inventory = reader.uint32();
          break;
        case /* optional uint32 def_index */ 4:
          message.def_index = reader.uint32();
          break;
        case /* optional uint32 quantity */ 5:
          message.quantity = reader.uint32();
          break;
        case /* optional uint32 level */ 6:
          message.level = reader.uint32();
          break;
        case /* optional uint32 quality */ 7:
          message.quality = reader.uint32();
          break;
        case /* optional uint32 flags */ 8:
          message.flags = reader.uint32();
          break;
        case /* optional uint32 origin */ 9:
          message.origin = reader.uint32();
          break;
        case /* repeated CSOEconItemAttribute attribute */ 12:
          message.attribute.push(CSOEconItemAttribute.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* optional CSOEconItem interior_item */ 13:
          message.interior_item = CSOEconItem.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.interior_item,
          );
          break;
        case /* optional uint32 style */ 15:
          message.style = reader.uint32();
          break;
        case /* optional uint64 original_id */ 16:
          message.original_id = reader.uint64().toBigInt();
          break;
        case /* repeated CSOEconItemEquipped equipped_state */ 18:
          message.equipped_state.push(CSOEconItemEquipped.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CSOEconItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional uint64 id = 1; */
    if (message.id !== undefined) writer.tag(1, WireType.Varint).uint64(message.id);
    /* optional uint32 account_id = 2; */
    if (message.account_id !== undefined) writer.tag(2, WireType.Varint).uint32(message.account_id);
    /* optional uint32 inventory = 3; */
    if (message.inventory !== undefined) writer.tag(3, WireType.Varint).uint32(message.inventory);
    /* optional uint32 def_index = 4; */
    if (message.def_index !== undefined) writer.tag(4, WireType.Varint).uint32(message.def_index);
    /* optional uint32 quantity = 5; */
    if (message.quantity !== undefined) writer.tag(5, WireType.Varint).uint32(message.quantity);
    /* optional uint32 level = 6; */
    if (message.level !== undefined) writer.tag(6, WireType.Varint).uint32(message.level);
    /* optional uint32 quality = 7; */
    if (message.quality !== undefined) writer.tag(7, WireType.Varint).uint32(message.quality);
    /* optional uint32 flags = 8; */
    if (message.flags !== undefined) writer.tag(8, WireType.Varint).uint32(message.flags);
    /* optional uint32 origin = 9; */
    if (message.origin !== undefined) writer.tag(9, WireType.Varint).uint32(message.origin);
    /* repeated CSOEconItemAttribute attribute = 12; */
    for (let i = 0; i < message.attribute.length; i++)
      CSOEconItemAttribute.internalBinaryWrite(
        message.attribute[i],
        writer.tag(12, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CSOEconItem interior_item = 13; */
    if (message.interior_item)
      CSOEconItem.internalBinaryWrite(
        message.interior_item,
        writer.tag(13, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 style = 15; */
    if (message.style !== undefined) writer.tag(15, WireType.Varint).uint32(message.style);
    /* optional uint64 original_id = 16; */
    if (message.original_id !== undefined) writer.tag(16, WireType.Varint).uint64(message.original_id);
    /* repeated CSOEconItemEquipped equipped_state = 18; */
    for (let i = 0; i < message.equipped_state.length; i++)
      CSOEconItemEquipped.internalBinaryWrite(
        message.equipped_state[i],
        writer.tag(18, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CSOEconItem
 */
export const CSOEconItem = new CSOEconItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSortItems$Type extends MessageType<CMsgSortItems> {
  constructor() {
    super("CMsgSortItems", [
      {
        no: 1,
        name: "sort_type",
        kind: "scalar",
        localName: "sort_type",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSortItems>): CMsgSortItems {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSortItems>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSortItems,
  ): CMsgSortItems {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 sort_type */ 1:
          message.sort_type = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgSortItems, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional uint32 sort_type = 1; */
    if (message.sort_type !== undefined) writer.tag(1, WireType.Varint).uint32(message.sort_type);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSortItems
 */
export const CMsgSortItems = new CMsgSortItems$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgItemAcknowledged$Type extends MessageType<CMsgItemAcknowledged> {
  constructor() {
    super("CMsgItemAcknowledged", [
      {
        no: 1,
        name: "account_id",
        kind: "scalar",
        localName: "account_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "inventory",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "def_index",
        kind: "scalar",
        localName: "def_index",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "quality",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "rarity",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "origin",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgItemAcknowledged>): CMsgItemAcknowledged {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgItemAcknowledged>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgItemAcknowledged,
  ): CMsgItemAcknowledged {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 account_id */ 1:
          message.account_id = reader.uint32();
          break;
        case /* optional uint32 inventory */ 2:
          message.inventory = reader.uint32();
          break;
        case /* optional uint32 def_index */ 3:
          message.def_index = reader.uint32();
          break;
        case /* optional uint32 quality */ 4:
          message.quality = reader.uint32();
          break;
        case /* optional uint32 rarity */ 5:
          message.rarity = reader.uint32();
          break;
        case /* optional uint32 origin */ 6:
          message.origin = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgItemAcknowledged,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 account_id = 1; */
    if (message.account_id !== undefined) writer.tag(1, WireType.Varint).uint32(message.account_id);
    /* optional uint32 inventory = 2; */
    if (message.inventory !== undefined) writer.tag(2, WireType.Varint).uint32(message.inventory);
    /* optional uint32 def_index = 3; */
    if (message.def_index !== undefined) writer.tag(3, WireType.Varint).uint32(message.def_index);
    /* optional uint32 quality = 4; */
    if (message.quality !== undefined) writer.tag(4, WireType.Varint).uint32(message.quality);
    /* optional uint32 rarity = 5; */
    if (message.rarity !== undefined) writer.tag(5, WireType.Varint).uint32(message.rarity);
    /* optional uint32 origin = 6; */
    if (message.origin !== undefined) writer.tag(6, WireType.Varint).uint32(message.origin);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgItemAcknowledged
 */
export const CMsgItemAcknowledged = new CMsgItemAcknowledged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSetItemPositions$Type extends MessageType<CMsgSetItemPositions> {
  constructor() {
    super("CMsgSetItemPositions", [
      {
        no: 1,
        name: "item_positions",
        kind: "message",
        localName: "item_positions",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgSetItemPositions_ItemPosition,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSetItemPositions>): CMsgSetItemPositions {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.item_positions = [];
    if (value !== undefined) reflectionMergePartial<CMsgSetItemPositions>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSetItemPositions,
  ): CMsgSetItemPositions {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CMsgSetItemPositions.ItemPosition item_positions */ 1:
          message.item_positions.push(
            CMsgSetItemPositions_ItemPosition.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSetItemPositions,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CMsgSetItemPositions.ItemPosition item_positions = 1; */
    for (let i = 0; i < message.item_positions.length; i++)
      CMsgSetItemPositions_ItemPosition.internalBinaryWrite(
        message.item_positions[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSetItemPositions
 */
export const CMsgSetItemPositions = new CMsgSetItemPositions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSetItemPositions_ItemPosition$Type extends MessageType<CMsgSetItemPositions_ItemPosition> {
  constructor() {
    super("CMsgSetItemPositions.ItemPosition", [
      {
        no: 1,
        name: "item_id",
        kind: "scalar",
        localName: "item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "position",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSetItemPositions_ItemPosition>): CMsgSetItemPositions_ItemPosition {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSetItemPositions_ItemPosition>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSetItemPositions_ItemPosition,
  ): CMsgSetItemPositions_ItemPosition {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 item_id */ 1:
          message.item_id = reader.uint64().toBigInt();
          break;
        case /* optional uint32 position */ 2:
          message.position = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSetItemPositions_ItemPosition,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 item_id = 1; */
    if (message.item_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.item_id);
    /* optional uint32 position = 2; */
    if (message.position !== undefined) writer.tag(2, WireType.Varint).uint32(message.position);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSetItemPositions.ItemPosition
 */
export const CMsgSetItemPositions_ItemPosition = new CMsgSetItemPositions_ItemPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCStorePurchaseCancel$Type extends MessageType<CMsgGCStorePurchaseCancel> {
  constructor() {
    super("CMsgGCStorePurchaseCancel", [
      {
        no: 1,
        name: "txn_id",
        kind: "scalar",
        localName: "txn_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCStorePurchaseCancel>): CMsgGCStorePurchaseCancel {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCStorePurchaseCancel>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCStorePurchaseCancel,
  ): CMsgGCStorePurchaseCancel {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 txn_id */ 1:
          message.txn_id = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCStorePurchaseCancel,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 txn_id = 1; */
    if (message.txn_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.txn_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCStorePurchaseCancel
 */
export const CMsgGCStorePurchaseCancel = new CMsgGCStorePurchaseCancel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCStorePurchaseCancelResponse$Type extends MessageType<CMsgGCStorePurchaseCancelResponse> {
  constructor() {
    super("CMsgGCStorePurchaseCancelResponse", [
      {
        no: 1,
        name: "result",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCStorePurchaseCancelResponse>): CMsgGCStorePurchaseCancelResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCStorePurchaseCancelResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCStorePurchaseCancelResponse,
  ): CMsgGCStorePurchaseCancelResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 result */ 1:
          message.result = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCStorePurchaseCancelResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 result = 1; */
    if (message.result !== undefined) writer.tag(1, WireType.Varint).uint32(message.result);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCStorePurchaseCancelResponse
 */
export const CMsgGCStorePurchaseCancelResponse = new CMsgGCStorePurchaseCancelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCStorePurchaseFinalize$Type extends MessageType<CMsgGCStorePurchaseFinalize> {
  constructor() {
    super("CMsgGCStorePurchaseFinalize", [
      {
        no: 1,
        name: "txn_id",
        kind: "scalar",
        localName: "txn_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCStorePurchaseFinalize>): CMsgGCStorePurchaseFinalize {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCStorePurchaseFinalize>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCStorePurchaseFinalize,
  ): CMsgGCStorePurchaseFinalize {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 txn_id */ 1:
          message.txn_id = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCStorePurchaseFinalize,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 txn_id = 1; */
    if (message.txn_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.txn_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCStorePurchaseFinalize
 */
export const CMsgGCStorePurchaseFinalize = new CMsgGCStorePurchaseFinalize$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCStorePurchaseFinalizeResponse$Type extends MessageType<CMsgGCStorePurchaseFinalizeResponse> {
  constructor() {
    super("CMsgGCStorePurchaseFinalizeResponse", [
      {
        no: 1,
        name: "result",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "item_ids",
        kind: "scalar",
        localName: "item_ids",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCStorePurchaseFinalizeResponse>): CMsgGCStorePurchaseFinalizeResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.item_ids = [];
    if (value !== undefined) reflectionMergePartial<CMsgGCStorePurchaseFinalizeResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCStorePurchaseFinalizeResponse,
  ): CMsgGCStorePurchaseFinalizeResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 result */ 1:
          message.result = reader.uint32();
          break;
        case /* repeated uint64 item_ids */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.item_ids.push(reader.uint64().toBigInt());
          else message.item_ids.push(reader.uint64().toBigInt());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCStorePurchaseFinalizeResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 result = 1; */
    if (message.result !== undefined) writer.tag(1, WireType.Varint).uint32(message.result);
    /* repeated uint64 item_ids = 2; */
    for (let i = 0; i < message.item_ids.length; i++) writer.tag(2, WireType.Varint).uint64(message.item_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCStorePurchaseFinalizeResponse
 */
export const CMsgGCStorePurchaseFinalizeResponse = new CMsgGCStorePurchaseFinalizeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCBannedWordListUpdated$Type extends MessageType<CMsgGCToGCBannedWordListUpdated> {
  constructor() {
    super("CMsgGCToGCBannedWordListUpdated", [
      {
        no: 1,
        name: "group_id",
        kind: "scalar",
        localName: "group_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCBannedWordListUpdated>): CMsgGCToGCBannedWordListUpdated {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCBannedWordListUpdated>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCBannedWordListUpdated,
  ): CMsgGCToGCBannedWordListUpdated {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 group_id */ 1:
          message.group_id = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCBannedWordListUpdated,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 group_id = 1; */
    if (message.group_id !== undefined) writer.tag(1, WireType.Varint).uint32(message.group_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCBannedWordListUpdated
 */
export const CMsgGCToGCBannedWordListUpdated = new CMsgGCToGCBannedWordListUpdated$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCDirtySDOCache$Type extends MessageType<CMsgGCToGCDirtySDOCache> {
  constructor() {
    super("CMsgGCToGCDirtySDOCache", [
      {
        no: 1,
        name: "sdo_type",
        kind: "scalar",
        localName: "sdo_type",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "key_uint64",
        kind: "scalar",
        localName: "key_uint64",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCDirtySDOCache>): CMsgGCToGCDirtySDOCache {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCDirtySDOCache>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCDirtySDOCache,
  ): CMsgGCToGCDirtySDOCache {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 sdo_type */ 1:
          message.sdo_type = reader.uint32();
          break;
        case /* optional uint64 key_uint64 */ 2:
          message.key_uint64 = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCDirtySDOCache,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 sdo_type = 1; */
    if (message.sdo_type !== undefined) writer.tag(1, WireType.Varint).uint32(message.sdo_type);
    /* optional uint64 key_uint64 = 2; */
    if (message.key_uint64 !== undefined) writer.tag(2, WireType.Varint).uint64(message.key_uint64);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCDirtySDOCache
 */
export const CMsgGCToGCDirtySDOCache = new CMsgGCToGCDirtySDOCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSDONoMemcached$Type extends MessageType<CMsgSDONoMemcached> {
  constructor() {
    super("CMsgSDONoMemcached", []);
  }
  create(value?: PartialMessage<CMsgSDONoMemcached>): CMsgSDONoMemcached {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSDONoMemcached>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSDONoMemcached,
  ): CMsgSDONoMemcached {
    return target ?? this.create();
  }
  internalBinaryWrite(message: CMsgSDONoMemcached, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSDONoMemcached
 */
export const CMsgSDONoMemcached = new CMsgSDONoMemcached$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCUpdateSQLKeyValue$Type extends MessageType<CMsgGCToGCUpdateSQLKeyValue> {
  constructor() {
    super("CMsgGCToGCUpdateSQLKeyValue", [
      {
        no: 1,
        name: "key_name",
        kind: "scalar",
        localName: "key_name",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCUpdateSQLKeyValue>): CMsgGCToGCUpdateSQLKeyValue {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCUpdateSQLKeyValue>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCUpdateSQLKeyValue,
  ): CMsgGCToGCUpdateSQLKeyValue {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string key_name */ 1:
          message.key_name = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCUpdateSQLKeyValue,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string key_name = 1; */
    if (message.key_name !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.key_name);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCUpdateSQLKeyValue
 */
export const CMsgGCToGCUpdateSQLKeyValue = new CMsgGCToGCUpdateSQLKeyValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCServerVersionUpdated$Type extends MessageType<CMsgGCServerVersionUpdated> {
  constructor() {
    super("CMsgGCServerVersionUpdated", [
      {
        no: 1,
        name: "server_version",
        kind: "scalar",
        localName: "server_version",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCServerVersionUpdated>): CMsgGCServerVersionUpdated {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCServerVersionUpdated>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCServerVersionUpdated,
  ): CMsgGCServerVersionUpdated {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 server_version */ 1:
          message.server_version = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCServerVersionUpdated,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 server_version = 1; */
    if (message.server_version !== undefined) writer.tag(1, WireType.Varint).uint32(message.server_version);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCServerVersionUpdated
 */
export const CMsgGCServerVersionUpdated = new CMsgGCServerVersionUpdated$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCClientVersionUpdated$Type extends MessageType<CMsgGCClientVersionUpdated> {
  constructor() {
    super("CMsgGCClientVersionUpdated", [
      {
        no: 1,
        name: "client_version",
        kind: "scalar",
        localName: "client_version",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCClientVersionUpdated>): CMsgGCClientVersionUpdated {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCClientVersionUpdated>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCClientVersionUpdated,
  ): CMsgGCClientVersionUpdated {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 client_version */ 1:
          message.client_version = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCClientVersionUpdated,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 client_version = 1; */
    if (message.client_version !== undefined) writer.tag(1, WireType.Varint).uint32(message.client_version);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCClientVersionUpdated
 */
export const CMsgGCClientVersionUpdated = new CMsgGCClientVersionUpdated$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCWebAPIAccountChanged$Type extends MessageType<CMsgGCToGCWebAPIAccountChanged> {
  constructor() {
    super("CMsgGCToGCWebAPIAccountChanged", []);
  }
  create(value?: PartialMessage<CMsgGCToGCWebAPIAccountChanged>): CMsgGCToGCWebAPIAccountChanged {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCWebAPIAccountChanged>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCWebAPIAccountChanged,
  ): CMsgGCToGCWebAPIAccountChanged {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CMsgGCToGCWebAPIAccountChanged,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCWebAPIAccountChanged
 */
export const CMsgGCToGCWebAPIAccountChanged = new CMsgGCToGCWebAPIAccountChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgExtractGems$Type extends MessageType<CMsgExtractGems> {
  constructor() {
    super("CMsgExtractGems", [
      {
        no: 1,
        name: "tool_item_id",
        kind: "scalar",
        localName: "tool_item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "item_item_id",
        kind: "scalar",
        localName: "item_item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "item_socket_id",
        kind: "scalar",
        localName: "item_socket_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgExtractGems>): CMsgExtractGems {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgExtractGems>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgExtractGems,
  ): CMsgExtractGems {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 tool_item_id */ 1:
          message.tool_item_id = reader.uint64().toBigInt();
          break;
        case /* optional uint64 item_item_id */ 2:
          message.item_item_id = reader.uint64().toBigInt();
          break;
        case /* optional uint32 item_socket_id */ 3:
          message.item_socket_id = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgExtractGems, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional uint64 tool_item_id = 1; */
    if (message.tool_item_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.tool_item_id);
    /* optional uint64 item_item_id = 2; */
    if (message.item_item_id !== undefined) writer.tag(2, WireType.Varint).uint64(message.item_item_id);
    /* optional uint32 item_socket_id = 3; */
    if (message.item_socket_id !== undefined) writer.tag(3, WireType.Varint).uint32(message.item_socket_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgExtractGems
 */
export const CMsgExtractGems = new CMsgExtractGems$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgExtractGemsResponse$Type extends MessageType<CMsgExtractGemsResponse> {
  constructor() {
    super("CMsgExtractGemsResponse", [
      {
        no: 1,
        name: "item_id",
        kind: "scalar",
        localName: "item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "response",
        kind: "enum",
        opt: true,
        T: () => ["CMsgExtractGemsResponse.EExtractGems", CMsgExtractGemsResponse_EExtractGems],
      },
    ]);
  }
  create(value?: PartialMessage<CMsgExtractGemsResponse>): CMsgExtractGemsResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgExtractGemsResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgExtractGemsResponse,
  ): CMsgExtractGemsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 item_id */ 1:
          message.item_id = reader.uint64().toBigInt();
          break;
        case /* optional CMsgExtractGemsResponse.EExtractGems response */ 2:
          message.response = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgExtractGemsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 item_id = 1; */
    if (message.item_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.item_id);
    /* optional CMsgExtractGemsResponse.EExtractGems response = 2; */
    if (message.response !== undefined) writer.tag(2, WireType.Varint).int32(message.response);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgExtractGemsResponse
 */
export const CMsgExtractGemsResponse = new CMsgExtractGemsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAddSocket$Type extends MessageType<CMsgAddSocket> {
  constructor() {
    super("CMsgAddSocket", [
      {
        no: 1,
        name: "tool_item_id",
        kind: "scalar",
        localName: "tool_item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "item_item_id",
        kind: "scalar",
        localName: "item_item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "unusual",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgAddSocket>): CMsgAddSocket {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgAddSocket>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgAddSocket,
  ): CMsgAddSocket {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 tool_item_id */ 1:
          message.tool_item_id = reader.uint64().toBigInt();
          break;
        case /* optional uint64 item_item_id */ 2:
          message.item_item_id = reader.uint64().toBigInt();
          break;
        case /* optional bool unusual */ 3:
          message.unusual = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgAddSocket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional uint64 tool_item_id = 1; */
    if (message.tool_item_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.tool_item_id);
    /* optional uint64 item_item_id = 2; */
    if (message.item_item_id !== undefined) writer.tag(2, WireType.Varint).uint64(message.item_item_id);
    /* optional bool unusual = 3; */
    if (message.unusual !== undefined) writer.tag(3, WireType.Varint).bool(message.unusual);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgAddSocket
 */
export const CMsgAddSocket = new CMsgAddSocket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAddSocketResponse$Type extends MessageType<CMsgAddSocketResponse> {
  constructor() {
    super("CMsgAddSocketResponse", [
      {
        no: 1,
        name: "item_id",
        kind: "scalar",
        localName: "item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "updated_socket_index",
        kind: "scalar",
        localName: "updated_socket_index",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "response",
        kind: "enum",
        opt: true,
        T: () => ["CMsgAddSocketResponse.EAddSocket", CMsgAddSocketResponse_EAddSocket],
      },
    ]);
  }
  create(value?: PartialMessage<CMsgAddSocketResponse>): CMsgAddSocketResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.updated_socket_index = [];
    if (value !== undefined) reflectionMergePartial<CMsgAddSocketResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgAddSocketResponse,
  ): CMsgAddSocketResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 item_id */ 1:
          message.item_id = reader.uint64().toBigInt();
          break;
        case /* repeated uint32 updated_socket_index */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.updated_socket_index.push(reader.uint32());
          else message.updated_socket_index.push(reader.uint32());
          break;
        case /* optional CMsgAddSocketResponse.EAddSocket response */ 3:
          message.response = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgAddSocketResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 item_id = 1; */
    if (message.item_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.item_id);
    /* repeated uint32 updated_socket_index = 2; */
    for (let i = 0; i < message.updated_socket_index.length; i++)
      writer.tag(2, WireType.Varint).uint32(message.updated_socket_index[i]);
    /* optional CMsgAddSocketResponse.EAddSocket response = 3; */
    if (message.response !== undefined) writer.tag(3, WireType.Varint).int32(message.response);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgAddSocketResponse
 */
export const CMsgAddSocketResponse = new CMsgAddSocketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAddItemToSocketData$Type extends MessageType<CMsgAddItemToSocketData> {
  constructor() {
    super("CMsgAddItemToSocketData", [
      {
        no: 1,
        name: "gem_item_id",
        kind: "scalar",
        localName: "gem_item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "socket_index",
        kind: "scalar",
        localName: "socket_index",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgAddItemToSocketData>): CMsgAddItemToSocketData {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgAddItemToSocketData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgAddItemToSocketData,
  ): CMsgAddItemToSocketData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 gem_item_id */ 1:
          message.gem_item_id = reader.uint64().toBigInt();
          break;
        case /* optional uint32 socket_index */ 2:
          message.socket_index = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgAddItemToSocketData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 gem_item_id = 1; */
    if (message.gem_item_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.gem_item_id);
    /* optional uint32 socket_index = 2; */
    if (message.socket_index !== undefined) writer.tag(2, WireType.Varint).uint32(message.socket_index);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgAddItemToSocketData
 */
export const CMsgAddItemToSocketData = new CMsgAddItemToSocketData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAddItemToSocket$Type extends MessageType<CMsgAddItemToSocket> {
  constructor() {
    super("CMsgAddItemToSocket", [
      {
        no: 1,
        name: "item_item_id",
        kind: "scalar",
        localName: "item_item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "gems_to_socket",
        kind: "message",
        localName: "gems_to_socket",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgAddItemToSocketData,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgAddItemToSocket>): CMsgAddItemToSocket {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.gems_to_socket = [];
    if (value !== undefined) reflectionMergePartial<CMsgAddItemToSocket>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgAddItemToSocket,
  ): CMsgAddItemToSocket {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 item_item_id */ 1:
          message.item_item_id = reader.uint64().toBigInt();
          break;
        case /* repeated CMsgAddItemToSocketData gems_to_socket */ 2:
          message.gems_to_socket.push(CMsgAddItemToSocketData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgAddItemToSocket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional uint64 item_item_id = 1; */
    if (message.item_item_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.item_item_id);
    /* repeated CMsgAddItemToSocketData gems_to_socket = 2; */
    for (let i = 0; i < message.gems_to_socket.length; i++)
      CMsgAddItemToSocketData.internalBinaryWrite(
        message.gems_to_socket[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgAddItemToSocket
 */
export const CMsgAddItemToSocket = new CMsgAddItemToSocket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAddItemToSocketResponse$Type extends MessageType<CMsgAddItemToSocketResponse> {
  constructor() {
    super("CMsgAddItemToSocketResponse", [
      {
        no: 1,
        name: "item_item_id",
        kind: "scalar",
        localName: "item_item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "updated_socket_index",
        kind: "scalar",
        localName: "updated_socket_index",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "response",
        kind: "enum",
        opt: true,
        T: () => ["CMsgAddItemToSocketResponse.EAddGem", CMsgAddItemToSocketResponse_EAddGem],
      },
    ]);
  }
  create(value?: PartialMessage<CMsgAddItemToSocketResponse>): CMsgAddItemToSocketResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.updated_socket_index = [];
    if (value !== undefined) reflectionMergePartial<CMsgAddItemToSocketResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgAddItemToSocketResponse,
  ): CMsgAddItemToSocketResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 item_item_id */ 1:
          message.item_item_id = reader.uint64().toBigInt();
          break;
        case /* repeated uint32 updated_socket_index */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.updated_socket_index.push(reader.uint32());
          else message.updated_socket_index.push(reader.uint32());
          break;
        case /* optional CMsgAddItemToSocketResponse.EAddGem response */ 3:
          message.response = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgAddItemToSocketResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 item_item_id = 1; */
    if (message.item_item_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.item_item_id);
    /* repeated uint32 updated_socket_index = 2; */
    for (let i = 0; i < message.updated_socket_index.length; i++)
      writer.tag(2, WireType.Varint).uint32(message.updated_socket_index[i]);
    /* optional CMsgAddItemToSocketResponse.EAddGem response = 3; */
    if (message.response !== undefined) writer.tag(3, WireType.Varint).int32(message.response);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgAddItemToSocketResponse
 */
export const CMsgAddItemToSocketResponse = new CMsgAddItemToSocketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgResetStrangeGemCount$Type extends MessageType<CMsgResetStrangeGemCount> {
  constructor() {
    super("CMsgResetStrangeGemCount", [
      {
        no: 1,
        name: "item_item_id",
        kind: "scalar",
        localName: "item_item_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "socket_index",
        kind: "scalar",
        localName: "socket_index",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgResetStrangeGemCount>): CMsgResetStrangeGemCount {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgResetStrangeGemCount>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgResetStrangeGemCount,
  ): CMsgResetStrangeGemCount {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 item_item_id */ 1:
          message.item_item_id = reader.uint64().toBigInt();
          break;
        case /* optional uint32 socket_index */ 2:
          message.socket_index = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgResetStrangeGemCount,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 item_item_id = 1; */
    if (message.item_item_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.item_item_id);
    /* optional uint32 socket_index = 2; */
    if (message.socket_index !== undefined) writer.tag(2, WireType.Varint).uint32(message.socket_index);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgResetStrangeGemCount
 */
export const CMsgResetStrangeGemCount = new CMsgResetStrangeGemCount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgResetStrangeGemCountResponse$Type extends MessageType<CMsgResetStrangeGemCountResponse> {
  constructor() {
    super("CMsgResetStrangeGemCountResponse", [
      {
        no: 1,
        name: "response",
        kind: "enum",
        opt: true,
        T: () => ["CMsgResetStrangeGemCountResponse.EResetGem", CMsgResetStrangeGemCountResponse_EResetGem],
      },
    ]);
  }
  create(value?: PartialMessage<CMsgResetStrangeGemCountResponse>): CMsgResetStrangeGemCountResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgResetStrangeGemCountResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgResetStrangeGemCountResponse,
  ): CMsgResetStrangeGemCountResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgResetStrangeGemCountResponse.EResetGem response */ 1:
          message.response = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgResetStrangeGemCountResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgResetStrangeGemCountResponse.EResetGem response = 1; */
    if (message.response !== undefined) writer.tag(1, WireType.Varint).int32(message.response);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgResetStrangeGemCountResponse
 */
export const CMsgResetStrangeGemCountResponse = new CMsgResetStrangeGemCountResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToClientPollFileRequest$Type extends MessageType<CMsgGCToClientPollFileRequest> {
  constructor() {
    super("CMsgGCToClientPollFileRequest", [
      {
        no: 1,
        name: "file_name",
        kind: "scalar",
        localName: "file_name",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "client_version",
        kind: "scalar",
        localName: "client_version",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "poll_id",
        kind: "scalar",
        localName: "poll_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToClientPollFileRequest>): CMsgGCToClientPollFileRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToClientPollFileRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToClientPollFileRequest,
  ): CMsgGCToClientPollFileRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string file_name */ 1:
          message.file_name = reader.string();
          break;
        case /* optional uint32 client_version */ 2:
          message.client_version = reader.uint32();
          break;
        case /* optional uint32 poll_id */ 3:
          message.poll_id = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToClientPollFileRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string file_name = 1; */
    if (message.file_name !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.file_name);
    /* optional uint32 client_version = 2; */
    if (message.client_version !== undefined) writer.tag(2, WireType.Varint).uint32(message.client_version);
    /* optional uint32 poll_id = 3; */
    if (message.poll_id !== undefined) writer.tag(3, WireType.Varint).uint32(message.poll_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToClientPollFileRequest
 */
export const CMsgGCToClientPollFileRequest = new CMsgGCToClientPollFileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToClientPollFileResponse$Type extends MessageType<CMsgGCToClientPollFileResponse> {
  constructor() {
    super("CMsgGCToClientPollFileResponse", [
      {
        no: 1,
        name: "poll_id",
        kind: "scalar",
        localName: "poll_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "file_size",
        kind: "scalar",
        localName: "file_size",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "file_crc",
        kind: "scalar",
        localName: "file_crc",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToClientPollFileResponse>): CMsgGCToClientPollFileResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToClientPollFileResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToClientPollFileResponse,
  ): CMsgGCToClientPollFileResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 poll_id */ 1:
          message.poll_id = reader.uint32();
          break;
        case /* optional uint32 file_size */ 2:
          message.file_size = reader.uint32();
          break;
        case /* optional uint32 file_crc */ 3:
          message.file_crc = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToClientPollFileResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 poll_id = 1; */
    if (message.poll_id !== undefined) writer.tag(1, WireType.Varint).uint32(message.poll_id);
    /* optional uint32 file_size = 2; */
    if (message.file_size !== undefined) writer.tag(2, WireType.Varint).uint32(message.file_size);
    /* optional uint32 file_crc = 3; */
    if (message.file_crc !== undefined) writer.tag(3, WireType.Varint).uint32(message.file_crc);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToClientPollFileResponse
 */
export const CMsgGCToClientPollFileResponse = new CMsgGCToClientPollFileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCPerformManualOp$Type extends MessageType<CMsgGCToGCPerformManualOp> {
  constructor() {
    super("CMsgGCToGCPerformManualOp", [
      {
        no: 1,
        name: "op_id",
        kind: "scalar",
        localName: "op_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "group_code",
        kind: "scalar",
        localName: "group_code",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCPerformManualOp>): CMsgGCToGCPerformManualOp {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCPerformManualOp>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCPerformManualOp,
  ): CMsgGCToGCPerformManualOp {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 op_id */ 1:
          message.op_id = reader.uint64().toBigInt();
          break;
        case /* optional uint32 group_code */ 2:
          message.group_code = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCPerformManualOp,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 op_id = 1; */
    if (message.op_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.op_id);
    /* optional uint32 group_code = 2; */
    if (message.group_code !== undefined) writer.tag(2, WireType.Varint).uint32(message.group_code);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCPerformManualOp
 */
export const CMsgGCToGCPerformManualOp = new CMsgGCToGCPerformManualOp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCPerformManualOpCompleted$Type extends MessageType<CMsgGCToGCPerformManualOpCompleted> {
  constructor() {
    super("CMsgGCToGCPerformManualOpCompleted", [
      {
        no: 1,
        name: "success",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 2,
        name: "source_gc",
        kind: "scalar",
        localName: "source_gc",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCPerformManualOpCompleted>): CMsgGCToGCPerformManualOpCompleted {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCPerformManualOpCompleted>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCPerformManualOpCompleted,
  ): CMsgGCToGCPerformManualOpCompleted {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bool success */ 1:
          message.success = reader.bool();
          break;
        case /* optional int32 source_gc */ 2:
          message.source_gc = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCPerformManualOpCompleted,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional bool success = 1; */
    if (message.success !== undefined) writer.tag(1, WireType.Varint).bool(message.success);
    /* optional int32 source_gc = 2; */
    if (message.source_gc !== undefined) writer.tag(2, WireType.Varint).int32(message.source_gc);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCPerformManualOpCompleted
 */
export const CMsgGCToGCPerformManualOpCompleted = new CMsgGCToGCPerformManualOpCompleted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCReloadServerRegionSettings$Type extends MessageType<CMsgGCToGCReloadServerRegionSettings> {
  constructor() {
    super("CMsgGCToGCReloadServerRegionSettings", []);
  }
  create(value?: PartialMessage<CMsgGCToGCReloadServerRegionSettings>): CMsgGCToGCReloadServerRegionSettings {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCReloadServerRegionSettings>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCReloadServerRegionSettings,
  ): CMsgGCToGCReloadServerRegionSettings {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CMsgGCToGCReloadServerRegionSettings,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCReloadServerRegionSettings
 */
export const CMsgGCToGCReloadServerRegionSettings = new CMsgGCToGCReloadServerRegionSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCAdditionalWelcomeMsgList$Type extends MessageType<CMsgGCAdditionalWelcomeMsgList> {
  constructor() {
    super("CMsgGCAdditionalWelcomeMsgList", [
      {
        no: 1,
        name: "welcome_messages",
        kind: "message",
        localName: "welcome_messages",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CExtraMsgBlock,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCAdditionalWelcomeMsgList>): CMsgGCAdditionalWelcomeMsgList {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.welcome_messages = [];
    if (value !== undefined) reflectionMergePartial<CMsgGCAdditionalWelcomeMsgList>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCAdditionalWelcomeMsgList,
  ): CMsgGCAdditionalWelcomeMsgList {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CExtraMsgBlock welcome_messages */ 1:
          message.welcome_messages.push(CExtraMsgBlock.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCAdditionalWelcomeMsgList,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CExtraMsgBlock welcome_messages = 1; */
    for (let i = 0; i < message.welcome_messages.length; i++)
      CExtraMsgBlock.internalBinaryWrite(
        message.welcome_messages[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCAdditionalWelcomeMsgList
 */
export const CMsgGCAdditionalWelcomeMsgList = new CMsgGCAdditionalWelcomeMsgList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgApplyRemoteConVars$Type extends MessageType<CMsgApplyRemoteConVars> {
  constructor() {
    super("CMsgApplyRemoteConVars", [
      {
        no: 1,
        name: "con_vars",
        kind: "message",
        localName: "con_vars",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgApplyRemoteConVars_ConVar,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgApplyRemoteConVars>): CMsgApplyRemoteConVars {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.con_vars = [];
    if (value !== undefined) reflectionMergePartial<CMsgApplyRemoteConVars>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgApplyRemoteConVars,
  ): CMsgApplyRemoteConVars {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CMsgApplyRemoteConVars.ConVar con_vars */ 1:
          message.con_vars.push(CMsgApplyRemoteConVars_ConVar.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgApplyRemoteConVars,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CMsgApplyRemoteConVars.ConVar con_vars = 1; */
    for (let i = 0; i < message.con_vars.length; i++)
      CMsgApplyRemoteConVars_ConVar.internalBinaryWrite(
        message.con_vars[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgApplyRemoteConVars
 */
export const CMsgApplyRemoteConVars = new CMsgApplyRemoteConVars$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgApplyRemoteConVars_ConVar$Type extends MessageType<CMsgApplyRemoteConVars_ConVar> {
  constructor() {
    super("CMsgApplyRemoteConVars.ConVar", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "value",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: "version_min",
        kind: "scalar",
        localName: "version_min",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "version_max",
        kind: "scalar",
        localName: "version_max",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "platform",
        kind: "enum",
        opt: true,
        T: () => ["EGCPlatform", EGCPlatform],
      },
    ]);
  }
  create(value?: PartialMessage<CMsgApplyRemoteConVars_ConVar>): CMsgApplyRemoteConVars_ConVar {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgApplyRemoteConVars_ConVar>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgApplyRemoteConVars_ConVar,
  ): CMsgApplyRemoteConVars_ConVar {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string name */ 1:
          message.name = reader.string();
          break;
        case /* optional string value */ 2:
          message.value = reader.string();
          break;
        case /* optional uint32 version_min */ 3:
          message.version_min = reader.uint32();
          break;
        case /* optional uint32 version_max */ 4:
          message.version_max = reader.uint32();
          break;
        case /* optional EGCPlatform platform */ 5:
          message.platform = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgApplyRemoteConVars_ConVar,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string name = 1; */
    if (message.name !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* optional string value = 2; */
    if (message.value !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.value);
    /* optional uint32 version_min = 3; */
    if (message.version_min !== undefined) writer.tag(3, WireType.Varint).uint32(message.version_min);
    /* optional uint32 version_max = 4; */
    if (message.version_max !== undefined) writer.tag(4, WireType.Varint).uint32(message.version_max);
    /* optional EGCPlatform platform = 5; */
    if (message.platform !== undefined) writer.tag(5, WireType.Varint).int32(message.platform);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgApplyRemoteConVars.ConVar
 */
export const CMsgApplyRemoteConVars_ConVar = new CMsgApplyRemoteConVars_ConVar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToClientApplyRemoteConVars$Type extends MessageType<CMsgGCToClientApplyRemoteConVars> {
  constructor() {
    super("CMsgGCToClientApplyRemoteConVars", [
      { no: 1, name: "msg", kind: "message", T: () => CMsgApplyRemoteConVars },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToClientApplyRemoteConVars>): CMsgGCToClientApplyRemoteConVars {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToClientApplyRemoteConVars>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToClientApplyRemoteConVars,
  ): CMsgGCToClientApplyRemoteConVars {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgApplyRemoteConVars msg */ 1:
          message.msg = CMsgApplyRemoteConVars.internalBinaryRead(reader, reader.uint32(), options, message.msg);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToClientApplyRemoteConVars,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgApplyRemoteConVars msg = 1; */
    if (message.msg)
      CMsgApplyRemoteConVars.internalBinaryWrite(
        message.msg,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToClientApplyRemoteConVars
 */
export const CMsgGCToClientApplyRemoteConVars = new CMsgGCToClientApplyRemoteConVars$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToServerApplyRemoteConVars$Type extends MessageType<CMsgGCToServerApplyRemoteConVars> {
  constructor() {
    super("CMsgGCToServerApplyRemoteConVars", [
      { no: 1, name: "msg", kind: "message", T: () => CMsgApplyRemoteConVars },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToServerApplyRemoteConVars>): CMsgGCToServerApplyRemoteConVars {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToServerApplyRemoteConVars>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToServerApplyRemoteConVars,
  ): CMsgGCToServerApplyRemoteConVars {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgApplyRemoteConVars msg */ 1:
          message.msg = CMsgApplyRemoteConVars.internalBinaryRead(reader, reader.uint32(), options, message.msg);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToServerApplyRemoteConVars,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgApplyRemoteConVars msg = 1; */
    if (message.msg)
      CMsgApplyRemoteConVars.internalBinaryWrite(
        message.msg,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToServerApplyRemoteConVars
 */
export const CMsgGCToServerApplyRemoteConVars = new CMsgGCToServerApplyRemoteConVars$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientToGCIntegrityStatus$Type extends MessageType<CMsgClientToGCIntegrityStatus> {
  constructor() {
    super("CMsgClientToGCIntegrityStatus", [
      {
        no: 1,
        name: "report",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "secure_allowed",
        kind: "scalar",
        localName: "secure_allowed",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 3,
        name: "diagnostics",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgClientToGCIntegrityStatus_keyvalue,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgClientToGCIntegrityStatus>): CMsgClientToGCIntegrityStatus {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.diagnostics = [];
    if (value !== undefined) reflectionMergePartial<CMsgClientToGCIntegrityStatus>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgClientToGCIntegrityStatus,
  ): CMsgClientToGCIntegrityStatus {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string report */ 1:
          message.report = reader.string();
          break;
        case /* optional bool secure_allowed */ 2:
          message.secure_allowed = reader.bool();
          break;
        case /* repeated CMsgClientToGCIntegrityStatus.keyvalue diagnostics */ 3:
          message.diagnostics.push(
            CMsgClientToGCIntegrityStatus_keyvalue.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgClientToGCIntegrityStatus,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string report = 1; */
    if (message.report !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.report);
    /* optional bool secure_allowed = 2; */
    if (message.secure_allowed !== undefined) writer.tag(2, WireType.Varint).bool(message.secure_allowed);
    /* repeated CMsgClientToGCIntegrityStatus.keyvalue diagnostics = 3; */
    for (let i = 0; i < message.diagnostics.length; i++)
      CMsgClientToGCIntegrityStatus_keyvalue.internalBinaryWrite(
        message.diagnostics[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgClientToGCIntegrityStatus
 */
export const CMsgClientToGCIntegrityStatus = new CMsgClientToGCIntegrityStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientToGCIntegrityStatus_keyvalue$Type extends MessageType<CMsgClientToGCIntegrityStatus_keyvalue> {
  constructor() {
    super("CMsgClientToGCIntegrityStatus.keyvalue", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "extended",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "value",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 4,
        name: "string_value",
        kind: "scalar",
        localName: "string_value",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgClientToGCIntegrityStatus_keyvalue>): CMsgClientToGCIntegrityStatus_keyvalue {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgClientToGCIntegrityStatus_keyvalue>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgClientToGCIntegrityStatus_keyvalue,
  ): CMsgClientToGCIntegrityStatus_keyvalue {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 id */ 1:
          message.id = reader.uint32();
          break;
        case /* optional uint32 extended */ 2:
          message.extended = reader.uint32();
          break;
        case /* optional uint64 value */ 3:
          message.value = reader.uint64().toBigInt();
          break;
        case /* optional string string_value */ 4:
          message.string_value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgClientToGCIntegrityStatus_keyvalue,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 id = 1; */
    if (message.id !== undefined) writer.tag(1, WireType.Varint).uint32(message.id);
    /* optional uint32 extended = 2; */
    if (message.extended !== undefined) writer.tag(2, WireType.Varint).uint32(message.extended);
    /* optional uint64 value = 3; */
    if (message.value !== undefined) writer.tag(3, WireType.Varint).uint64(message.value);
    /* optional string string_value = 4; */
    if (message.string_value !== undefined) writer.tag(4, WireType.LengthDelimited).string(message.string_value);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgClientToGCIntegrityStatus.keyvalue
 */
export const CMsgClientToGCIntegrityStatus_keyvalue = new CMsgClientToGCIntegrityStatus_keyvalue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientToGCAggregateMetrics$Type extends MessageType<CMsgClientToGCAggregateMetrics> {
  constructor() {
    super("CMsgClientToGCAggregateMetrics", [
      {
        no: 1,
        name: "metrics",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgClientToGCAggregateMetrics_SingleMetric,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgClientToGCAggregateMetrics>): CMsgClientToGCAggregateMetrics {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.metrics = [];
    if (value !== undefined) reflectionMergePartial<CMsgClientToGCAggregateMetrics>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgClientToGCAggregateMetrics,
  ): CMsgClientToGCAggregateMetrics {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CMsgClientToGCAggregateMetrics.SingleMetric metrics */ 1:
          message.metrics.push(
            CMsgClientToGCAggregateMetrics_SingleMetric.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgClientToGCAggregateMetrics,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CMsgClientToGCAggregateMetrics.SingleMetric metrics = 1; */
    for (let i = 0; i < message.metrics.length; i++)
      CMsgClientToGCAggregateMetrics_SingleMetric.internalBinaryWrite(
        message.metrics[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgClientToGCAggregateMetrics
 */
export const CMsgClientToGCAggregateMetrics = new CMsgClientToGCAggregateMetrics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientToGCAggregateMetrics_SingleMetric$Type extends MessageType<CMsgClientToGCAggregateMetrics_SingleMetric> {
  constructor() {
    super("CMsgClientToGCAggregateMetrics.SingleMetric", [
      {
        no: 1,
        name: "metric_name",
        kind: "scalar",
        localName: "metric_name",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "metric_count",
        kind: "scalar",
        localName: "metric_count",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgClientToGCAggregateMetrics_SingleMetric>,
  ): CMsgClientToGCAggregateMetrics_SingleMetric {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgClientToGCAggregateMetrics_SingleMetric>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgClientToGCAggregateMetrics_SingleMetric,
  ): CMsgClientToGCAggregateMetrics_SingleMetric {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string metric_name */ 1:
          message.metric_name = reader.string();
          break;
        case /* optional uint32 metric_count */ 2:
          message.metric_count = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgClientToGCAggregateMetrics_SingleMetric,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string metric_name = 1; */
    if (message.metric_name !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.metric_name);
    /* optional uint32 metric_count = 2; */
    if (message.metric_count !== undefined) writer.tag(2, WireType.Varint).uint32(message.metric_count);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgClientToGCAggregateMetrics.SingleMetric
 */
export const CMsgClientToGCAggregateMetrics_SingleMetric = new CMsgClientToGCAggregateMetrics_SingleMetric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToClientAggregateMetricsBackoff$Type extends MessageType<CMsgGCToClientAggregateMetricsBackoff> {
  constructor() {
    super("CMsgGCToClientAggregateMetricsBackoff", [
      {
        no: 1,
        name: "upload_rate_modifier",
        kind: "scalar",
        localName: "upload_rate_modifier",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToClientAggregateMetricsBackoff>): CMsgGCToClientAggregateMetricsBackoff {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToClientAggregateMetricsBackoff>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToClientAggregateMetricsBackoff,
  ): CMsgGCToClientAggregateMetricsBackoff {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional float upload_rate_modifier */ 1:
          message.upload_rate_modifier = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToClientAggregateMetricsBackoff,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional float upload_rate_modifier = 1; */
    if (message.upload_rate_modifier !== undefined) writer.tag(1, WireType.Bit32).float(message.upload_rate_modifier);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToClientAggregateMetricsBackoff
 */
export const CMsgGCToClientAggregateMetricsBackoff = new CMsgGCToClientAggregateMetricsBackoff$Type();

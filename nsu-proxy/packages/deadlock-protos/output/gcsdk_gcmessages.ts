// @generated by protobuf-ts 2.9.4 with parameter use_proto_field_name
// @generated from protobuf file "gcsdk_gcmessages.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CGCSystemMsg_GetAccountDetails_Response } from "./steammessages.js";
import { CMsgSteamLearnAccessTokens } from "./steammessages_steamlearn.steamworkssdk.js";
/**
 * @generated from protobuf message CExtraMsgBlock
 */
export interface CExtraMsgBlock {
  /**
   * @generated from protobuf field: optional uint32 msg_type = 1;
   */
  msg_type?: number;
  /**
   * @generated from protobuf field: optional bytes contents = 2;
   */
  contents?: Uint8Array;
  /**
   * @generated from protobuf field: optional uint64 msg_key = 3;
   */
  msg_key?: bigint;
  /**
   * @generated from protobuf field: optional bool is_compressed = 4;
   */
  is_compressed?: boolean;
}
/**
 * @generated from protobuf message CMsgSteamLearnServerInfo
 */
export interface CMsgSteamLearnServerInfo {
  /**
   * @generated from protobuf field: optional CMsgSteamLearnAccessTokens access_tokens = 4;
   */
  access_tokens?: CMsgSteamLearnAccessTokens;
  /**
   * @generated from protobuf field: repeated CMsgSteamLearnServerInfo.ProjectInfo project_infos = 5;
   */
  project_infos: CMsgSteamLearnServerInfo_ProjectInfo[];
}
/**
 * @generated from protobuf message CMsgSteamLearnServerInfo.ProjectInfo
 */
export interface CMsgSteamLearnServerInfo_ProjectInfo {
  /**
   * @generated from protobuf field: optional uint32 project_id = 1;
   */
  project_id?: number;
  /**
   * @generated from protobuf field: optional uint32 snapshot_published_version = 2;
   */
  snapshot_published_version?: number;
  /**
   * @generated from protobuf field: optional uint32 inference_published_version = 3;
   */
  inference_published_version?: number;
  /**
   * @generated from protobuf field: optional uint32 snapshot_percentage = 6;
   */
  snapshot_percentage?: number;
  /**
   * @generated from protobuf field: optional bool snapshot_enabled = 7;
   */
  snapshot_enabled?: boolean;
}
/**
 * @generated from protobuf message CMsgGCAssertJobData
 */
export interface CMsgGCAssertJobData {
  /**
   * @generated from protobuf field: optional string message_type = 1;
   */
  message_type?: string;
  /**
   * @generated from protobuf field: optional bytes message_data = 2;
   */
  message_data?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgGCConCommand
 */
export interface CMsgGCConCommand {
  /**
   * @generated from protobuf field: optional string command = 1;
   */
  command?: string;
}
/**
 * @generated from protobuf message CMsgSDOAssert
 */
export interface CMsgSDOAssert {
  /**
   * @generated from protobuf field: optional int32 sdo_type = 1;
   */
  sdo_type?: number;
  /**
   * @generated from protobuf field: repeated CMsgSDOAssert.Request requests = 2;
   */
  requests: CMsgSDOAssert_Request[];
}
/**
 * @generated from protobuf message CMsgSDOAssert.Request
 */
export interface CMsgSDOAssert_Request {
  /**
   * @generated from protobuf field: repeated uint64 key = 1;
   */
  key: bigint[];
  /**
   * @generated from protobuf field: optional string requesting_job = 2;
   */
  requesting_job?: string;
}
/**
 * @generated from protobuf message CMsgSOIDOwner
 */
export interface CMsgSOIDOwner {
  /**
   * @generated from protobuf field: optional uint32 type = 1;
   */
  type?: number;
  /**
   * @generated from protobuf field: optional uint64 id = 2;
   */
  id?: bigint;
}
/**
 * @generated from protobuf message CMsgSOSingleObject
 */
export interface CMsgSOSingleObject {
  /**
   * @generated from protobuf field: optional int32 type_id = 2;
   */
  type_id?: number;
  /**
   * @generated from protobuf field: optional bytes object_data = 3;
   */
  object_data?: Uint8Array;
  /**
   * @generated from protobuf field: optional fixed64 version = 4;
   */
  version?: bigint;
  /**
   * @generated from protobuf field: optional CMsgSOIDOwner owner_soid = 5;
   */
  owner_soid?: CMsgSOIDOwner;
  /**
   * @generated from protobuf field: optional uint32 service_id = 6;
   */
  service_id?: number;
}
/**
 * @generated from protobuf message CMsgSOMultipleObjects
 */
export interface CMsgSOMultipleObjects {
  /**
   * @generated from protobuf field: repeated CMsgSOMultipleObjects.SingleObject objects_modified = 2;
   */
  objects_modified: CMsgSOMultipleObjects_SingleObject[];
  /**
   * @generated from protobuf field: optional fixed64 version = 3;
   */
  version?: bigint;
  /**
   * @generated from protobuf field: repeated CMsgSOMultipleObjects.SingleObject objects_added = 4;
   */
  objects_added: CMsgSOMultipleObjects_SingleObject[];
  /**
   * @generated from protobuf field: repeated CMsgSOMultipleObjects.SingleObject objects_removed = 5;
   */
  objects_removed: CMsgSOMultipleObjects_SingleObject[];
  /**
   * @generated from protobuf field: optional CMsgSOIDOwner owner_soid = 6;
   */
  owner_soid?: CMsgSOIDOwner;
  /**
   * @generated from protobuf field: optional uint32 service_id = 7;
   */
  service_id?: number;
}
/**
 * @generated from protobuf message CMsgSOMultipleObjects.SingleObject
 */
export interface CMsgSOMultipleObjects_SingleObject {
  /**
   * @generated from protobuf field: optional int32 type_id = 1;
   */
  type_id?: number;
  /**
   * @generated from protobuf field: optional bytes object_data = 2;
   */
  object_data?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSOCacheSubscribed
 */
export interface CMsgSOCacheSubscribed {
  /**
   * @generated from protobuf field: repeated CMsgSOCacheSubscribed.SubscribedType objects = 2;
   */
  objects: CMsgSOCacheSubscribed_SubscribedType[];
  /**
   * @generated from protobuf field: optional fixed64 version = 3;
   */
  version?: bigint;
  /**
   * @generated from protobuf field: optional CMsgSOIDOwner owner_soid = 4;
   */
  owner_soid?: CMsgSOIDOwner;
  /**
   * @generated from protobuf field: optional uint32 service_id = 5;
   */
  service_id?: number;
  /**
   * @generated from protobuf field: repeated uint32 service_list = 6;
   */
  service_list: number[];
  /**
   * @generated from protobuf field: optional fixed64 sync_version = 7;
   */
  sync_version?: bigint;
}
/**
 * @generated from protobuf message CMsgSOCacheSubscribed.SubscribedType
 */
export interface CMsgSOCacheSubscribed_SubscribedType {
  /**
   * @generated from protobuf field: optional int32 type_id = 1;
   */
  type_id?: number;
  /**
   * @generated from protobuf field: repeated bytes object_data = 2;
   */
  object_data: Uint8Array[];
}
/**
 * @generated from protobuf message CMsgSOCacheSubscribedUpToDate
 */
export interface CMsgSOCacheSubscribedUpToDate {
  /**
   * @generated from protobuf field: optional fixed64 version = 1;
   */
  version?: bigint;
  /**
   * @generated from protobuf field: optional CMsgSOIDOwner owner_soid = 2;
   */
  owner_soid?: CMsgSOIDOwner;
  /**
   * @generated from protobuf field: optional uint32 service_id = 3;
   */
  service_id?: number;
  /**
   * @generated from protobuf field: repeated uint32 service_list = 4;
   */
  service_list: number[];
  /**
   * @generated from protobuf field: optional fixed64 sync_version = 5;
   */
  sync_version?: bigint;
}
/**
 * @generated from protobuf message CMsgSOCacheUnsubscribed
 */
export interface CMsgSOCacheUnsubscribed {
  /**
   * @generated from protobuf field: optional CMsgSOIDOwner owner_soid = 2;
   */
  owner_soid?: CMsgSOIDOwner;
}
/**
 * @generated from protobuf message CMsgSOCacheSubscriptionCheck
 */
export interface CMsgSOCacheSubscriptionCheck {
  /**
   * @generated from protobuf field: optional fixed64 version = 2;
   */
  version?: bigint;
  /**
   * @generated from protobuf field: optional CMsgSOIDOwner owner_soid = 3;
   */
  owner_soid?: CMsgSOIDOwner;
  /**
   * @generated from protobuf field: optional uint32 service_id = 4;
   */
  service_id?: number;
  /**
   * @generated from protobuf field: repeated uint32 service_list = 5;
   */
  service_list: number[];
  /**
   * @generated from protobuf field: optional fixed64 sync_version = 6;
   */
  sync_version?: bigint;
}
/**
 * @generated from protobuf message CMsgSOCacheSubscriptionRefresh
 */
export interface CMsgSOCacheSubscriptionRefresh {
  /**
   * @generated from protobuf field: optional CMsgSOIDOwner owner_soid = 2;
   */
  owner_soid?: CMsgSOIDOwner;
}
/**
 * @generated from protobuf message CMsgSOCacheVersion
 */
export interface CMsgSOCacheVersion {
  /**
   * @generated from protobuf field: optional fixed64 version = 1;
   */
  version?: bigint;
}
/**
 * @generated from protobuf message CMsgGCMultiplexMessage
 */
export interface CMsgGCMultiplexMessage {
  /**
   * @generated from protobuf field: optional uint32 msgtype = 1;
   */
  msgtype?: number;
  /**
   * @generated from protobuf field: optional bytes payload = 2;
   */
  payload?: Uint8Array;
  /**
   * @generated from protobuf field: repeated fixed64 steamids = 3;
   */
  steamids: bigint[];
}
/**
 * @generated from protobuf message CMsgGCToGCSubGCStarting
 */
export interface CMsgGCToGCSubGCStarting {
  /**
   * @generated from protobuf field: optional int32 dir_index = 1;
   */
  dir_index?: number;
}
/**
 * @generated from protobuf message CGCToGCMsgMasterAck
 */
export interface CGCToGCMsgMasterAck {
  /**
   * @generated from protobuf field: optional int32 dir_index = 1;
   */
  dir_index?: number;
  /**
   * @generated from protobuf field: optional string machine_name = 3;
   */
  machine_name?: string;
  /**
   * @generated from protobuf field: optional string process_name = 4;
   */
  process_name?: string;
  /**
   * @generated from protobuf field: repeated CGCToGCMsgMasterAck.Process directory = 6;
   */
  directory: CGCToGCMsgMasterAck_Process[];
}
/**
 * @generated from protobuf message CGCToGCMsgMasterAck.Process
 */
export interface CGCToGCMsgMasterAck_Process {
  /**
   * @generated from protobuf field: optional int32 dir_index = 1;
   */
  dir_index?: number;
  /**
   * @generated from protobuf field: repeated uint32 type_instances = 2;
   */
  type_instances: number[];
}
/**
 * @generated from protobuf message CGCToGCMsgMasterAck_Response
 */
export interface CGCToGCMsgMasterAck_Response {
  /**
   * @generated from protobuf field: optional int32 eresult = 1;
   */
  eresult?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCUniverseStartup
 */
export interface CMsgGCToGCUniverseStartup {
  /**
   * @generated from protobuf field: optional bool is_initial_startup = 1;
   */
  is_initial_startup?: boolean;
}
/**
 * @generated from protobuf message CMsgGCToGCUniverseStartupResponse
 */
export interface CMsgGCToGCUniverseStartupResponse {
  /**
   * @generated from protobuf field: optional int32 eresult = 1;
   */
  eresult?: number;
}
/**
 * @generated from protobuf message CGCToGCMsgMasterStartupComplete
 */
export interface CGCToGCMsgMasterStartupComplete {
  /**
   * @generated from protobuf field: repeated CGCToGCMsgMasterStartupComplete.GCInfo gc_info = 1;
   */
  gc_info: CGCToGCMsgMasterStartupComplete_GCInfo[];
}
/**
 * @generated from protobuf message CGCToGCMsgMasterStartupComplete.GCInfo
 */
export interface CGCToGCMsgMasterStartupComplete_GCInfo {
  /**
   * @generated from protobuf field: optional int32 dir_index = 1;
   */
  dir_index?: number;
  /**
   * @generated from protobuf field: optional string machine_name = 2;
   */
  machine_name?: string;
}
/**
 * @generated from protobuf message CGCToGCMsgRouted
 */
export interface CGCToGCMsgRouted {
  /**
   * @generated from protobuf field: optional uint32 msg_type = 1;
   */
  msg_type?: number;
  /**
   * @generated from protobuf field: optional fixed64 sender_id = 2;
   */
  sender_id?: bigint;
  /**
   * @generated from protobuf field: optional bytes net_message = 3;
   */
  net_message?: Uint8Array;
}
/**
 * @generated from protobuf message CGCToGCMsgRoutedReply
 */
export interface CGCToGCMsgRoutedReply {
  /**
   * @generated from protobuf field: optional uint32 msg_type = 1;
   */
  msg_type?: number;
  /**
   * @generated from protobuf field: optional bytes net_message = 2;
   */
  net_message?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgGCUpdateSubGCSessionInfo
 */
export interface CMsgGCUpdateSubGCSessionInfo {
  /**
   * @generated from protobuf field: repeated CMsgGCUpdateSubGCSessionInfo.CMsgUpdate updates = 1;
   */
  updates: CMsgGCUpdateSubGCSessionInfo_CMsgUpdate[];
}
/**
 * @generated from protobuf message CMsgGCUpdateSubGCSessionInfo.CMsgUpdate
 */
export interface CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
  /**
   * @generated from protobuf field: optional fixed64 steamid = 1;
   */
  steamid?: bigint;
  /**
   * @generated from protobuf field: optional fixed32 ip = 2;
   */
  ip?: number;
  /**
   * @generated from protobuf field: optional bool trusted = 3;
   */
  trusted?: boolean;
}
/**
 * @generated from protobuf message CMsgGCRequestSubGCSessionInfo
 */
export interface CMsgGCRequestSubGCSessionInfo {
  /**
   * @generated from protobuf field: optional fixed64 steamid = 1;
   */
  steamid?: bigint;
}
/**
 * @generated from protobuf message CMsgGCRequestSubGCSessionInfoResponse
 */
export interface CMsgGCRequestSubGCSessionInfoResponse {
  /**
   * @generated from protobuf field: optional fixed32 ip = 1;
   */
  ip?: number;
  /**
   * @generated from protobuf field: optional bool trusted = 2;
   */
  trusted?: boolean;
  /**
   * @generated from protobuf field: optional uint32 port = 3;
   */
  port?: number;
  /**
   * @generated from protobuf field: optional bool success = 4;
   */
  success?: boolean;
}
/**
 * @generated from protobuf message CMsgSOCacheHaveVersion
 */
export interface CMsgSOCacheHaveVersion {
  /**
   * @generated from protobuf field: optional CMsgSOIDOwner soid = 1;
   */
  soid?: CMsgSOIDOwner;
  /**
   * @generated from protobuf field: optional fixed64 version = 2;
   */
  version?: bigint;
  /**
   * @generated from protobuf field: optional uint32 service_id = 3;
   */
  service_id?: number;
  /**
   * @generated from protobuf field: optional uint32 cached_file_version = 4;
   */
  cached_file_version?: number;
}
/**
 * @generated from protobuf message CMsgClientHello
 */
export interface CMsgClientHello {
  /**
   * @generated from protobuf field: optional uint32 version = 1;
   */
  version?: number;
  /**
   * @generated from protobuf field: repeated CMsgSOCacheHaveVersion socache_have_versions = 2;
   */
  socache_have_versions: CMsgSOCacheHaveVersion[];
  /**
   * @generated from protobuf field: optional uint32 client_session_need = 3;
   */
  client_session_need?: number;
  /**
   * @generated from protobuf field: optional PartnerAccountType client_launcher = 4;
   */
  client_launcher?: PartnerAccountType;
  /**
   * @generated from protobuf field: optional string secret_key = 5;
   */
  secret_key?: string;
  /**
   * @generated from protobuf field: optional uint32 client_language = 6;
   */
  client_language?: number;
  /**
   * @generated from protobuf field: optional ESourceEngine engine = 7;
   */
  engine?: ESourceEngine;
  /**
   * @generated from protobuf field: optional bytes steamdatagram_login = 8;
   */
  steamdatagram_login?: Uint8Array;
  /**
   * @generated from protobuf field: optional uint32 platform_id = 9;
   */
  platform_id?: number;
  /**
   * @generated from protobuf field: optional bytes game_msg = 10;
   */
  game_msg?: Uint8Array;
  /**
   * @generated from protobuf field: optional int32 os_type = 11;
   */
  os_type?: number;
  /**
   * @generated from protobuf field: optional uint32 render_system = 12;
   */
  render_system?: number;
  /**
   * @generated from protobuf field: optional uint32 render_system_req = 13;
   */
  render_system_req?: number;
  /**
   * @generated from protobuf field: optional uint32 screen_width = 14;
   */
  screen_width?: number;
  /**
   * @generated from protobuf field: optional uint32 screen_height = 15;
   */
  screen_height?: number;
  /**
   * @generated from protobuf field: optional uint32 screen_refresh = 16;
   */
  screen_refresh?: number;
  /**
   * @generated from protobuf field: optional uint32 render_width = 17;
   */
  render_width?: number;
  /**
   * @generated from protobuf field: optional uint32 render_height = 18;
   */
  render_height?: number;
  /**
   * @generated from protobuf field: optional uint32 swap_width = 19;
   */
  swap_width?: number;
  /**
   * @generated from protobuf field: optional uint32 swap_height = 20;
   */
  swap_height?: number;
  /**
   * @generated from protobuf field: optional bool is_steam_china = 22;
   */
  is_steam_china?: boolean;
  /**
   * @generated from protobuf field: optional bool is_steam_china_client = 24;
   */
  is_steam_china_client?: boolean;
  /**
   * @generated from protobuf field: optional string platform_name = 23;
   */
  platform_name?: string;
}
/**
 * @generated from protobuf message CMsgClientWelcome
 */
export interface CMsgClientWelcome {
  /**
   * @generated from protobuf field: optional uint32 version = 1;
   */
  version?: number;
  /**
   * @generated from protobuf field: optional bytes game_data = 2;
   */
  game_data?: Uint8Array;
  /**
   * @generated from protobuf field: repeated CMsgSOCacheSubscribed outofdate_subscribed_caches = 3;
   */
  outofdate_subscribed_caches: CMsgSOCacheSubscribed[];
  /**
   * @generated from protobuf field: repeated CMsgSOCacheSubscriptionCheck uptodate_subscribed_caches = 4;
   */
  uptodate_subscribed_caches: CMsgSOCacheSubscriptionCheck[];
  /**
   * @generated from protobuf field: optional CMsgClientWelcome.Location location = 5;
   */
  location?: CMsgClientWelcome_Location;
  /**
   * @generated from protobuf field: optional uint32 gc_socache_file_version = 9;
   */
  gc_socache_file_version?: number;
  /**
   * @generated from protobuf field: optional string txn_country_code = 10;
   */
  txn_country_code?: string;
  /**
   * @generated from protobuf field: optional bytes game_data2 = 11;
   */
  game_data2?: Uint8Array;
  /**
   * @generated from protobuf field: optional uint32 rtime32_gc_welcome_timestamp = 12;
   */
  rtime32_gc_welcome_timestamp?: number;
  /**
   * @generated from protobuf field: optional uint32 currency = 13;
   */
  currency?: number;
  /**
   * @generated from protobuf field: optional uint32 balance = 14;
   */
  balance?: number;
  /**
   * @generated from protobuf field: optional string balance_url = 15;
   */
  balance_url?: string;
  /**
   * @generated from protobuf field: optional bool has_accepted_china_ssa = 16;
   */
  has_accepted_china_ssa?: boolean;
  /**
   * @generated from protobuf field: optional bool is_banned_steam_china = 17;
   */
  is_banned_steam_china?: boolean;
  /**
   * @generated from protobuf field: optional CExtraMsgBlock additional_welcome_msgs = 18;
   */
  additional_welcome_msgs?: CExtraMsgBlock;
  /**
   * @generated from protobuf field: optional CMsgSteamLearnServerInfo steam_learn_server_info = 20;
   */
  steam_learn_server_info?: CMsgSteamLearnServerInfo;
}
/**
 * @generated from protobuf message CMsgClientWelcome.Location
 */
export interface CMsgClientWelcome_Location {
  /**
   * @generated from protobuf field: optional float latitude = 1;
   */
  latitude?: number;
  /**
   * @generated from protobuf field: optional float longitude = 2;
   */
  longitude?: number;
  /**
   * @generated from protobuf field: optional string country = 3;
   */
  country?: string;
}
/**
 * @generated from protobuf message CMsgConnectionStatus
 */
export interface CMsgConnectionStatus {
  /**
   * @generated from protobuf field: optional GCConnectionStatus status = 1;
   */
  status?: GCConnectionStatus;
  /**
   * @generated from protobuf field: optional uint32 client_session_need = 2;
   */
  client_session_need?: number;
  /**
   * @generated from protobuf field: optional int32 queue_position = 3;
   */
  queue_position?: number;
  /**
   * @generated from protobuf field: optional int32 queue_size = 4;
   */
  queue_size?: number;
  /**
   * @generated from protobuf field: optional int32 wait_seconds = 5;
   */
  wait_seconds?: number;
  /**
   * @generated from protobuf field: optional int32 estimated_wait_seconds_remaining = 6;
   */
  estimated_wait_seconds_remaining?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCSOCacheSubscribe
 */
export interface CMsgGCToGCSOCacheSubscribe {
  /**
   * @generated from protobuf field: optional fixed64 subscriber = 1;
   */
  subscriber?: bigint;
  /**
   * @generated from protobuf field: optional fixed64 subscribe_to_id = 2;
   */
  subscribe_to_id?: bigint;
  /**
   * @generated from protobuf field: optional fixed64 sync_version = 3;
   */
  sync_version?: bigint;
  /**
   * @generated from protobuf field: repeated CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions have_versions = 4;
   */
  have_versions: CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions[];
  /**
   * @generated from protobuf field: optional uint32 subscribe_to_type = 5;
   */
  subscribe_to_type?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions
 */
export interface CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
  /**
   * @generated from protobuf field: optional uint32 service_id = 1;
   */
  service_id?: number;
  /**
   * @generated from protobuf field: optional uint64 version = 2;
   */
  version?: bigint;
}
/**
 * @generated from protobuf message CMsgGCToGCSOCacheUnsubscribe
 */
export interface CMsgGCToGCSOCacheUnsubscribe {
  /**
   * @generated from protobuf field: optional fixed64 subscriber = 1;
   */
  subscriber?: bigint;
  /**
   * @generated from protobuf field: optional fixed64 unsubscribe_from_id = 2;
   */
  unsubscribe_from_id?: bigint;
  /**
   * @generated from protobuf field: optional uint32 unsubscribe_from_type = 3;
   */
  unsubscribe_from_type?: number;
}
/**
 * @generated from protobuf message CMsgGCClientPing
 */
export interface CMsgGCClientPing {}
/**
 * @generated from protobuf message CMsgGCToGCForwardAccountDetails
 */
export interface CMsgGCToGCForwardAccountDetails {
  /**
   * @generated from protobuf field: optional fixed64 steamid = 1;
   */
  steamid?: bigint;
  /**
   * @generated from protobuf field: optional CGCSystemMsg_GetAccountDetails_Response account_details = 2;
   */
  account_details?: CGCSystemMsg_GetAccountDetails_Response;
  /**
   * @generated from protobuf field: optional uint32 age_seconds = 3;
   */
  age_seconds?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCLoadSessionSOCache
 */
export interface CMsgGCToGCLoadSessionSOCache {
  /**
   * @generated from protobuf field: optional uint32 account_id = 1;
   */
  account_id?: number;
  /**
   * @generated from protobuf field: optional CMsgGCToGCForwardAccountDetails forward_account_details = 2;
   */
  forward_account_details?: CMsgGCToGCForwardAccountDetails;
}
/**
 * @generated from protobuf message CMsgGCToGCLoadSessionSOCacheResponse
 */
export interface CMsgGCToGCLoadSessionSOCacheResponse {}
/**
 * @generated from protobuf message CMsgGCToGCUpdateSessionStats
 */
export interface CMsgGCToGCUpdateSessionStats {
  /**
   * @generated from protobuf field: optional uint32 user_sessions = 1;
   */
  user_sessions?: number;
  /**
   * @generated from protobuf field: optional uint32 server_sessions = 2;
   */
  server_sessions?: number;
  /**
   * @generated from protobuf field: optional bool in_logon_surge = 3;
   */
  in_logon_surge?: boolean;
}
/**
 * @generated from protobuf message CMsgGCToClientRequestDropped
 */
export interface CMsgGCToClientRequestDropped {}
/**
 * @generated from protobuf message CWorkshop_PopulateItemDescriptions_Request
 */
export interface CWorkshop_PopulateItemDescriptions_Request {
  /**
   * @generated from protobuf field: optional uint32 appid = 1;
   */
  appid?: number;
  /**
   * @generated from protobuf field: repeated CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock languages = 2;
   */
  languages: CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock[];
}
/**
 * @generated from protobuf message CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription
 */
export interface CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
  /**
   * @generated from protobuf field: optional uint32 gameitemid = 1;
   */
  gameitemid?: number;
  /**
   * @generated from protobuf field: optional string item_description = 2;
   */
  item_description?: string;
}
/**
 * @generated from protobuf message CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock
 */
export interface CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
  /**
   * @generated from protobuf field: optional string language = 1;
   */
  language?: string;
  /**
   * @generated from protobuf field: repeated CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription descriptions = 2;
   */
  descriptions: CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription[];
}
/**
 * @generated from protobuf message CWorkshop_GetContributors_Request
 */
export interface CWorkshop_GetContributors_Request {
  /**
   * @generated from protobuf field: optional uint32 appid = 1;
   */
  appid?: number;
  /**
   * @generated from protobuf field: optional uint32 gameitemid = 2;
   */
  gameitemid?: number;
}
/**
 * @generated from protobuf message CWorkshop_GetContributors_Response
 */
export interface CWorkshop_GetContributors_Response {
  /**
   * @generated from protobuf field: repeated fixed64 contributors = 1;
   */
  contributors: bigint[];
}
/**
 * @generated from protobuf message CWorkshop_SetItemPaymentRules_Request
 */
export interface CWorkshop_SetItemPaymentRules_Request {
  /**
   * @generated from protobuf field: optional uint32 appid = 1;
   */
  appid?: number;
  /**
   * @generated from protobuf field: optional uint32 gameitemid = 2;
   */
  gameitemid?: number;
  /**
   * @generated from protobuf field: repeated CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule associated_workshop_files = 3;
   */
  associated_workshop_files: CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule[];
  /**
   * @generated from protobuf field: repeated CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule partner_accounts = 4;
   */
  partner_accounts: CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule[];
  /**
   * @generated from protobuf field: optional bool validate_only = 5;
   */
  validate_only?: boolean;
  /**
   * @generated from protobuf field: optional bool make_workshop_files_subscribable = 6;
   */
  make_workshop_files_subscribable?: boolean;
  /**
   * @generated from protobuf field: optional CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule associated_workshop_file_for_direct_payments = 7;
   */
  associated_workshop_file_for_direct_payments?: CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule;
}
/**
 * @generated from protobuf message CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule
 */
export interface CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
  /**
   * @generated from protobuf field: optional uint64 workshop_file_id = 1;
   */
  workshop_file_id?: bigint;
  /**
   * @generated from protobuf field: optional float revenue_percentage = 2;
   */
  revenue_percentage?: number;
  /**
   * @generated from protobuf field: optional string rule_description = 3;
   */
  rule_description?: string;
  /**
   * @generated from protobuf field: optional uint32 rule_type = 4;
   */
  rule_type?: number;
}
/**
 * @generated from protobuf message CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule
 */
export interface CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule {
  /**
   * @generated from protobuf field: optional uint64 workshop_file_id = 1;
   */
  workshop_file_id?: bigint;
  /**
   * @generated from protobuf field: optional string rule_description = 2;
   */
  rule_description?: string;
}
/**
 * @generated from protobuf message CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule
 */
export interface CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
  /**
   * @generated from protobuf field: optional uint32 account_id = 1;
   */
  account_id?: number;
  /**
   * @generated from protobuf field: optional float revenue_percentage = 2;
   */
  revenue_percentage?: number;
  /**
   * @generated from protobuf field: optional string rule_description = 3;
   */
  rule_description?: string;
}
/**
 * @generated from protobuf message CWorkshop_SetItemPaymentRules_Response
 */
export interface CWorkshop_SetItemPaymentRules_Response {
  /**
   * @generated from protobuf field: repeated string validation_errors = 1;
   */
  validation_errors: string[];
}
/**
 * @generated from protobuf message CCommunity_ClanAnnouncementInfo
 */
export interface CCommunity_ClanAnnouncementInfo {
  /**
   * @generated from protobuf field: optional uint64 gid = 1;
   */
  gid?: bigint;
  /**
   * @generated from protobuf field: optional uint64 clanid = 2;
   */
  clanid?: bigint;
  /**
   * @generated from protobuf field: optional uint64 posterid = 3;
   */
  posterid?: bigint;
  /**
   * @generated from protobuf field: optional string headline = 4;
   */
  headline?: string;
  /**
   * @generated from protobuf field: optional uint32 posttime = 5;
   */
  posttime?: number;
  /**
   * @generated from protobuf field: optional uint32 updatetime = 6;
   */
  updatetime?: number;
  /**
   * @generated from protobuf field: optional string body = 7;
   */
  body?: string;
  /**
   * @generated from protobuf field: optional int32 commentcount = 8;
   */
  commentcount?: number;
  /**
   * @generated from protobuf field: repeated string tags = 9;
   */
  tags: string[];
  /**
   * @generated from protobuf field: optional int32 language = 10;
   */
  language?: number;
  /**
   * @generated from protobuf field: optional bool hidden = 11;
   */
  hidden?: boolean;
  /**
   * @generated from protobuf field: optional fixed64 forum_topic_id = 12;
   */
  forum_topic_id?: bigint;
}
/**
 * @generated from protobuf message CCommunity_GetClanAnnouncements_Request
 */
export interface CCommunity_GetClanAnnouncements_Request {
  /**
   * @generated from protobuf field: optional uint64 steamid = 1;
   */
  steamid?: bigint;
  /**
   * @generated from protobuf field: optional uint32 offset = 2;
   */
  offset?: number;
  /**
   * @generated from protobuf field: optional uint32 count = 3;
   */
  count?: number;
  /**
   * @generated from protobuf field: optional uint32 maxchars = 4;
   */
  maxchars?: number;
  /**
   * @generated from protobuf field: optional bool strip_html = 5;
   */
  strip_html?: boolean;
  /**
   * @generated from protobuf field: repeated string required_tags = 6;
   */
  required_tags: string[];
  /**
   * @generated from protobuf field: optional bool require_no_tags = 7;
   */
  require_no_tags?: boolean;
  /**
   * @generated from protobuf field: repeated uint32 language_preference = 8;
   */
  language_preference: number[];
  /**
   * @generated from protobuf field: optional bool hidden_only = 9;
   */
  hidden_only?: boolean;
  /**
   * @generated from protobuf field: optional bool only_gid = 10;
   */
  only_gid?: boolean;
  /**
   * @generated from protobuf field: optional uint32 rtime_oldest_date = 11;
   */
  rtime_oldest_date?: number;
  /**
   * @generated from protobuf field: optional bool include_hidden = 12;
   */
  include_hidden?: boolean;
  /**
   * @generated from protobuf field: optional bool include_partner_events = 13;
   */
  include_partner_events?: boolean;
}
/**
 * @generated from protobuf message CCommunity_GetClanAnnouncements_Response
 */
export interface CCommunity_GetClanAnnouncements_Response {
  /**
   * @generated from protobuf field: optional uint32 maxchars = 1;
   */
  maxchars?: number;
  /**
   * @generated from protobuf field: optional bool strip_html = 2;
   */
  strip_html?: boolean;
  /**
   * @generated from protobuf field: repeated CCommunity_ClanAnnouncementInfo announcements = 3;
   */
  announcements: CCommunity_ClanAnnouncementInfo[];
}
/**
 * @generated from protobuf message CBroadcast_PostGameDataFrame_Request
 */
export interface CBroadcast_PostGameDataFrame_Request {
  /**
   * @generated from protobuf field: optional uint32 appid = 1;
   */
  appid?: number;
  /**
   * @generated from protobuf field: optional fixed64 steamid = 2;
   */
  steamid?: bigint;
  /**
   * @generated from protobuf field: optional fixed64 broadcast_id = 3;
   */
  broadcast_id?: bigint;
  /**
   * @generated from protobuf field: optional bytes frame_data = 4;
   */
  frame_data?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSerializedSOCache
 */
export interface CMsgSerializedSOCache {
  /**
   * @generated from protobuf field: optional uint32 file_version = 1;
   */
  file_version?: number;
  /**
   * @generated from protobuf field: repeated CMsgSerializedSOCache.Cache caches = 2;
   */
  caches: CMsgSerializedSOCache_Cache[];
  /**
   * @generated from protobuf field: optional uint32 gc_socache_file_version = 3;
   */
  gc_socache_file_version?: number;
}
/**
 * @generated from protobuf message CMsgSerializedSOCache.TypeCache
 */
export interface CMsgSerializedSOCache_TypeCache {
  /**
   * @generated from protobuf field: optional uint32 type = 1;
   */
  type?: number;
  /**
   * @generated from protobuf field: repeated bytes objects = 2;
   */
  objects: Uint8Array[];
  /**
   * @generated from protobuf field: optional uint32 service_id = 3;
   */
  service_id?: number;
}
/**
 * @generated from protobuf message CMsgSerializedSOCache.Cache
 */
export interface CMsgSerializedSOCache_Cache {
  /**
   * @generated from protobuf field: optional uint32 type = 1;
   */
  type?: number;
  /**
   * @generated from protobuf field: optional uint64 id = 2;
   */
  id?: bigint;
  /**
   * @generated from protobuf field: repeated CMsgSerializedSOCache.Cache.Version versions = 3;
   */
  versions: CMsgSerializedSOCache_Cache_Version[];
  /**
   * @generated from protobuf field: repeated CMsgSerializedSOCache.TypeCache type_caches = 4;
   */
  type_caches: CMsgSerializedSOCache_TypeCache[];
}
/**
 * @generated from protobuf message CMsgSerializedSOCache.Cache.Version
 */
export interface CMsgSerializedSOCache_Cache_Version {
  /**
   * @generated from protobuf field: optional uint32 service = 1;
   */
  service?: number;
  /**
   * @generated from protobuf field: optional uint64 version = 2;
   */
  version?: bigint;
}
/**
 * @generated from protobuf message CMsgGCToClientPollConvarRequest
 */
export interface CMsgGCToClientPollConvarRequest {
  /**
   * @generated from protobuf field: optional string convar_name = 1;
   */
  convar_name?: string;
  /**
   * @generated from protobuf field: optional uint32 poll_id = 2;
   */
  poll_id?: number;
}
/**
 * @generated from protobuf message CMsgGCToClientPollConvarResponse
 */
export interface CMsgGCToClientPollConvarResponse {
  /**
   * @generated from protobuf field: optional uint32 poll_id = 1;
   */
  poll_id?: number;
  /**
   * @generated from protobuf field: optional string convar_value = 2;
   */
  convar_value?: string;
}
/**
 * @generated from protobuf message CGCMsgCompressedMsgToClient
 */
export interface CGCMsgCompressedMsgToClient {
  /**
   * @generated from protobuf field: optional uint32 msg_id = 1;
   */
  msg_id?: number;
  /**
   * @generated from protobuf field: optional bytes compressed_msg = 2;
   */
  compressed_msg?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgGCToGCMasterBroadcastMessage
 */
export interface CMsgGCToGCMasterBroadcastMessage {
  /**
   * @generated from protobuf field: optional uint32 users_per_second = 1;
   */
  users_per_second?: number;
  /**
   * @generated from protobuf field: optional bool send_to_users = 2;
   */
  send_to_users?: boolean;
  /**
   * @generated from protobuf field: optional bool send_to_servers = 3;
   */
  send_to_servers?: boolean;
  /**
   * @generated from protobuf field: optional uint32 msg_id = 4;
   */
  msg_id?: number;
  /**
   * @generated from protobuf field: optional bytes msg_data = 5;
   */
  msg_data?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgGCToGCMasterSubscribeToCache
 */
export interface CMsgGCToGCMasterSubscribeToCache {
  /**
   * @generated from protobuf field: optional uint32 soid_type = 1;
   */
  soid_type?: number;
  /**
   * @generated from protobuf field: optional fixed64 soid_id = 2;
   */
  soid_id?: bigint;
  /**
   * @generated from protobuf field: repeated uint32 account_ids = 3;
   */
  account_ids: number[];
  /**
   * @generated from protobuf field: repeated fixed64 steam_ids = 4;
   */
  steam_ids: bigint[];
}
/**
 * @generated from protobuf message CMsgGCToGCMasterSubscribeToCacheResponse
 */
export interface CMsgGCToGCMasterSubscribeToCacheResponse {}
/**
 * @generated from protobuf message CMsgGCToGCMasterSubscribeToCacheAsync
 */
export interface CMsgGCToGCMasterSubscribeToCacheAsync {
  /**
   * @generated from protobuf field: optional CMsgGCToGCMasterSubscribeToCache subscribe_msg = 1;
   */
  subscribe_msg?: CMsgGCToGCMasterSubscribeToCache;
}
/**
 * @generated from protobuf message CMsgGCToGCMasterUnsubscribeFromCache
 */
export interface CMsgGCToGCMasterUnsubscribeFromCache {
  /**
   * @generated from protobuf field: optional uint32 soid_type = 1;
   */
  soid_type?: number;
  /**
   * @generated from protobuf field: optional fixed64 soid_id = 2;
   */
  soid_id?: bigint;
  /**
   * @generated from protobuf field: repeated uint32 account_ids = 3;
   */
  account_ids: number[];
  /**
   * @generated from protobuf field: repeated fixed64 steam_ids = 4;
   */
  steam_ids: bigint[];
}
/**
 * @generated from protobuf message CMsgGCToGCMasterDestroyCache
 */
export interface CMsgGCToGCMasterDestroyCache {
  /**
   * @generated from protobuf field: optional uint32 soid_type = 1;
   */
  soid_type?: number;
  /**
   * @generated from protobuf field: optional fixed64 soid_id = 2;
   */
  soid_id?: bigint;
}
/**
 * @generated from protobuf enum ESourceEngine
 */
export enum ESourceEngine {
  /**
   * @generated from protobuf enum value: k_ESE_Source1 = 0;
   */
  k_ESE_Source1 = 0,
  /**
   * @generated from protobuf enum value: k_ESE_Source2 = 1;
   */
  k_ESE_Source2 = 1,
}
/**
 * @generated from protobuf enum PartnerAccountType
 */
export enum PartnerAccountType {
  /**
   * @generated from protobuf enum value: PARTNER_NONE = 0;
   */
  PARTNER_NONE = 0,
  /**
   * @generated from protobuf enum value: PARTNER_PERFECT_WORLD = 1;
   */
  PARTNER_PERFECT_WORLD = 1,
  /**
   * @generated from protobuf enum value: PARTNER_INVALID = 3;
   */
  PARTNER_INVALID = 3,
}
/**
 * @generated from protobuf enum GCConnectionStatus
 */
export enum GCConnectionStatus {
  /**
   * @generated from protobuf enum value: GCConnectionStatus_HAVE_SESSION = 0;
   */
  GCConnectionStatus_HAVE_SESSION = 0,
  /**
   * @generated from protobuf enum value: GCConnectionStatus_GC_GOING_DOWN = 1;
   */
  GCConnectionStatus_GC_GOING_DOWN = 1,
  /**
   * @generated from protobuf enum value: GCConnectionStatus_NO_SESSION = 2;
   */
  GCConnectionStatus_NO_SESSION = 2,
  /**
   * @generated from protobuf enum value: GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE = 3;
   */
  GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE = 3,
  /**
   * @generated from protobuf enum value: GCConnectionStatus_NO_STEAM = 4;
   */
  GCConnectionStatus_NO_STEAM = 4,
  /**
   * @generated from protobuf enum value: GCConnectionStatus_SUSPENDED = 5;
   */
  GCConnectionStatus_SUSPENDED = 5,
  /**
   * @generated from protobuf enum value: GCConnectionStatus_STEAM_GOING_DOWN = 6;
   */
  GCConnectionStatus_STEAM_GOING_DOWN = 6,
}
// @generated message type with reflection information, may provide speed optimized methods
class CExtraMsgBlock$Type extends MessageType<CExtraMsgBlock> {
  constructor() {
    super("CExtraMsgBlock", [
      {
        no: 1,
        name: "msg_type",
        kind: "scalar",
        localName: "msg_type",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "contents",
        kind: "scalar",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 3,
        name: "msg_key",
        kind: "scalar",
        localName: "msg_key",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 4,
        name: "is_compressed",
        kind: "scalar",
        localName: "is_compressed",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<CExtraMsgBlock>): CExtraMsgBlock {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CExtraMsgBlock>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CExtraMsgBlock,
  ): CExtraMsgBlock {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 msg_type */ 1:
          message.msg_type = reader.uint32();
          break;
        case /* optional bytes contents */ 2:
          message.contents = reader.bytes();
          break;
        case /* optional uint64 msg_key */ 3:
          message.msg_key = reader.uint64().toBigInt();
          break;
        case /* optional bool is_compressed */ 4:
          message.is_compressed = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CExtraMsgBlock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional uint32 msg_type = 1; */
    if (message.msg_type !== undefined) writer.tag(1, WireType.Varint).uint32(message.msg_type);
    /* optional bytes contents = 2; */
    if (message.contents !== undefined) writer.tag(2, WireType.LengthDelimited).bytes(message.contents);
    /* optional uint64 msg_key = 3; */
    if (message.msg_key !== undefined) writer.tag(3, WireType.Varint).uint64(message.msg_key);
    /* optional bool is_compressed = 4; */
    if (message.is_compressed !== undefined) writer.tag(4, WireType.Varint).bool(message.is_compressed);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CExtraMsgBlock
 */
export const CExtraMsgBlock = new CExtraMsgBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearnServerInfo$Type extends MessageType<CMsgSteamLearnServerInfo> {
  constructor() {
    super("CMsgSteamLearnServerInfo", [
      {
        no: 4,
        name: "access_tokens",
        kind: "message",
        localName: "access_tokens",
        T: () => CMsgSteamLearnAccessTokens,
      },
      {
        no: 5,
        name: "project_infos",
        kind: "message",
        localName: "project_infos",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgSteamLearnServerInfo_ProjectInfo,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSteamLearnServerInfo>): CMsgSteamLearnServerInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.project_infos = [];
    if (value !== undefined) reflectionMergePartial<CMsgSteamLearnServerInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSteamLearnServerInfo,
  ): CMsgSteamLearnServerInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgSteamLearnAccessTokens access_tokens */ 4:
          message.access_tokens = CMsgSteamLearnAccessTokens.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.access_tokens,
          );
          break;
        case /* repeated CMsgSteamLearnServerInfo.ProjectInfo project_infos */ 5:
          message.project_infos.push(
            CMsgSteamLearnServerInfo_ProjectInfo.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSteamLearnServerInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgSteamLearnAccessTokens access_tokens = 4; */
    if (message.access_tokens)
      CMsgSteamLearnAccessTokens.internalBinaryWrite(
        message.access_tokens,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated CMsgSteamLearnServerInfo.ProjectInfo project_infos = 5; */
    for (let i = 0; i < message.project_infos.length; i++)
      CMsgSteamLearnServerInfo_ProjectInfo.internalBinaryWrite(
        message.project_infos[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearnServerInfo
 */
export const CMsgSteamLearnServerInfo = new CMsgSteamLearnServerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearnServerInfo_ProjectInfo$Type extends MessageType<CMsgSteamLearnServerInfo_ProjectInfo> {
  constructor() {
    super("CMsgSteamLearnServerInfo.ProjectInfo", [
      {
        no: 1,
        name: "project_id",
        kind: "scalar",
        localName: "project_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "snapshot_published_version",
        kind: "scalar",
        localName: "snapshot_published_version",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "inference_published_version",
        kind: "scalar",
        localName: "inference_published_version",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "snapshot_percentage",
        kind: "scalar",
        localName: "snapshot_percentage",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 7,
        name: "snapshot_enabled",
        kind: "scalar",
        localName: "snapshot_enabled",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSteamLearnServerInfo_ProjectInfo>): CMsgSteamLearnServerInfo_ProjectInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSteamLearnServerInfo_ProjectInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSteamLearnServerInfo_ProjectInfo,
  ): CMsgSteamLearnServerInfo_ProjectInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 project_id */ 1:
          message.project_id = reader.uint32();
          break;
        case /* optional uint32 snapshot_published_version */ 2:
          message.snapshot_published_version = reader.uint32();
          break;
        case /* optional uint32 inference_published_version */ 3:
          message.inference_published_version = reader.uint32();
          break;
        case /* optional uint32 snapshot_percentage */ 6:
          message.snapshot_percentage = reader.uint32();
          break;
        case /* optional bool snapshot_enabled */ 7:
          message.snapshot_enabled = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSteamLearnServerInfo_ProjectInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 project_id = 1; */
    if (message.project_id !== undefined) writer.tag(1, WireType.Varint).uint32(message.project_id);
    /* optional uint32 snapshot_published_version = 2; */
    if (message.snapshot_published_version !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.snapshot_published_version);
    /* optional uint32 inference_published_version = 3; */
    if (message.inference_published_version !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.inference_published_version);
    /* optional uint32 snapshot_percentage = 6; */
    if (message.snapshot_percentage !== undefined) writer.tag(6, WireType.Varint).uint32(message.snapshot_percentage);
    /* optional bool snapshot_enabled = 7; */
    if (message.snapshot_enabled !== undefined) writer.tag(7, WireType.Varint).bool(message.snapshot_enabled);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearnServerInfo.ProjectInfo
 */
export const CMsgSteamLearnServerInfo_ProjectInfo = new CMsgSteamLearnServerInfo_ProjectInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCAssertJobData$Type extends MessageType<CMsgGCAssertJobData> {
  constructor() {
    super("CMsgGCAssertJobData", [
      {
        no: 1,
        name: "message_type",
        kind: "scalar",
        localName: "message_type",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "message_data",
        kind: "scalar",
        localName: "message_data",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCAssertJobData>): CMsgGCAssertJobData {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCAssertJobData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCAssertJobData,
  ): CMsgGCAssertJobData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string message_type */ 1:
          message.message_type = reader.string();
          break;
        case /* optional bytes message_data */ 2:
          message.message_data = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgGCAssertJobData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional string message_type = 1; */
    if (message.message_type !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.message_type);
    /* optional bytes message_data = 2; */
    if (message.message_data !== undefined) writer.tag(2, WireType.LengthDelimited).bytes(message.message_data);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCAssertJobData
 */
export const CMsgGCAssertJobData = new CMsgGCAssertJobData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCConCommand$Type extends MessageType<CMsgGCConCommand> {
  constructor() {
    super("CMsgGCConCommand", [
      {
        no: 1,
        name: "command",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCConCommand>): CMsgGCConCommand {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCConCommand>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCConCommand,
  ): CMsgGCConCommand {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string command */ 1:
          message.command = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgGCConCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional string command = 1; */
    if (message.command !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.command);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCConCommand
 */
export const CMsgGCConCommand = new CMsgGCConCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSDOAssert$Type extends MessageType<CMsgSDOAssert> {
  constructor() {
    super("CMsgSDOAssert", [
      {
        no: 1,
        name: "sdo_type",
        kind: "scalar",
        localName: "sdo_type",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "requests",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgSDOAssert_Request,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSDOAssert>): CMsgSDOAssert {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.requests = [];
    if (value !== undefined) reflectionMergePartial<CMsgSDOAssert>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSDOAssert,
  ): CMsgSDOAssert {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 sdo_type */ 1:
          message.sdo_type = reader.int32();
          break;
        case /* repeated CMsgSDOAssert.Request requests */ 2:
          message.requests.push(CMsgSDOAssert_Request.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgSDOAssert, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional int32 sdo_type = 1; */
    if (message.sdo_type !== undefined) writer.tag(1, WireType.Varint).int32(message.sdo_type);
    /* repeated CMsgSDOAssert.Request requests = 2; */
    for (let i = 0; i < message.requests.length; i++)
      CMsgSDOAssert_Request.internalBinaryWrite(
        message.requests[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSDOAssert
 */
export const CMsgSDOAssert = new CMsgSDOAssert$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSDOAssert_Request$Type extends MessageType<CMsgSDOAssert_Request> {
  constructor() {
    super("CMsgSDOAssert.Request", [
      {
        no: 1,
        name: "key",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "requesting_job",
        kind: "scalar",
        localName: "requesting_job",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSDOAssert_Request>): CMsgSDOAssert_Request {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.key = [];
    if (value !== undefined) reflectionMergePartial<CMsgSDOAssert_Request>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSDOAssert_Request,
  ): CMsgSDOAssert_Request {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated uint64 key */ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.key.push(reader.uint64().toBigInt());
          else message.key.push(reader.uint64().toBigInt());
          break;
        case /* optional string requesting_job */ 2:
          message.requesting_job = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSDOAssert_Request,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated uint64 key = 1; */
    for (let i = 0; i < message.key.length; i++) writer.tag(1, WireType.Varint).uint64(message.key[i]);
    /* optional string requesting_job = 2; */
    if (message.requesting_job !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.requesting_job);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSDOAssert.Request
 */
export const CMsgSDOAssert_Request = new CMsgSDOAssert_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOIDOwner$Type extends MessageType<CMsgSOIDOwner> {
  constructor() {
    super("CMsgSOIDOwner", [
      {
        no: 1,
        name: "type",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSOIDOwner>): CMsgSOIDOwner {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSOIDOwner>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSOIDOwner,
  ): CMsgSOIDOwner {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 type */ 1:
          message.type = reader.uint32();
          break;
        case /* optional uint64 id */ 2:
          message.id = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgSOIDOwner, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional uint32 type = 1; */
    if (message.type !== undefined) writer.tag(1, WireType.Varint).uint32(message.type);
    /* optional uint64 id = 2; */
    if (message.id !== undefined) writer.tag(2, WireType.Varint).uint64(message.id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSOIDOwner
 */
export const CMsgSOIDOwner = new CMsgSOIDOwner$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOSingleObject$Type extends MessageType<CMsgSOSingleObject> {
  constructor() {
    super("CMsgSOSingleObject", [
      {
        no: 2,
        name: "type_id",
        kind: "scalar",
        localName: "type_id",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "object_data",
        kind: "scalar",
        localName: "object_data",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 4,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 5,
        name: "owner_soid",
        kind: "message",
        localName: "owner_soid",
        T: () => CMsgSOIDOwner,
      },
      {
        no: 6,
        name: "service_id",
        kind: "scalar",
        localName: "service_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSOSingleObject>): CMsgSOSingleObject {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSOSingleObject>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSOSingleObject,
  ): CMsgSOSingleObject {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 type_id */ 2:
          message.type_id = reader.int32();
          break;
        case /* optional bytes object_data */ 3:
          message.object_data = reader.bytes();
          break;
        case /* optional fixed64 version */ 4:
          message.version = reader.fixed64().toBigInt();
          break;
        case /* optional CMsgSOIDOwner owner_soid */ 5:
          message.owner_soid = CMsgSOIDOwner.internalBinaryRead(reader, reader.uint32(), options, message.owner_soid);
          break;
        case /* optional uint32 service_id */ 6:
          message.service_id = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgSOSingleObject, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional int32 type_id = 2; */
    if (message.type_id !== undefined) writer.tag(2, WireType.Varint).int32(message.type_id);
    /* optional bytes object_data = 3; */
    if (message.object_data !== undefined) writer.tag(3, WireType.LengthDelimited).bytes(message.object_data);
    /* optional fixed64 version = 4; */
    if (message.version !== undefined) writer.tag(4, WireType.Bit64).fixed64(message.version);
    /* optional CMsgSOIDOwner owner_soid = 5; */
    if (message.owner_soid)
      CMsgSOIDOwner.internalBinaryWrite(
        message.owner_soid,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 service_id = 6; */
    if (message.service_id !== undefined) writer.tag(6, WireType.Varint).uint32(message.service_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSOSingleObject
 */
export const CMsgSOSingleObject = new CMsgSOSingleObject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOMultipleObjects$Type extends MessageType<CMsgSOMultipleObjects> {
  constructor() {
    super("CMsgSOMultipleObjects", [
      {
        no: 2,
        name: "objects_modified",
        kind: "message",
        localName: "objects_modified",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgSOMultipleObjects_SingleObject,
      },
      {
        no: 3,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 4,
        name: "objects_added",
        kind: "message",
        localName: "objects_added",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgSOMultipleObjects_SingleObject,
      },
      {
        no: 5,
        name: "objects_removed",
        kind: "message",
        localName: "objects_removed",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgSOMultipleObjects_SingleObject,
      },
      {
        no: 6,
        name: "owner_soid",
        kind: "message",
        localName: "owner_soid",
        T: () => CMsgSOIDOwner,
      },
      {
        no: 7,
        name: "service_id",
        kind: "scalar",
        localName: "service_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSOMultipleObjects>): CMsgSOMultipleObjects {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.objects_modified = [];
    message.objects_added = [];
    message.objects_removed = [];
    if (value !== undefined) reflectionMergePartial<CMsgSOMultipleObjects>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSOMultipleObjects,
  ): CMsgSOMultipleObjects {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CMsgSOMultipleObjects.SingleObject objects_modified */ 2:
          message.objects_modified.push(
            CMsgSOMultipleObjects_SingleObject.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* optional fixed64 version */ 3:
          message.version = reader.fixed64().toBigInt();
          break;
        case /* repeated CMsgSOMultipleObjects.SingleObject objects_added */ 4:
          message.objects_added.push(
            CMsgSOMultipleObjects_SingleObject.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated CMsgSOMultipleObjects.SingleObject objects_removed */ 5:
          message.objects_removed.push(
            CMsgSOMultipleObjects_SingleObject.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* optional CMsgSOIDOwner owner_soid */ 6:
          message.owner_soid = CMsgSOIDOwner.internalBinaryRead(reader, reader.uint32(), options, message.owner_soid);
          break;
        case /* optional uint32 service_id */ 7:
          message.service_id = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSOMultipleObjects,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CMsgSOMultipleObjects.SingleObject objects_modified = 2; */
    for (let i = 0; i < message.objects_modified.length; i++)
      CMsgSOMultipleObjects_SingleObject.internalBinaryWrite(
        message.objects_modified[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional fixed64 version = 3; */
    if (message.version !== undefined) writer.tag(3, WireType.Bit64).fixed64(message.version);
    /* repeated CMsgSOMultipleObjects.SingleObject objects_added = 4; */
    for (let i = 0; i < message.objects_added.length; i++)
      CMsgSOMultipleObjects_SingleObject.internalBinaryWrite(
        message.objects_added[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated CMsgSOMultipleObjects.SingleObject objects_removed = 5; */
    for (let i = 0; i < message.objects_removed.length; i++)
      CMsgSOMultipleObjects_SingleObject.internalBinaryWrite(
        message.objects_removed[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgSOIDOwner owner_soid = 6; */
    if (message.owner_soid)
      CMsgSOIDOwner.internalBinaryWrite(
        message.owner_soid,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 service_id = 7; */
    if (message.service_id !== undefined) writer.tag(7, WireType.Varint).uint32(message.service_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSOMultipleObjects
 */
export const CMsgSOMultipleObjects = new CMsgSOMultipleObjects$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOMultipleObjects_SingleObject$Type extends MessageType<CMsgSOMultipleObjects_SingleObject> {
  constructor() {
    super(
      "CMsgSOMultipleObjects.SingleObject",
      [
        {
          no: 1,
          name: "type_id",
          kind: "scalar",
          localName: "type_id",
          opt: true,
          T: 5 /*ScalarType.INT32*/,
        },
        {
          no: 2,
          name: "object_data",
          kind: "scalar",
          localName: "object_data",
          opt: true,
          T: 12 /*ScalarType.BYTES*/,
        },
      ],
      { msgpool_soft_limit: 256, msgpool_hard_limit: 1024 },
    );
  }
  create(value?: PartialMessage<CMsgSOMultipleObjects_SingleObject>): CMsgSOMultipleObjects_SingleObject {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSOMultipleObjects_SingleObject>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSOMultipleObjects_SingleObject,
  ): CMsgSOMultipleObjects_SingleObject {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 type_id */ 1:
          message.type_id = reader.int32();
          break;
        case /* optional bytes object_data */ 2:
          message.object_data = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSOMultipleObjects_SingleObject,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 type_id = 1; */
    if (message.type_id !== undefined) writer.tag(1, WireType.Varint).int32(message.type_id);
    /* optional bytes object_data = 2; */
    if (message.object_data !== undefined) writer.tag(2, WireType.LengthDelimited).bytes(message.object_data);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSOMultipleObjects.SingleObject
 */
export const CMsgSOMultipleObjects_SingleObject = new CMsgSOMultipleObjects_SingleObject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOCacheSubscribed$Type extends MessageType<CMsgSOCacheSubscribed> {
  constructor() {
    super("CMsgSOCacheSubscribed", [
      {
        no: 2,
        name: "objects",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgSOCacheSubscribed_SubscribedType,
      },
      {
        no: 3,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 4,
        name: "owner_soid",
        kind: "message",
        localName: "owner_soid",
        T: () => CMsgSOIDOwner,
      },
      {
        no: 5,
        name: "service_id",
        kind: "scalar",
        localName: "service_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "service_list",
        kind: "scalar",
        localName: "service_list",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 7,
        name: "sync_version",
        kind: "scalar",
        localName: "sync_version",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSOCacheSubscribed>): CMsgSOCacheSubscribed {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.objects = [];
    message.service_list = [];
    if (value !== undefined) reflectionMergePartial<CMsgSOCacheSubscribed>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSOCacheSubscribed,
  ): CMsgSOCacheSubscribed {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CMsgSOCacheSubscribed.SubscribedType objects */ 2:
          message.objects.push(
            CMsgSOCacheSubscribed_SubscribedType.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* optional fixed64 version */ 3:
          message.version = reader.fixed64().toBigInt();
          break;
        case /* optional CMsgSOIDOwner owner_soid */ 4:
          message.owner_soid = CMsgSOIDOwner.internalBinaryRead(reader, reader.uint32(), options, message.owner_soid);
          break;
        case /* optional uint32 service_id */ 5:
          message.service_id = reader.uint32();
          break;
        case /* repeated uint32 service_list */ 6:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.service_list.push(reader.uint32());
          else message.service_list.push(reader.uint32());
          break;
        case /* optional fixed64 sync_version */ 7:
          message.sync_version = reader.fixed64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSOCacheSubscribed,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CMsgSOCacheSubscribed.SubscribedType objects = 2; */
    for (let i = 0; i < message.objects.length; i++)
      CMsgSOCacheSubscribed_SubscribedType.internalBinaryWrite(
        message.objects[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional fixed64 version = 3; */
    if (message.version !== undefined) writer.tag(3, WireType.Bit64).fixed64(message.version);
    /* optional CMsgSOIDOwner owner_soid = 4; */
    if (message.owner_soid)
      CMsgSOIDOwner.internalBinaryWrite(
        message.owner_soid,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 service_id = 5; */
    if (message.service_id !== undefined) writer.tag(5, WireType.Varint).uint32(message.service_id);
    /* repeated uint32 service_list = 6; */
    for (let i = 0; i < message.service_list.length; i++)
      writer.tag(6, WireType.Varint).uint32(message.service_list[i]);
    /* optional fixed64 sync_version = 7; */
    if (message.sync_version !== undefined) writer.tag(7, WireType.Bit64).fixed64(message.sync_version);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSOCacheSubscribed
 */
export const CMsgSOCacheSubscribed = new CMsgSOCacheSubscribed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOCacheSubscribed_SubscribedType$Type extends MessageType<CMsgSOCacheSubscribed_SubscribedType> {
  constructor() {
    super("CMsgSOCacheSubscribed.SubscribedType", [
      {
        no: 1,
        name: "type_id",
        kind: "scalar",
        localName: "type_id",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "object_data",
        kind: "scalar",
        localName: "object_data",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSOCacheSubscribed_SubscribedType>): CMsgSOCacheSubscribed_SubscribedType {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.object_data = [];
    if (value !== undefined) reflectionMergePartial<CMsgSOCacheSubscribed_SubscribedType>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSOCacheSubscribed_SubscribedType,
  ): CMsgSOCacheSubscribed_SubscribedType {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 type_id */ 1:
          message.type_id = reader.int32();
          break;
        case /* repeated bytes object_data */ 2:
          message.object_data.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSOCacheSubscribed_SubscribedType,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 type_id = 1; */
    if (message.type_id !== undefined) writer.tag(1, WireType.Varint).int32(message.type_id);
    /* repeated bytes object_data = 2; */
    for (let i = 0; i < message.object_data.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.object_data[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSOCacheSubscribed.SubscribedType
 */
export const CMsgSOCacheSubscribed_SubscribedType = new CMsgSOCacheSubscribed_SubscribedType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOCacheSubscribedUpToDate$Type extends MessageType<CMsgSOCacheSubscribedUpToDate> {
  constructor() {
    super("CMsgSOCacheSubscribedUpToDate", [
      {
        no: 1,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "owner_soid",
        kind: "message",
        localName: "owner_soid",
        T: () => CMsgSOIDOwner,
      },
      {
        no: 3,
        name: "service_id",
        kind: "scalar",
        localName: "service_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "service_list",
        kind: "scalar",
        localName: "service_list",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "sync_version",
        kind: "scalar",
        localName: "sync_version",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSOCacheSubscribedUpToDate>): CMsgSOCacheSubscribedUpToDate {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.service_list = [];
    if (value !== undefined) reflectionMergePartial<CMsgSOCacheSubscribedUpToDate>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSOCacheSubscribedUpToDate,
  ): CMsgSOCacheSubscribedUpToDate {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 version */ 1:
          message.version = reader.fixed64().toBigInt();
          break;
        case /* optional CMsgSOIDOwner owner_soid */ 2:
          message.owner_soid = CMsgSOIDOwner.internalBinaryRead(reader, reader.uint32(), options, message.owner_soid);
          break;
        case /* optional uint32 service_id */ 3:
          message.service_id = reader.uint32();
          break;
        case /* repeated uint32 service_list */ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.service_list.push(reader.uint32());
          else message.service_list.push(reader.uint32());
          break;
        case /* optional fixed64 sync_version */ 5:
          message.sync_version = reader.fixed64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSOCacheSubscribedUpToDate,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed64 version = 1; */
    if (message.version !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.version);
    /* optional CMsgSOIDOwner owner_soid = 2; */
    if (message.owner_soid)
      CMsgSOIDOwner.internalBinaryWrite(
        message.owner_soid,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 service_id = 3; */
    if (message.service_id !== undefined) writer.tag(3, WireType.Varint).uint32(message.service_id);
    /* repeated uint32 service_list = 4; */
    for (let i = 0; i < message.service_list.length; i++)
      writer.tag(4, WireType.Varint).uint32(message.service_list[i]);
    /* optional fixed64 sync_version = 5; */
    if (message.sync_version !== undefined) writer.tag(5, WireType.Bit64).fixed64(message.sync_version);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSOCacheSubscribedUpToDate
 */
export const CMsgSOCacheSubscribedUpToDate = new CMsgSOCacheSubscribedUpToDate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOCacheUnsubscribed$Type extends MessageType<CMsgSOCacheUnsubscribed> {
  constructor() {
    super("CMsgSOCacheUnsubscribed", [
      {
        no: 2,
        name: "owner_soid",
        kind: "message",
        localName: "owner_soid",
        T: () => CMsgSOIDOwner,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSOCacheUnsubscribed>): CMsgSOCacheUnsubscribed {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSOCacheUnsubscribed>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSOCacheUnsubscribed,
  ): CMsgSOCacheUnsubscribed {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgSOIDOwner owner_soid */ 2:
          message.owner_soid = CMsgSOIDOwner.internalBinaryRead(reader, reader.uint32(), options, message.owner_soid);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSOCacheUnsubscribed,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgSOIDOwner owner_soid = 2; */
    if (message.owner_soid)
      CMsgSOIDOwner.internalBinaryWrite(
        message.owner_soid,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSOCacheUnsubscribed
 */
export const CMsgSOCacheUnsubscribed = new CMsgSOCacheUnsubscribed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOCacheSubscriptionCheck$Type extends MessageType<CMsgSOCacheSubscriptionCheck> {
  constructor() {
    super("CMsgSOCacheSubscriptionCheck", [
      {
        no: 2,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "owner_soid",
        kind: "message",
        localName: "owner_soid",
        T: () => CMsgSOIDOwner,
      },
      {
        no: 4,
        name: "service_id",
        kind: "scalar",
        localName: "service_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "service_list",
        kind: "scalar",
        localName: "service_list",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "sync_version",
        kind: "scalar",
        localName: "sync_version",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSOCacheSubscriptionCheck>): CMsgSOCacheSubscriptionCheck {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.service_list = [];
    if (value !== undefined) reflectionMergePartial<CMsgSOCacheSubscriptionCheck>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSOCacheSubscriptionCheck,
  ): CMsgSOCacheSubscriptionCheck {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 version */ 2:
          message.version = reader.fixed64().toBigInt();
          break;
        case /* optional CMsgSOIDOwner owner_soid */ 3:
          message.owner_soid = CMsgSOIDOwner.internalBinaryRead(reader, reader.uint32(), options, message.owner_soid);
          break;
        case /* optional uint32 service_id */ 4:
          message.service_id = reader.uint32();
          break;
        case /* repeated uint32 service_list */ 5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.service_list.push(reader.uint32());
          else message.service_list.push(reader.uint32());
          break;
        case /* optional fixed64 sync_version */ 6:
          message.sync_version = reader.fixed64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSOCacheSubscriptionCheck,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed64 version = 2; */
    if (message.version !== undefined) writer.tag(2, WireType.Bit64).fixed64(message.version);
    /* optional CMsgSOIDOwner owner_soid = 3; */
    if (message.owner_soid)
      CMsgSOIDOwner.internalBinaryWrite(
        message.owner_soid,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 service_id = 4; */
    if (message.service_id !== undefined) writer.tag(4, WireType.Varint).uint32(message.service_id);
    /* repeated uint32 service_list = 5; */
    for (let i = 0; i < message.service_list.length; i++)
      writer.tag(5, WireType.Varint).uint32(message.service_list[i]);
    /* optional fixed64 sync_version = 6; */
    if (message.sync_version !== undefined) writer.tag(6, WireType.Bit64).fixed64(message.sync_version);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSOCacheSubscriptionCheck
 */
export const CMsgSOCacheSubscriptionCheck = new CMsgSOCacheSubscriptionCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOCacheSubscriptionRefresh$Type extends MessageType<CMsgSOCacheSubscriptionRefresh> {
  constructor() {
    super("CMsgSOCacheSubscriptionRefresh", [
      {
        no: 2,
        name: "owner_soid",
        kind: "message",
        localName: "owner_soid",
        T: () => CMsgSOIDOwner,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSOCacheSubscriptionRefresh>): CMsgSOCacheSubscriptionRefresh {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSOCacheSubscriptionRefresh>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSOCacheSubscriptionRefresh,
  ): CMsgSOCacheSubscriptionRefresh {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgSOIDOwner owner_soid */ 2:
          message.owner_soid = CMsgSOIDOwner.internalBinaryRead(reader, reader.uint32(), options, message.owner_soid);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSOCacheSubscriptionRefresh,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgSOIDOwner owner_soid = 2; */
    if (message.owner_soid)
      CMsgSOIDOwner.internalBinaryWrite(
        message.owner_soid,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSOCacheSubscriptionRefresh
 */
export const CMsgSOCacheSubscriptionRefresh = new CMsgSOCacheSubscriptionRefresh$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOCacheVersion$Type extends MessageType<CMsgSOCacheVersion> {
  constructor() {
    super("CMsgSOCacheVersion", [
      {
        no: 1,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSOCacheVersion>): CMsgSOCacheVersion {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSOCacheVersion>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSOCacheVersion,
  ): CMsgSOCacheVersion {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 version */ 1:
          message.version = reader.fixed64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgSOCacheVersion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional fixed64 version = 1; */
    if (message.version !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.version);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSOCacheVersion
 */
export const CMsgSOCacheVersion = new CMsgSOCacheVersion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMultiplexMessage$Type extends MessageType<CMsgGCMultiplexMessage> {
  constructor() {
    super("CMsgGCMultiplexMessage", [
      {
        no: 1,
        name: "msgtype",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "payload",
        kind: "scalar",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 3,
        name: "steamids",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCMultiplexMessage>): CMsgGCMultiplexMessage {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.steamids = [];
    if (value !== undefined) reflectionMergePartial<CMsgGCMultiplexMessage>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCMultiplexMessage,
  ): CMsgGCMultiplexMessage {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 msgtype */ 1:
          message.msgtype = reader.uint32();
          break;
        case /* optional bytes payload */ 2:
          message.payload = reader.bytes();
          break;
        case /* repeated fixed64 steamids */ 3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.steamids.push(reader.fixed64().toBigInt());
          else message.steamids.push(reader.fixed64().toBigInt());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCMultiplexMessage,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 msgtype = 1; */
    if (message.msgtype !== undefined) writer.tag(1, WireType.Varint).uint32(message.msgtype);
    /* optional bytes payload = 2; */
    if (message.payload !== undefined) writer.tag(2, WireType.LengthDelimited).bytes(message.payload);
    /* repeated fixed64 steamids = 3; */
    for (let i = 0; i < message.steamids.length; i++) writer.tag(3, WireType.Bit64).fixed64(message.steamids[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCMultiplexMessage
 */
export const CMsgGCMultiplexMessage = new CMsgGCMultiplexMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCSubGCStarting$Type extends MessageType<CMsgGCToGCSubGCStarting> {
  constructor() {
    super("CMsgGCToGCSubGCStarting", [
      {
        no: 1,
        name: "dir_index",
        kind: "scalar",
        localName: "dir_index",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCSubGCStarting>): CMsgGCToGCSubGCStarting {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCSubGCStarting>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCSubGCStarting,
  ): CMsgGCToGCSubGCStarting {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 dir_index */ 1:
          message.dir_index = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCSubGCStarting,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 dir_index = 1; */
    if (message.dir_index !== undefined) writer.tag(1, WireType.Varint).int32(message.dir_index);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCSubGCStarting
 */
export const CMsgGCToGCSubGCStarting = new CMsgGCToGCSubGCStarting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCToGCMsgMasterAck$Type extends MessageType<CGCToGCMsgMasterAck> {
  constructor() {
    super("CGCToGCMsgMasterAck", [
      {
        no: 1,
        name: "dir_index",
        kind: "scalar",
        localName: "dir_index",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "machine_name",
        kind: "scalar",
        localName: "machine_name",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: "process_name",
        kind: "scalar",
        localName: "process_name",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 6,
        name: "directory",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CGCToGCMsgMasterAck_Process,
      },
    ]);
  }
  create(value?: PartialMessage<CGCToGCMsgMasterAck>): CGCToGCMsgMasterAck {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.directory = [];
    if (value !== undefined) reflectionMergePartial<CGCToGCMsgMasterAck>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CGCToGCMsgMasterAck,
  ): CGCToGCMsgMasterAck {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 dir_index */ 1:
          message.dir_index = reader.int32();
          break;
        case /* optional string machine_name */ 3:
          message.machine_name = reader.string();
          break;
        case /* optional string process_name */ 4:
          message.process_name = reader.string();
          break;
        case /* repeated CGCToGCMsgMasterAck.Process directory */ 6:
          message.directory.push(CGCToGCMsgMasterAck_Process.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CGCToGCMsgMasterAck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional int32 dir_index = 1; */
    if (message.dir_index !== undefined) writer.tag(1, WireType.Varint).int32(message.dir_index);
    /* optional string machine_name = 3; */
    if (message.machine_name !== undefined) writer.tag(3, WireType.LengthDelimited).string(message.machine_name);
    /* optional string process_name = 4; */
    if (message.process_name !== undefined) writer.tag(4, WireType.LengthDelimited).string(message.process_name);
    /* repeated CGCToGCMsgMasterAck.Process directory = 6; */
    for (let i = 0; i < message.directory.length; i++)
      CGCToGCMsgMasterAck_Process.internalBinaryWrite(
        message.directory[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CGCToGCMsgMasterAck
 */
export const CGCToGCMsgMasterAck = new CGCToGCMsgMasterAck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCToGCMsgMasterAck_Process$Type extends MessageType<CGCToGCMsgMasterAck_Process> {
  constructor() {
    super("CGCToGCMsgMasterAck.Process", [
      {
        no: 1,
        name: "dir_index",
        kind: "scalar",
        localName: "dir_index",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "type_instances",
        kind: "scalar",
        localName: "type_instances",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CGCToGCMsgMasterAck_Process>): CGCToGCMsgMasterAck_Process {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.type_instances = [];
    if (value !== undefined) reflectionMergePartial<CGCToGCMsgMasterAck_Process>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CGCToGCMsgMasterAck_Process,
  ): CGCToGCMsgMasterAck_Process {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 dir_index */ 1:
          message.dir_index = reader.int32();
          break;
        case /* repeated uint32 type_instances */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.type_instances.push(reader.uint32());
          else message.type_instances.push(reader.uint32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CGCToGCMsgMasterAck_Process,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 dir_index = 1; */
    if (message.dir_index !== undefined) writer.tag(1, WireType.Varint).int32(message.dir_index);
    /* repeated uint32 type_instances = 2; */
    for (let i = 0; i < message.type_instances.length; i++)
      writer.tag(2, WireType.Varint).uint32(message.type_instances[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CGCToGCMsgMasterAck.Process
 */
export const CGCToGCMsgMasterAck_Process = new CGCToGCMsgMasterAck_Process$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCToGCMsgMasterAck_Response$Type extends MessageType<CGCToGCMsgMasterAck_Response> {
  constructor() {
    super("CGCToGCMsgMasterAck_Response", [
      {
        no: 1,
        name: "eresult",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CGCToGCMsgMasterAck_Response>): CGCToGCMsgMasterAck_Response {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CGCToGCMsgMasterAck_Response>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CGCToGCMsgMasterAck_Response,
  ): CGCToGCMsgMasterAck_Response {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 eresult */ 1:
          message.eresult = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CGCToGCMsgMasterAck_Response,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 eresult = 1; */
    if (message.eresult !== undefined) writer.tag(1, WireType.Varint).int32(message.eresult);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CGCToGCMsgMasterAck_Response
 */
export const CGCToGCMsgMasterAck_Response = new CGCToGCMsgMasterAck_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCUniverseStartup$Type extends MessageType<CMsgGCToGCUniverseStartup> {
  constructor() {
    super("CMsgGCToGCUniverseStartup", [
      {
        no: 1,
        name: "is_initial_startup",
        kind: "scalar",
        localName: "is_initial_startup",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCUniverseStartup>): CMsgGCToGCUniverseStartup {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCUniverseStartup>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCUniverseStartup,
  ): CMsgGCToGCUniverseStartup {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bool is_initial_startup */ 1:
          message.is_initial_startup = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCUniverseStartup,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional bool is_initial_startup = 1; */
    if (message.is_initial_startup !== undefined) writer.tag(1, WireType.Varint).bool(message.is_initial_startup);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCUniverseStartup
 */
export const CMsgGCToGCUniverseStartup = new CMsgGCToGCUniverseStartup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCUniverseStartupResponse$Type extends MessageType<CMsgGCToGCUniverseStartupResponse> {
  constructor() {
    super("CMsgGCToGCUniverseStartupResponse", [
      {
        no: 1,
        name: "eresult",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCUniverseStartupResponse>): CMsgGCToGCUniverseStartupResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCUniverseStartupResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCUniverseStartupResponse,
  ): CMsgGCToGCUniverseStartupResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 eresult */ 1:
          message.eresult = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCUniverseStartupResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 eresult = 1; */
    if (message.eresult !== undefined) writer.tag(1, WireType.Varint).int32(message.eresult);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCUniverseStartupResponse
 */
export const CMsgGCToGCUniverseStartupResponse = new CMsgGCToGCUniverseStartupResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCToGCMsgMasterStartupComplete$Type extends MessageType<CGCToGCMsgMasterStartupComplete> {
  constructor() {
    super("CGCToGCMsgMasterStartupComplete", [
      {
        no: 1,
        name: "gc_info",
        kind: "message",
        localName: "gc_info",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CGCToGCMsgMasterStartupComplete_GCInfo,
      },
    ]);
  }
  create(value?: PartialMessage<CGCToGCMsgMasterStartupComplete>): CGCToGCMsgMasterStartupComplete {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.gc_info = [];
    if (value !== undefined) reflectionMergePartial<CGCToGCMsgMasterStartupComplete>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CGCToGCMsgMasterStartupComplete,
  ): CGCToGCMsgMasterStartupComplete {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CGCToGCMsgMasterStartupComplete.GCInfo gc_info */ 1:
          message.gc_info.push(
            CGCToGCMsgMasterStartupComplete_GCInfo.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CGCToGCMsgMasterStartupComplete,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CGCToGCMsgMasterStartupComplete.GCInfo gc_info = 1; */
    for (let i = 0; i < message.gc_info.length; i++)
      CGCToGCMsgMasterStartupComplete_GCInfo.internalBinaryWrite(
        message.gc_info[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CGCToGCMsgMasterStartupComplete
 */
export const CGCToGCMsgMasterStartupComplete = new CGCToGCMsgMasterStartupComplete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCToGCMsgMasterStartupComplete_GCInfo$Type extends MessageType<CGCToGCMsgMasterStartupComplete_GCInfo> {
  constructor() {
    super("CGCToGCMsgMasterStartupComplete.GCInfo", [
      {
        no: 1,
        name: "dir_index",
        kind: "scalar",
        localName: "dir_index",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "machine_name",
        kind: "scalar",
        localName: "machine_name",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<CGCToGCMsgMasterStartupComplete_GCInfo>): CGCToGCMsgMasterStartupComplete_GCInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CGCToGCMsgMasterStartupComplete_GCInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CGCToGCMsgMasterStartupComplete_GCInfo,
  ): CGCToGCMsgMasterStartupComplete_GCInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 dir_index */ 1:
          message.dir_index = reader.int32();
          break;
        case /* optional string machine_name */ 2:
          message.machine_name = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CGCToGCMsgMasterStartupComplete_GCInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 dir_index = 1; */
    if (message.dir_index !== undefined) writer.tag(1, WireType.Varint).int32(message.dir_index);
    /* optional string machine_name = 2; */
    if (message.machine_name !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.machine_name);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CGCToGCMsgMasterStartupComplete.GCInfo
 */
export const CGCToGCMsgMasterStartupComplete_GCInfo = new CGCToGCMsgMasterStartupComplete_GCInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCToGCMsgRouted$Type extends MessageType<CGCToGCMsgRouted> {
  constructor() {
    super("CGCToGCMsgRouted", [
      {
        no: 1,
        name: "msg_type",
        kind: "scalar",
        localName: "msg_type",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "sender_id",
        kind: "scalar",
        localName: "sender_id",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "net_message",
        kind: "scalar",
        localName: "net_message",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<CGCToGCMsgRouted>): CGCToGCMsgRouted {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CGCToGCMsgRouted>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CGCToGCMsgRouted,
  ): CGCToGCMsgRouted {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 msg_type */ 1:
          message.msg_type = reader.uint32();
          break;
        case /* optional fixed64 sender_id */ 2:
          message.sender_id = reader.fixed64().toBigInt();
          break;
        case /* optional bytes net_message */ 3:
          message.net_message = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CGCToGCMsgRouted, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional uint32 msg_type = 1; */
    if (message.msg_type !== undefined) writer.tag(1, WireType.Varint).uint32(message.msg_type);
    /* optional fixed64 sender_id = 2; */
    if (message.sender_id !== undefined) writer.tag(2, WireType.Bit64).fixed64(message.sender_id);
    /* optional bytes net_message = 3; */
    if (message.net_message !== undefined) writer.tag(3, WireType.LengthDelimited).bytes(message.net_message);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CGCToGCMsgRouted
 */
export const CGCToGCMsgRouted = new CGCToGCMsgRouted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCToGCMsgRoutedReply$Type extends MessageType<CGCToGCMsgRoutedReply> {
  constructor() {
    super("CGCToGCMsgRoutedReply", [
      {
        no: 1,
        name: "msg_type",
        kind: "scalar",
        localName: "msg_type",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "net_message",
        kind: "scalar",
        localName: "net_message",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<CGCToGCMsgRoutedReply>): CGCToGCMsgRoutedReply {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CGCToGCMsgRoutedReply>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CGCToGCMsgRoutedReply,
  ): CGCToGCMsgRoutedReply {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 msg_type */ 1:
          message.msg_type = reader.uint32();
          break;
        case /* optional bytes net_message */ 2:
          message.net_message = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CGCToGCMsgRoutedReply,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 msg_type = 1; */
    if (message.msg_type !== undefined) writer.tag(1, WireType.Varint).uint32(message.msg_type);
    /* optional bytes net_message = 2; */
    if (message.net_message !== undefined) writer.tag(2, WireType.LengthDelimited).bytes(message.net_message);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CGCToGCMsgRoutedReply
 */
export const CGCToGCMsgRoutedReply = new CGCToGCMsgRoutedReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCUpdateSubGCSessionInfo$Type extends MessageType<CMsgGCUpdateSubGCSessionInfo> {
  constructor() {
    super("CMsgGCUpdateSubGCSessionInfo", [
      {
        no: 1,
        name: "updates",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgGCUpdateSubGCSessionInfo_CMsgUpdate,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCUpdateSubGCSessionInfo>): CMsgGCUpdateSubGCSessionInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.updates = [];
    if (value !== undefined) reflectionMergePartial<CMsgGCUpdateSubGCSessionInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCUpdateSubGCSessionInfo,
  ): CMsgGCUpdateSubGCSessionInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CMsgGCUpdateSubGCSessionInfo.CMsgUpdate updates */ 1:
          message.updates.push(
            CMsgGCUpdateSubGCSessionInfo_CMsgUpdate.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCUpdateSubGCSessionInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CMsgGCUpdateSubGCSessionInfo.CMsgUpdate updates = 1; */
    for (let i = 0; i < message.updates.length; i++)
      CMsgGCUpdateSubGCSessionInfo_CMsgUpdate.internalBinaryWrite(
        message.updates[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCUpdateSubGCSessionInfo
 */
export const CMsgGCUpdateSubGCSessionInfo = new CMsgGCUpdateSubGCSessionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCUpdateSubGCSessionInfo_CMsgUpdate$Type extends MessageType<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate> {
  constructor() {
    super("CMsgGCUpdateSubGCSessionInfo.CMsgUpdate", [
      {
        no: 1,
        name: "steamid",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "ip",
        kind: "scalar",
        opt: true,
        T: 7 /*ScalarType.FIXED32*/,
      },
      {
        no: 3,
        name: "trusted",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate>): CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCUpdateSubGCSessionInfo_CMsgUpdate,
  ): CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 steamid */ 1:
          message.steamid = reader.fixed64().toBigInt();
          break;
        case /* optional fixed32 ip */ 2:
          message.ip = reader.fixed32();
          break;
        case /* optional bool trusted */ 3:
          message.trusted = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCUpdateSubGCSessionInfo_CMsgUpdate,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed64 steamid = 1; */
    if (message.steamid !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steamid);
    /* optional fixed32 ip = 2; */
    if (message.ip !== undefined) writer.tag(2, WireType.Bit32).fixed32(message.ip);
    /* optional bool trusted = 3; */
    if (message.trusted !== undefined) writer.tag(3, WireType.Varint).bool(message.trusted);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCUpdateSubGCSessionInfo.CMsgUpdate
 */
export const CMsgGCUpdateSubGCSessionInfo_CMsgUpdate = new CMsgGCUpdateSubGCSessionInfo_CMsgUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCRequestSubGCSessionInfo$Type extends MessageType<CMsgGCRequestSubGCSessionInfo> {
  constructor() {
    super("CMsgGCRequestSubGCSessionInfo", [
      {
        no: 1,
        name: "steamid",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCRequestSubGCSessionInfo>): CMsgGCRequestSubGCSessionInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCRequestSubGCSessionInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCRequestSubGCSessionInfo,
  ): CMsgGCRequestSubGCSessionInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 steamid */ 1:
          message.steamid = reader.fixed64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCRequestSubGCSessionInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed64 steamid = 1; */
    if (message.steamid !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steamid);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCRequestSubGCSessionInfo
 */
export const CMsgGCRequestSubGCSessionInfo = new CMsgGCRequestSubGCSessionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCRequestSubGCSessionInfoResponse$Type extends MessageType<CMsgGCRequestSubGCSessionInfoResponse> {
  constructor() {
    super("CMsgGCRequestSubGCSessionInfoResponse", [
      {
        no: 1,
        name: "ip",
        kind: "scalar",
        opt: true,
        T: 7 /*ScalarType.FIXED32*/,
      },
      {
        no: 2,
        name: "trusted",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 3,
        name: "port",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "success",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCRequestSubGCSessionInfoResponse>): CMsgGCRequestSubGCSessionInfoResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCRequestSubGCSessionInfoResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCRequestSubGCSessionInfoResponse,
  ): CMsgGCRequestSubGCSessionInfoResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed32 ip */ 1:
          message.ip = reader.fixed32();
          break;
        case /* optional bool trusted */ 2:
          message.trusted = reader.bool();
          break;
        case /* optional uint32 port */ 3:
          message.port = reader.uint32();
          break;
        case /* optional bool success */ 4:
          message.success = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCRequestSubGCSessionInfoResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed32 ip = 1; */
    if (message.ip !== undefined) writer.tag(1, WireType.Bit32).fixed32(message.ip);
    /* optional bool trusted = 2; */
    if (message.trusted !== undefined) writer.tag(2, WireType.Varint).bool(message.trusted);
    /* optional uint32 port = 3; */
    if (message.port !== undefined) writer.tag(3, WireType.Varint).uint32(message.port);
    /* optional bool success = 4; */
    if (message.success !== undefined) writer.tag(4, WireType.Varint).bool(message.success);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCRequestSubGCSessionInfoResponse
 */
export const CMsgGCRequestSubGCSessionInfoResponse = new CMsgGCRequestSubGCSessionInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOCacheHaveVersion$Type extends MessageType<CMsgSOCacheHaveVersion> {
  constructor() {
    super("CMsgSOCacheHaveVersion", [
      { no: 1, name: "soid", kind: "message", T: () => CMsgSOIDOwner },
      {
        no: 2,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "service_id",
        kind: "scalar",
        localName: "service_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "cached_file_version",
        kind: "scalar",
        localName: "cached_file_version",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSOCacheHaveVersion>): CMsgSOCacheHaveVersion {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSOCacheHaveVersion>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSOCacheHaveVersion,
  ): CMsgSOCacheHaveVersion {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgSOIDOwner soid */ 1:
          message.soid = CMsgSOIDOwner.internalBinaryRead(reader, reader.uint32(), options, message.soid);
          break;
        case /* optional fixed64 version */ 2:
          message.version = reader.fixed64().toBigInt();
          break;
        case /* optional uint32 service_id */ 3:
          message.service_id = reader.uint32();
          break;
        case /* optional uint32 cached_file_version */ 4:
          message.cached_file_version = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSOCacheHaveVersion,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgSOIDOwner soid = 1; */
    if (message.soid)
      CMsgSOIDOwner.internalBinaryWrite(message.soid, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    /* optional fixed64 version = 2; */
    if (message.version !== undefined) writer.tag(2, WireType.Bit64).fixed64(message.version);
    /* optional uint32 service_id = 3; */
    if (message.service_id !== undefined) writer.tag(3, WireType.Varint).uint32(message.service_id);
    /* optional uint32 cached_file_version = 4; */
    if (message.cached_file_version !== undefined) writer.tag(4, WireType.Varint).uint32(message.cached_file_version);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSOCacheHaveVersion
 */
export const CMsgSOCacheHaveVersion = new CMsgSOCacheHaveVersion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientHello$Type extends MessageType<CMsgClientHello> {
  constructor() {
    super("CMsgClientHello", [
      {
        no: 1,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "socache_have_versions",
        kind: "message",
        localName: "socache_have_versions",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgSOCacheHaveVersion,
      },
      {
        no: 3,
        name: "client_session_need",
        kind: "scalar",
        localName: "client_session_need",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "client_launcher",
        kind: "enum",
        localName: "client_launcher",
        opt: true,
        T: () => ["PartnerAccountType", PartnerAccountType],
      },
      {
        no: 5,
        name: "secret_key",
        kind: "scalar",
        localName: "secret_key",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 6,
        name: "client_language",
        kind: "scalar",
        localName: "client_language",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 7,
        name: "engine",
        kind: "enum",
        opt: true,
        T: () => ["ESourceEngine", ESourceEngine],
      },
      {
        no: 8,
        name: "steamdatagram_login",
        kind: "scalar",
        localName: "steamdatagram_login",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 9,
        name: "platform_id",
        kind: "scalar",
        localName: "platform_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 10,
        name: "game_msg",
        kind: "scalar",
        localName: "game_msg",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 11,
        name: "os_type",
        kind: "scalar",
        localName: "os_type",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 12,
        name: "render_system",
        kind: "scalar",
        localName: "render_system",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 13,
        name: "render_system_req",
        kind: "scalar",
        localName: "render_system_req",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 14,
        name: "screen_width",
        kind: "scalar",
        localName: "screen_width",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 15,
        name: "screen_height",
        kind: "scalar",
        localName: "screen_height",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 16,
        name: "screen_refresh",
        kind: "scalar",
        localName: "screen_refresh",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 17,
        name: "render_width",
        kind: "scalar",
        localName: "render_width",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 18,
        name: "render_height",
        kind: "scalar",
        localName: "render_height",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 19,
        name: "swap_width",
        kind: "scalar",
        localName: "swap_width",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 20,
        name: "swap_height",
        kind: "scalar",
        localName: "swap_height",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 22,
        name: "is_steam_china",
        kind: "scalar",
        localName: "is_steam_china",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 24,
        name: "is_steam_china_client",
        kind: "scalar",
        localName: "is_steam_china_client",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 23,
        name: "platform_name",
        kind: "scalar",
        localName: "platform_name",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgClientHello>): CMsgClientHello {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.socache_have_versions = [];
    if (value !== undefined) reflectionMergePartial<CMsgClientHello>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgClientHello,
  ): CMsgClientHello {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 version */ 1:
          message.version = reader.uint32();
          break;
        case /* repeated CMsgSOCacheHaveVersion socache_have_versions */ 2:
          message.socache_have_versions.push(
            CMsgSOCacheHaveVersion.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* optional uint32 client_session_need */ 3:
          message.client_session_need = reader.uint32();
          break;
        case /* optional PartnerAccountType client_launcher */ 4:
          message.client_launcher = reader.int32();
          break;
        case /* optional string secret_key */ 5:
          message.secret_key = reader.string();
          break;
        case /* optional uint32 client_language */ 6:
          message.client_language = reader.uint32();
          break;
        case /* optional ESourceEngine engine */ 7:
          message.engine = reader.int32();
          break;
        case /* optional bytes steamdatagram_login */ 8:
          message.steamdatagram_login = reader.bytes();
          break;
        case /* optional uint32 platform_id */ 9:
          message.platform_id = reader.uint32();
          break;
        case /* optional bytes game_msg */ 10:
          message.game_msg = reader.bytes();
          break;
        case /* optional int32 os_type */ 11:
          message.os_type = reader.int32();
          break;
        case /* optional uint32 render_system */ 12:
          message.render_system = reader.uint32();
          break;
        case /* optional uint32 render_system_req */ 13:
          message.render_system_req = reader.uint32();
          break;
        case /* optional uint32 screen_width */ 14:
          message.screen_width = reader.uint32();
          break;
        case /* optional uint32 screen_height */ 15:
          message.screen_height = reader.uint32();
          break;
        case /* optional uint32 screen_refresh */ 16:
          message.screen_refresh = reader.uint32();
          break;
        case /* optional uint32 render_width */ 17:
          message.render_width = reader.uint32();
          break;
        case /* optional uint32 render_height */ 18:
          message.render_height = reader.uint32();
          break;
        case /* optional uint32 swap_width */ 19:
          message.swap_width = reader.uint32();
          break;
        case /* optional uint32 swap_height */ 20:
          message.swap_height = reader.uint32();
          break;
        case /* optional bool is_steam_china */ 22:
          message.is_steam_china = reader.bool();
          break;
        case /* optional bool is_steam_china_client */ 24:
          message.is_steam_china_client = reader.bool();
          break;
        case /* optional string platform_name */ 23:
          message.platform_name = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgClientHello, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional uint32 version = 1; */
    if (message.version !== undefined) writer.tag(1, WireType.Varint).uint32(message.version);
    /* repeated CMsgSOCacheHaveVersion socache_have_versions = 2; */
    for (let i = 0; i < message.socache_have_versions.length; i++)
      CMsgSOCacheHaveVersion.internalBinaryWrite(
        message.socache_have_versions[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 client_session_need = 3; */
    if (message.client_session_need !== undefined) writer.tag(3, WireType.Varint).uint32(message.client_session_need);
    /* optional PartnerAccountType client_launcher = 4; */
    if (message.client_launcher !== undefined) writer.tag(4, WireType.Varint).int32(message.client_launcher);
    /* optional string secret_key = 5; */
    if (message.secret_key !== undefined) writer.tag(5, WireType.LengthDelimited).string(message.secret_key);
    /* optional uint32 client_language = 6; */
    if (message.client_language !== undefined) writer.tag(6, WireType.Varint).uint32(message.client_language);
    /* optional ESourceEngine engine = 7; */
    if (message.engine !== undefined) writer.tag(7, WireType.Varint).int32(message.engine);
    /* optional bytes steamdatagram_login = 8; */
    if (message.steamdatagram_login !== undefined)
      writer.tag(8, WireType.LengthDelimited).bytes(message.steamdatagram_login);
    /* optional uint32 platform_id = 9; */
    if (message.platform_id !== undefined) writer.tag(9, WireType.Varint).uint32(message.platform_id);
    /* optional bytes game_msg = 10; */
    if (message.game_msg !== undefined) writer.tag(10, WireType.LengthDelimited).bytes(message.game_msg);
    /* optional int32 os_type = 11; */
    if (message.os_type !== undefined) writer.tag(11, WireType.Varint).int32(message.os_type);
    /* optional uint32 render_system = 12; */
    if (message.render_system !== undefined) writer.tag(12, WireType.Varint).uint32(message.render_system);
    /* optional uint32 render_system_req = 13; */
    if (message.render_system_req !== undefined) writer.tag(13, WireType.Varint).uint32(message.render_system_req);
    /* optional uint32 screen_width = 14; */
    if (message.screen_width !== undefined) writer.tag(14, WireType.Varint).uint32(message.screen_width);
    /* optional uint32 screen_height = 15; */
    if (message.screen_height !== undefined) writer.tag(15, WireType.Varint).uint32(message.screen_height);
    /* optional uint32 screen_refresh = 16; */
    if (message.screen_refresh !== undefined) writer.tag(16, WireType.Varint).uint32(message.screen_refresh);
    /* optional uint32 render_width = 17; */
    if (message.render_width !== undefined) writer.tag(17, WireType.Varint).uint32(message.render_width);
    /* optional uint32 render_height = 18; */
    if (message.render_height !== undefined) writer.tag(18, WireType.Varint).uint32(message.render_height);
    /* optional uint32 swap_width = 19; */
    if (message.swap_width !== undefined) writer.tag(19, WireType.Varint).uint32(message.swap_width);
    /* optional uint32 swap_height = 20; */
    if (message.swap_height !== undefined) writer.tag(20, WireType.Varint).uint32(message.swap_height);
    /* optional bool is_steam_china = 22; */
    if (message.is_steam_china !== undefined) writer.tag(22, WireType.Varint).bool(message.is_steam_china);
    /* optional bool is_steam_china_client = 24; */
    if (message.is_steam_china_client !== undefined)
      writer.tag(24, WireType.Varint).bool(message.is_steam_china_client);
    /* optional string platform_name = 23; */
    if (message.platform_name !== undefined) writer.tag(23, WireType.LengthDelimited).string(message.platform_name);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgClientHello
 */
export const CMsgClientHello = new CMsgClientHello$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientWelcome$Type extends MessageType<CMsgClientWelcome> {
  constructor() {
    super("CMsgClientWelcome", [
      {
        no: 1,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "game_data",
        kind: "scalar",
        localName: "game_data",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 3,
        name: "outofdate_subscribed_caches",
        kind: "message",
        localName: "outofdate_subscribed_caches",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgSOCacheSubscribed,
      },
      {
        no: 4,
        name: "uptodate_subscribed_caches",
        kind: "message",
        localName: "uptodate_subscribed_caches",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgSOCacheSubscriptionCheck,
      },
      {
        no: 5,
        name: "location",
        kind: "message",
        T: () => CMsgClientWelcome_Location,
      },
      {
        no: 9,
        name: "gc_socache_file_version",
        kind: "scalar",
        localName: "gc_socache_file_version",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 10,
        name: "txn_country_code",
        kind: "scalar",
        localName: "txn_country_code",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 11,
        name: "game_data2",
        kind: "scalar",
        localName: "game_data2",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 12,
        name: "rtime32_gc_welcome_timestamp",
        kind: "scalar",
        localName: "rtime32_gc_welcome_timestamp",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 13,
        name: "currency",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 14,
        name: "balance",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 15,
        name: "balance_url",
        kind: "scalar",
        localName: "balance_url",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 16,
        name: "has_accepted_china_ssa",
        kind: "scalar",
        localName: "has_accepted_china_ssa",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 17,
        name: "is_banned_steam_china",
        kind: "scalar",
        localName: "is_banned_steam_china",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 18,
        name: "additional_welcome_msgs",
        kind: "message",
        localName: "additional_welcome_msgs",
        T: () => CExtraMsgBlock,
      },
      {
        no: 20,
        name: "steam_learn_server_info",
        kind: "message",
        localName: "steam_learn_server_info",
        T: () => CMsgSteamLearnServerInfo,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgClientWelcome>): CMsgClientWelcome {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.outofdate_subscribed_caches = [];
    message.uptodate_subscribed_caches = [];
    if (value !== undefined) reflectionMergePartial<CMsgClientWelcome>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgClientWelcome,
  ): CMsgClientWelcome {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 version */ 1:
          message.version = reader.uint32();
          break;
        case /* optional bytes game_data */ 2:
          message.game_data = reader.bytes();
          break;
        case /* repeated CMsgSOCacheSubscribed outofdate_subscribed_caches */ 3:
          message.outofdate_subscribed_caches.push(
            CMsgSOCacheSubscribed.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated CMsgSOCacheSubscriptionCheck uptodate_subscribed_caches */ 4:
          message.uptodate_subscribed_caches.push(
            CMsgSOCacheSubscriptionCheck.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* optional CMsgClientWelcome.Location location */ 5:
          message.location = CMsgClientWelcome_Location.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.location,
          );
          break;
        case /* optional uint32 gc_socache_file_version */ 9:
          message.gc_socache_file_version = reader.uint32();
          break;
        case /* optional string txn_country_code */ 10:
          message.txn_country_code = reader.string();
          break;
        case /* optional bytes game_data2 */ 11:
          message.game_data2 = reader.bytes();
          break;
        case /* optional uint32 rtime32_gc_welcome_timestamp */ 12:
          message.rtime32_gc_welcome_timestamp = reader.uint32();
          break;
        case /* optional uint32 currency */ 13:
          message.currency = reader.uint32();
          break;
        case /* optional uint32 balance */ 14:
          message.balance = reader.uint32();
          break;
        case /* optional string balance_url */ 15:
          message.balance_url = reader.string();
          break;
        case /* optional bool has_accepted_china_ssa */ 16:
          message.has_accepted_china_ssa = reader.bool();
          break;
        case /* optional bool is_banned_steam_china */ 17:
          message.is_banned_steam_china = reader.bool();
          break;
        case /* optional CExtraMsgBlock additional_welcome_msgs */ 18:
          message.additional_welcome_msgs = CExtraMsgBlock.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.additional_welcome_msgs,
          );
          break;
        case /* optional CMsgSteamLearnServerInfo steam_learn_server_info */ 20:
          message.steam_learn_server_info = CMsgSteamLearnServerInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.steam_learn_server_info,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CMsgClientWelcome, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* optional uint32 version = 1; */
    if (message.version !== undefined) writer.tag(1, WireType.Varint).uint32(message.version);
    /* optional bytes game_data = 2; */
    if (message.game_data !== undefined) writer.tag(2, WireType.LengthDelimited).bytes(message.game_data);
    /* repeated CMsgSOCacheSubscribed outofdate_subscribed_caches = 3; */
    for (let i = 0; i < message.outofdate_subscribed_caches.length; i++)
      CMsgSOCacheSubscribed.internalBinaryWrite(
        message.outofdate_subscribed_caches[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated CMsgSOCacheSubscriptionCheck uptodate_subscribed_caches = 4; */
    for (let i = 0; i < message.uptodate_subscribed_caches.length; i++)
      CMsgSOCacheSubscriptionCheck.internalBinaryWrite(
        message.uptodate_subscribed_caches[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgClientWelcome.Location location = 5; */
    if (message.location)
      CMsgClientWelcome_Location.internalBinaryWrite(
        message.location,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 gc_socache_file_version = 9; */
    if (message.gc_socache_file_version !== undefined)
      writer.tag(9, WireType.Varint).uint32(message.gc_socache_file_version);
    /* optional string txn_country_code = 10; */
    if (message.txn_country_code !== undefined)
      writer.tag(10, WireType.LengthDelimited).string(message.txn_country_code);
    /* optional bytes game_data2 = 11; */
    if (message.game_data2 !== undefined) writer.tag(11, WireType.LengthDelimited).bytes(message.game_data2);
    /* optional uint32 rtime32_gc_welcome_timestamp = 12; */
    if (message.rtime32_gc_welcome_timestamp !== undefined)
      writer.tag(12, WireType.Varint).uint32(message.rtime32_gc_welcome_timestamp);
    /* optional uint32 currency = 13; */
    if (message.currency !== undefined) writer.tag(13, WireType.Varint).uint32(message.currency);
    /* optional uint32 balance = 14; */
    if (message.balance !== undefined) writer.tag(14, WireType.Varint).uint32(message.balance);
    /* optional string balance_url = 15; */
    if (message.balance_url !== undefined) writer.tag(15, WireType.LengthDelimited).string(message.balance_url);
    /* optional bool has_accepted_china_ssa = 16; */
    if (message.has_accepted_china_ssa !== undefined)
      writer.tag(16, WireType.Varint).bool(message.has_accepted_china_ssa);
    /* optional bool is_banned_steam_china = 17; */
    if (message.is_banned_steam_china !== undefined)
      writer.tag(17, WireType.Varint).bool(message.is_banned_steam_china);
    /* optional CExtraMsgBlock additional_welcome_msgs = 18; */
    if (message.additional_welcome_msgs)
      CExtraMsgBlock.internalBinaryWrite(
        message.additional_welcome_msgs,
        writer.tag(18, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgSteamLearnServerInfo steam_learn_server_info = 20; */
    if (message.steam_learn_server_info)
      CMsgSteamLearnServerInfo.internalBinaryWrite(
        message.steam_learn_server_info,
        writer.tag(20, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgClientWelcome
 */
export const CMsgClientWelcome = new CMsgClientWelcome$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientWelcome_Location$Type extends MessageType<CMsgClientWelcome_Location> {
  constructor() {
    super("CMsgClientWelcome.Location", [
      {
        no: 1,
        name: "latitude",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 2,
        name: "longitude",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 3,
        name: "country",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgClientWelcome_Location>): CMsgClientWelcome_Location {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgClientWelcome_Location>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgClientWelcome_Location,
  ): CMsgClientWelcome_Location {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional float latitude */ 1:
          message.latitude = reader.float();
          break;
        case /* optional float longitude */ 2:
          message.longitude = reader.float();
          break;
        case /* optional string country */ 3:
          message.country = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgClientWelcome_Location,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional float latitude = 1; */
    if (message.latitude !== undefined) writer.tag(1, WireType.Bit32).float(message.latitude);
    /* optional float longitude = 2; */
    if (message.longitude !== undefined) writer.tag(2, WireType.Bit32).float(message.longitude);
    /* optional string country = 3; */
    if (message.country !== undefined) writer.tag(3, WireType.LengthDelimited).string(message.country);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgClientWelcome.Location
 */
export const CMsgClientWelcome_Location = new CMsgClientWelcome_Location$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgConnectionStatus$Type extends MessageType<CMsgConnectionStatus> {
  constructor() {
    super("CMsgConnectionStatus", [
      {
        no: 1,
        name: "status",
        kind: "enum",
        opt: true,
        T: () => ["GCConnectionStatus", GCConnectionStatus],
      },
      {
        no: 2,
        name: "client_session_need",
        kind: "scalar",
        localName: "client_session_need",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "queue_position",
        kind: "scalar",
        localName: "queue_position",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 4,
        name: "queue_size",
        kind: "scalar",
        localName: "queue_size",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 5,
        name: "wait_seconds",
        kind: "scalar",
        localName: "wait_seconds",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 6,
        name: "estimated_wait_seconds_remaining",
        kind: "scalar",
        localName: "estimated_wait_seconds_remaining",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgConnectionStatus>): CMsgConnectionStatus {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgConnectionStatus>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgConnectionStatus,
  ): CMsgConnectionStatus {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional GCConnectionStatus status */ 1:
          message.status = reader.int32();
          break;
        case /* optional uint32 client_session_need */ 2:
          message.client_session_need = reader.uint32();
          break;
        case /* optional int32 queue_position */ 3:
          message.queue_position = reader.int32();
          break;
        case /* optional int32 queue_size */ 4:
          message.queue_size = reader.int32();
          break;
        case /* optional int32 wait_seconds */ 5:
          message.wait_seconds = reader.int32();
          break;
        case /* optional int32 estimated_wait_seconds_remaining */ 6:
          message.estimated_wait_seconds_remaining = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgConnectionStatus,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional GCConnectionStatus status = 1; */
    if (message.status !== undefined) writer.tag(1, WireType.Varint).int32(message.status);
    /* optional uint32 client_session_need = 2; */
    if (message.client_session_need !== undefined) writer.tag(2, WireType.Varint).uint32(message.client_session_need);
    /* optional int32 queue_position = 3; */
    if (message.queue_position !== undefined) writer.tag(3, WireType.Varint).int32(message.queue_position);
    /* optional int32 queue_size = 4; */
    if (message.queue_size !== undefined) writer.tag(4, WireType.Varint).int32(message.queue_size);
    /* optional int32 wait_seconds = 5; */
    if (message.wait_seconds !== undefined) writer.tag(5, WireType.Varint).int32(message.wait_seconds);
    /* optional int32 estimated_wait_seconds_remaining = 6; */
    if (message.estimated_wait_seconds_remaining !== undefined)
      writer.tag(6, WireType.Varint).int32(message.estimated_wait_seconds_remaining);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgConnectionStatus
 */
export const CMsgConnectionStatus = new CMsgConnectionStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCSOCacheSubscribe$Type extends MessageType<CMsgGCToGCSOCacheSubscribe> {
  constructor() {
    super("CMsgGCToGCSOCacheSubscribe", [
      {
        no: 1,
        name: "subscriber",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "subscribe_to_id",
        kind: "scalar",
        localName: "subscribe_to_id",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "sync_version",
        kind: "scalar",
        localName: "sync_version",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 4,
        name: "have_versions",
        kind: "message",
        localName: "have_versions",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions,
      },
      {
        no: 5,
        name: "subscribe_to_type",
        kind: "scalar",
        localName: "subscribe_to_type",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCSOCacheSubscribe>): CMsgGCToGCSOCacheSubscribe {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.have_versions = [];
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCSOCacheSubscribe>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCSOCacheSubscribe,
  ): CMsgGCToGCSOCacheSubscribe {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 subscriber */ 1:
          message.subscriber = reader.fixed64().toBigInt();
          break;
        case /* optional fixed64 subscribe_to_id */ 2:
          message.subscribe_to_id = reader.fixed64().toBigInt();
          break;
        case /* optional fixed64 sync_version */ 3:
          message.sync_version = reader.fixed64().toBigInt();
          break;
        case /* repeated CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions have_versions */ 4:
          message.have_versions.push(
            CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* optional uint32 subscribe_to_type */ 5:
          message.subscribe_to_type = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCSOCacheSubscribe,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed64 subscriber = 1; */
    if (message.subscriber !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.subscriber);
    /* optional fixed64 subscribe_to_id = 2; */
    if (message.subscribe_to_id !== undefined) writer.tag(2, WireType.Bit64).fixed64(message.subscribe_to_id);
    /* optional fixed64 sync_version = 3; */
    if (message.sync_version !== undefined) writer.tag(3, WireType.Bit64).fixed64(message.sync_version);
    /* repeated CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions have_versions = 4; */
    for (let i = 0; i < message.have_versions.length; i++)
      CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions.internalBinaryWrite(
        message.have_versions[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 subscribe_to_type = 5; */
    if (message.subscribe_to_type !== undefined) writer.tag(5, WireType.Varint).uint32(message.subscribe_to_type);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCSOCacheSubscribe
 */
export const CMsgGCToGCSOCacheSubscribe = new CMsgGCToGCSOCacheSubscribe$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions$Type extends MessageType<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions> {
  constructor() {
    super("CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions", [
      {
        no: 1,
        name: "service_id",
        kind: "scalar",
        localName: "service_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions>,
  ): CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions,
  ): CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 service_id */ 1:
          message.service_id = reader.uint32();
          break;
        case /* optional uint64 version */ 2:
          message.version = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 service_id = 1; */
    if (message.service_id !== undefined) writer.tag(1, WireType.Varint).uint32(message.service_id);
    /* optional uint64 version = 2; */
    if (message.version !== undefined) writer.tag(2, WireType.Varint).uint64(message.version);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions
 */
export const CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions = new CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCSOCacheUnsubscribe$Type extends MessageType<CMsgGCToGCSOCacheUnsubscribe> {
  constructor() {
    super("CMsgGCToGCSOCacheUnsubscribe", [
      {
        no: 1,
        name: "subscriber",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "unsubscribe_from_id",
        kind: "scalar",
        localName: "unsubscribe_from_id",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "unsubscribe_from_type",
        kind: "scalar",
        localName: "unsubscribe_from_type",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCSOCacheUnsubscribe>): CMsgGCToGCSOCacheUnsubscribe {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCSOCacheUnsubscribe>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCSOCacheUnsubscribe,
  ): CMsgGCToGCSOCacheUnsubscribe {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 subscriber */ 1:
          message.subscriber = reader.fixed64().toBigInt();
          break;
        case /* optional fixed64 unsubscribe_from_id */ 2:
          message.unsubscribe_from_id = reader.fixed64().toBigInt();
          break;
        case /* optional uint32 unsubscribe_from_type */ 3:
          message.unsubscribe_from_type = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCSOCacheUnsubscribe,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed64 subscriber = 1; */
    if (message.subscriber !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.subscriber);
    /* optional fixed64 unsubscribe_from_id = 2; */
    if (message.unsubscribe_from_id !== undefined) writer.tag(2, WireType.Bit64).fixed64(message.unsubscribe_from_id);
    /* optional uint32 unsubscribe_from_type = 3; */
    if (message.unsubscribe_from_type !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.unsubscribe_from_type);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCSOCacheUnsubscribe
 */
export const CMsgGCToGCSOCacheUnsubscribe = new CMsgGCToGCSOCacheUnsubscribe$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCClientPing$Type extends MessageType<CMsgGCClientPing> {
  constructor() {
    super("CMsgGCClientPing", []);
  }
  create(value?: PartialMessage<CMsgGCClientPing>): CMsgGCClientPing {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCClientPing>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCClientPing,
  ): CMsgGCClientPing {
    return target ?? this.create();
  }
  internalBinaryWrite(message: CMsgGCClientPing, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCClientPing
 */
export const CMsgGCClientPing = new CMsgGCClientPing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCForwardAccountDetails$Type extends MessageType<CMsgGCToGCForwardAccountDetails> {
  constructor() {
    super("CMsgGCToGCForwardAccountDetails", [
      {
        no: 1,
        name: "steamid",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "account_details",
        kind: "message",
        localName: "account_details",
        T: () => CGCSystemMsg_GetAccountDetails_Response,
      },
      {
        no: 3,
        name: "age_seconds",
        kind: "scalar",
        localName: "age_seconds",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCForwardAccountDetails>): CMsgGCToGCForwardAccountDetails {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCForwardAccountDetails>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCForwardAccountDetails,
  ): CMsgGCToGCForwardAccountDetails {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 steamid */ 1:
          message.steamid = reader.fixed64().toBigInt();
          break;
        case /* optional CGCSystemMsg_GetAccountDetails_Response account_details */ 2:
          message.account_details = CGCSystemMsg_GetAccountDetails_Response.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.account_details,
          );
          break;
        case /* optional uint32 age_seconds */ 3:
          message.age_seconds = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCForwardAccountDetails,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed64 steamid = 1; */
    if (message.steamid !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steamid);
    /* optional CGCSystemMsg_GetAccountDetails_Response account_details = 2; */
    if (message.account_details)
      CGCSystemMsg_GetAccountDetails_Response.internalBinaryWrite(
        message.account_details,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 age_seconds = 3; */
    if (message.age_seconds !== undefined) writer.tag(3, WireType.Varint).uint32(message.age_seconds);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCForwardAccountDetails
 */
export const CMsgGCToGCForwardAccountDetails = new CMsgGCToGCForwardAccountDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCLoadSessionSOCache$Type extends MessageType<CMsgGCToGCLoadSessionSOCache> {
  constructor() {
    super("CMsgGCToGCLoadSessionSOCache", [
      {
        no: 1,
        name: "account_id",
        kind: "scalar",
        localName: "account_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "forward_account_details",
        kind: "message",
        localName: "forward_account_details",
        T: () => CMsgGCToGCForwardAccountDetails,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCLoadSessionSOCache>): CMsgGCToGCLoadSessionSOCache {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCLoadSessionSOCache>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCLoadSessionSOCache,
  ): CMsgGCToGCLoadSessionSOCache {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 account_id */ 1:
          message.account_id = reader.uint32();
          break;
        case /* optional CMsgGCToGCForwardAccountDetails forward_account_details */ 2:
          message.forward_account_details = CMsgGCToGCForwardAccountDetails.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.forward_account_details,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCLoadSessionSOCache,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 account_id = 1; */
    if (message.account_id !== undefined) writer.tag(1, WireType.Varint).uint32(message.account_id);
    /* optional CMsgGCToGCForwardAccountDetails forward_account_details = 2; */
    if (message.forward_account_details)
      CMsgGCToGCForwardAccountDetails.internalBinaryWrite(
        message.forward_account_details,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCLoadSessionSOCache
 */
export const CMsgGCToGCLoadSessionSOCache = new CMsgGCToGCLoadSessionSOCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCLoadSessionSOCacheResponse$Type extends MessageType<CMsgGCToGCLoadSessionSOCacheResponse> {
  constructor() {
    super("CMsgGCToGCLoadSessionSOCacheResponse", []);
  }
  create(value?: PartialMessage<CMsgGCToGCLoadSessionSOCacheResponse>): CMsgGCToGCLoadSessionSOCacheResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCLoadSessionSOCacheResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCLoadSessionSOCacheResponse,
  ): CMsgGCToGCLoadSessionSOCacheResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CMsgGCToGCLoadSessionSOCacheResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCLoadSessionSOCacheResponse
 */
export const CMsgGCToGCLoadSessionSOCacheResponse = new CMsgGCToGCLoadSessionSOCacheResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCUpdateSessionStats$Type extends MessageType<CMsgGCToGCUpdateSessionStats> {
  constructor() {
    super("CMsgGCToGCUpdateSessionStats", [
      {
        no: 1,
        name: "user_sessions",
        kind: "scalar",
        localName: "user_sessions",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "server_sessions",
        kind: "scalar",
        localName: "server_sessions",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "in_logon_surge",
        kind: "scalar",
        localName: "in_logon_surge",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCUpdateSessionStats>): CMsgGCToGCUpdateSessionStats {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCUpdateSessionStats>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCUpdateSessionStats,
  ): CMsgGCToGCUpdateSessionStats {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 user_sessions */ 1:
          message.user_sessions = reader.uint32();
          break;
        case /* optional uint32 server_sessions */ 2:
          message.server_sessions = reader.uint32();
          break;
        case /* optional bool in_logon_surge */ 3:
          message.in_logon_surge = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCUpdateSessionStats,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 user_sessions = 1; */
    if (message.user_sessions !== undefined) writer.tag(1, WireType.Varint).uint32(message.user_sessions);
    /* optional uint32 server_sessions = 2; */
    if (message.server_sessions !== undefined) writer.tag(2, WireType.Varint).uint32(message.server_sessions);
    /* optional bool in_logon_surge = 3; */
    if (message.in_logon_surge !== undefined) writer.tag(3, WireType.Varint).bool(message.in_logon_surge);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCUpdateSessionStats
 */
export const CMsgGCToGCUpdateSessionStats = new CMsgGCToGCUpdateSessionStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToClientRequestDropped$Type extends MessageType<CMsgGCToClientRequestDropped> {
  constructor() {
    super("CMsgGCToClientRequestDropped", []);
  }
  create(value?: PartialMessage<CMsgGCToClientRequestDropped>): CMsgGCToClientRequestDropped {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToClientRequestDropped>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToClientRequestDropped,
  ): CMsgGCToClientRequestDropped {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CMsgGCToClientRequestDropped,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToClientRequestDropped
 */
export const CMsgGCToClientRequestDropped = new CMsgGCToClientRequestDropped$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_PopulateItemDescriptions_Request$Type extends MessageType<CWorkshop_PopulateItemDescriptions_Request> {
  constructor() {
    super("CWorkshop_PopulateItemDescriptions_Request", [
      {
        no: 1,
        name: "appid",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "languages",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock,
      },
    ]);
  }
  create(
    value?: PartialMessage<CWorkshop_PopulateItemDescriptions_Request>,
  ): CWorkshop_PopulateItemDescriptions_Request {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.languages = [];
    if (value !== undefined) reflectionMergePartial<CWorkshop_PopulateItemDescriptions_Request>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CWorkshop_PopulateItemDescriptions_Request,
  ): CWorkshop_PopulateItemDescriptions_Request {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 appid */ 1:
          message.appid = reader.uint32();
          break;
        case /* repeated CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock languages */ 2:
          message.languages.push(
            CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CWorkshop_PopulateItemDescriptions_Request,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 appid = 1; */
    if (message.appid !== undefined) writer.tag(1, WireType.Varint).uint32(message.appid);
    /* repeated CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock languages = 2; */
    for (let i = 0; i < message.languages.length; i++)
      CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock.internalBinaryWrite(
        message.languages[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CWorkshop_PopulateItemDescriptions_Request
 */
export const CWorkshop_PopulateItemDescriptions_Request = new CWorkshop_PopulateItemDescriptions_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription$Type extends MessageType<CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription> {
  constructor() {
    super("CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription", [
      {
        no: 1,
        name: "gameitemid",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "item_description",
        kind: "scalar",
        localName: "item_description",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription>,
  ): CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription,
  ): CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 gameitemid */ 1:
          message.gameitemid = reader.uint32();
          break;
        case /* optional string item_description */ 2:
          message.item_description = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 gameitemid = 1; */
    if (message.gameitemid !== undefined) writer.tag(1, WireType.Varint).uint32(message.gameitemid);
    /* optional string item_description = 2; */
    if (message.item_description !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.item_description);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription
 */
export const CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription =
  new CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock$Type extends MessageType<CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock> {
  constructor() {
    super("CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock", [
      {
        no: 1,
        name: "language",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "descriptions",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription,
      },
    ]);
  }
  create(
    value?: PartialMessage<CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock>,
  ): CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.descriptions = [];
    if (value !== undefined)
      reflectionMergePartial<CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock,
  ): CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string language */ 1:
          message.language = reader.string();
          break;
        case /* repeated CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription descriptions */ 2:
          message.descriptions.push(
            CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string language = 1; */
    if (message.language !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.language);
    /* repeated CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription descriptions = 2; */
    for (let i = 0; i < message.descriptions.length; i++)
      CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription.internalBinaryWrite(
        message.descriptions[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock
 */
export const CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock =
  new CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_GetContributors_Request$Type extends MessageType<CWorkshop_GetContributors_Request> {
  constructor() {
    super("CWorkshop_GetContributors_Request", [
      {
        no: 1,
        name: "appid",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "gameitemid",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CWorkshop_GetContributors_Request>): CWorkshop_GetContributors_Request {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CWorkshop_GetContributors_Request>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CWorkshop_GetContributors_Request,
  ): CWorkshop_GetContributors_Request {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 appid */ 1:
          message.appid = reader.uint32();
          break;
        case /* optional uint32 gameitemid */ 2:
          message.gameitemid = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CWorkshop_GetContributors_Request,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 appid = 1; */
    if (message.appid !== undefined) writer.tag(1, WireType.Varint).uint32(message.appid);
    /* optional uint32 gameitemid = 2; */
    if (message.gameitemid !== undefined) writer.tag(2, WireType.Varint).uint32(message.gameitemid);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CWorkshop_GetContributors_Request
 */
export const CWorkshop_GetContributors_Request = new CWorkshop_GetContributors_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_GetContributors_Response$Type extends MessageType<CWorkshop_GetContributors_Response> {
  constructor() {
    super("CWorkshop_GetContributors_Response", [
      {
        no: 1,
        name: "contributors",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CWorkshop_GetContributors_Response>): CWorkshop_GetContributors_Response {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.contributors = [];
    if (value !== undefined) reflectionMergePartial<CWorkshop_GetContributors_Response>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CWorkshop_GetContributors_Response,
  ): CWorkshop_GetContributors_Response {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated fixed64 contributors */ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.contributors.push(reader.fixed64().toBigInt());
          else message.contributors.push(reader.fixed64().toBigInt());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CWorkshop_GetContributors_Response,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated fixed64 contributors = 1; */
    for (let i = 0; i < message.contributors.length; i++)
      writer.tag(1, WireType.Bit64).fixed64(message.contributors[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CWorkshop_GetContributors_Response
 */
export const CWorkshop_GetContributors_Response = new CWorkshop_GetContributors_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_SetItemPaymentRules_Request$Type extends MessageType<CWorkshop_SetItemPaymentRules_Request> {
  constructor() {
    super("CWorkshop_SetItemPaymentRules_Request", [
      {
        no: 1,
        name: "appid",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "gameitemid",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "associated_workshop_files",
        kind: "message",
        localName: "associated_workshop_files",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule,
      },
      {
        no: 4,
        name: "partner_accounts",
        kind: "message",
        localName: "partner_accounts",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule,
      },
      {
        no: 5,
        name: "validate_only",
        kind: "scalar",
        localName: "validate_only",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 6,
        name: "make_workshop_files_subscribable",
        kind: "scalar",
        localName: "make_workshop_files_subscribable",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 7,
        name: "associated_workshop_file_for_direct_payments",
        kind: "message",
        localName: "associated_workshop_file_for_direct_payments",
        T: () => CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule,
      },
    ]);
  }
  create(value?: PartialMessage<CWorkshop_SetItemPaymentRules_Request>): CWorkshop_SetItemPaymentRules_Request {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.associated_workshop_files = [];
    message.partner_accounts = [];
    if (value !== undefined) reflectionMergePartial<CWorkshop_SetItemPaymentRules_Request>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CWorkshop_SetItemPaymentRules_Request,
  ): CWorkshop_SetItemPaymentRules_Request {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 appid */ 1:
          message.appid = reader.uint32();
          break;
        case /* optional uint32 gameitemid */ 2:
          message.gameitemid = reader.uint32();
          break;
        case /* repeated CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule associated_workshop_files */ 3:
          message.associated_workshop_files.push(
            CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* repeated CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule partner_accounts */ 4:
          message.partner_accounts.push(
            CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* optional bool validate_only */ 5:
          message.validate_only = reader.bool();
          break;
        case /* optional bool make_workshop_files_subscribable */ 6:
          message.make_workshop_files_subscribable = reader.bool();
          break;
        case /* optional CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule associated_workshop_file_for_direct_payments */ 7:
          message.associated_workshop_file_for_direct_payments =
            CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.associated_workshop_file_for_direct_payments,
            );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CWorkshop_SetItemPaymentRules_Request,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 appid = 1; */
    if (message.appid !== undefined) writer.tag(1, WireType.Varint).uint32(message.appid);
    /* optional uint32 gameitemid = 2; */
    if (message.gameitemid !== undefined) writer.tag(2, WireType.Varint).uint32(message.gameitemid);
    /* repeated CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule associated_workshop_files = 3; */
    for (let i = 0; i < message.associated_workshop_files.length; i++)
      CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule.internalBinaryWrite(
        message.associated_workshop_files[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule partner_accounts = 4; */
    for (let i = 0; i < message.partner_accounts.length; i++)
      CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule.internalBinaryWrite(
        message.partner_accounts[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional bool validate_only = 5; */
    if (message.validate_only !== undefined) writer.tag(5, WireType.Varint).bool(message.validate_only);
    /* optional bool make_workshop_files_subscribable = 6; */
    if (message.make_workshop_files_subscribable !== undefined)
      writer.tag(6, WireType.Varint).bool(message.make_workshop_files_subscribable);
    /* optional CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule associated_workshop_file_for_direct_payments = 7; */
    if (message.associated_workshop_file_for_direct_payments)
      CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule.internalBinaryWrite(
        message.associated_workshop_file_for_direct_payments,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CWorkshop_SetItemPaymentRules_Request
 */
export const CWorkshop_SetItemPaymentRules_Request = new CWorkshop_SetItemPaymentRules_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule$Type extends MessageType<CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule> {
  constructor() {
    super("CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule", [
      {
        no: 1,
        name: "workshop_file_id",
        kind: "scalar",
        localName: "workshop_file_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "revenue_percentage",
        kind: "scalar",
        localName: "revenue_percentage",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 3,
        name: "rule_description",
        kind: "scalar",
        localName: "rule_description",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: "rule_type",
        kind: "scalar",
        localName: "rule_type",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule>,
  ): CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule,
  ): CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 workshop_file_id */ 1:
          message.workshop_file_id = reader.uint64().toBigInt();
          break;
        case /* optional float revenue_percentage */ 2:
          message.revenue_percentage = reader.float();
          break;
        case /* optional string rule_description */ 3:
          message.rule_description = reader.string();
          break;
        case /* optional uint32 rule_type */ 4:
          message.rule_type = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 workshop_file_id = 1; */
    if (message.workshop_file_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.workshop_file_id);
    /* optional float revenue_percentage = 2; */
    if (message.revenue_percentage !== undefined) writer.tag(2, WireType.Bit32).float(message.revenue_percentage);
    /* optional string rule_description = 3; */
    if (message.rule_description !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.rule_description);
    /* optional uint32 rule_type = 4; */
    if (message.rule_type !== undefined) writer.tag(4, WireType.Varint).uint32(message.rule_type);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule
 */
export const CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule =
  new CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule$Type extends MessageType<CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule> {
  constructor() {
    super("CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule", [
      {
        no: 1,
        name: "workshop_file_id",
        kind: "scalar",
        localName: "workshop_file_id",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "rule_description",
        kind: "scalar",
        localName: "rule_description",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule>,
  ): CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule,
  ): CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 workshop_file_id */ 1:
          message.workshop_file_id = reader.uint64().toBigInt();
          break;
        case /* optional string rule_description */ 2:
          message.rule_description = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 workshop_file_id = 1; */
    if (message.workshop_file_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.workshop_file_id);
    /* optional string rule_description = 2; */
    if (message.rule_description !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.rule_description);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule
 */
export const CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule =
  new CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule$Type extends MessageType<CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule> {
  constructor() {
    super("CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule", [
      {
        no: 1,
        name: "account_id",
        kind: "scalar",
        localName: "account_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "revenue_percentage",
        kind: "scalar",
        localName: "revenue_percentage",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 3,
        name: "rule_description",
        kind: "scalar",
        localName: "rule_description",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule>,
  ): CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule,
  ): CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 account_id */ 1:
          message.account_id = reader.uint32();
          break;
        case /* optional float revenue_percentage */ 2:
          message.revenue_percentage = reader.float();
          break;
        case /* optional string rule_description */ 3:
          message.rule_description = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 account_id = 1; */
    if (message.account_id !== undefined) writer.tag(1, WireType.Varint).uint32(message.account_id);
    /* optional float revenue_percentage = 2; */
    if (message.revenue_percentage !== undefined) writer.tag(2, WireType.Bit32).float(message.revenue_percentage);
    /* optional string rule_description = 3; */
    if (message.rule_description !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.rule_description);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule
 */
export const CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule =
  new CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_SetItemPaymentRules_Response$Type extends MessageType<CWorkshop_SetItemPaymentRules_Response> {
  constructor() {
    super("CWorkshop_SetItemPaymentRules_Response", [
      {
        no: 1,
        name: "validation_errors",
        kind: "scalar",
        localName: "validation_errors",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<CWorkshop_SetItemPaymentRules_Response>): CWorkshop_SetItemPaymentRules_Response {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.validation_errors = [];
    if (value !== undefined) reflectionMergePartial<CWorkshop_SetItemPaymentRules_Response>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CWorkshop_SetItemPaymentRules_Response,
  ): CWorkshop_SetItemPaymentRules_Response {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string validation_errors */ 1:
          message.validation_errors.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CWorkshop_SetItemPaymentRules_Response,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string validation_errors = 1; */
    for (let i = 0; i < message.validation_errors.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.validation_errors[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CWorkshop_SetItemPaymentRules_Response
 */
export const CWorkshop_SetItemPaymentRules_Response = new CWorkshop_SetItemPaymentRules_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCommunity_ClanAnnouncementInfo$Type extends MessageType<CCommunity_ClanAnnouncementInfo> {
  constructor() {
    super("CCommunity_ClanAnnouncementInfo", [
      {
        no: 1,
        name: "gid",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "clanid",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "posterid",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 4,
        name: "headline",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 5,
        name: "posttime",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "updatetime",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 7,
        name: "body",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 8,
        name: "commentcount",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 9,
        name: "tags",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 10,
        name: "language",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 11,
        name: "hidden",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 12,
        name: "forum_topic_id",
        kind: "scalar",
        localName: "forum_topic_id",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CCommunity_ClanAnnouncementInfo>): CCommunity_ClanAnnouncementInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.tags = [];
    if (value !== undefined) reflectionMergePartial<CCommunity_ClanAnnouncementInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCommunity_ClanAnnouncementInfo,
  ): CCommunity_ClanAnnouncementInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 gid */ 1:
          message.gid = reader.uint64().toBigInt();
          break;
        case /* optional uint64 clanid */ 2:
          message.clanid = reader.uint64().toBigInt();
          break;
        case /* optional uint64 posterid */ 3:
          message.posterid = reader.uint64().toBigInt();
          break;
        case /* optional string headline */ 4:
          message.headline = reader.string();
          break;
        case /* optional uint32 posttime */ 5:
          message.posttime = reader.uint32();
          break;
        case /* optional uint32 updatetime */ 6:
          message.updatetime = reader.uint32();
          break;
        case /* optional string body */ 7:
          message.body = reader.string();
          break;
        case /* optional int32 commentcount */ 8:
          message.commentcount = reader.int32();
          break;
        case /* repeated string tags */ 9:
          message.tags.push(reader.string());
          break;
        case /* optional int32 language */ 10:
          message.language = reader.int32();
          break;
        case /* optional bool hidden */ 11:
          message.hidden = reader.bool();
          break;
        case /* optional fixed64 forum_topic_id */ 12:
          message.forum_topic_id = reader.fixed64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCommunity_ClanAnnouncementInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 gid = 1; */
    if (message.gid !== undefined) writer.tag(1, WireType.Varint).uint64(message.gid);
    /* optional uint64 clanid = 2; */
    if (message.clanid !== undefined) writer.tag(2, WireType.Varint).uint64(message.clanid);
    /* optional uint64 posterid = 3; */
    if (message.posterid !== undefined) writer.tag(3, WireType.Varint).uint64(message.posterid);
    /* optional string headline = 4; */
    if (message.headline !== undefined) writer.tag(4, WireType.LengthDelimited).string(message.headline);
    /* optional uint32 posttime = 5; */
    if (message.posttime !== undefined) writer.tag(5, WireType.Varint).uint32(message.posttime);
    /* optional uint32 updatetime = 6; */
    if (message.updatetime !== undefined) writer.tag(6, WireType.Varint).uint32(message.updatetime);
    /* optional string body = 7; */
    if (message.body !== undefined) writer.tag(7, WireType.LengthDelimited).string(message.body);
    /* optional int32 commentcount = 8; */
    if (message.commentcount !== undefined) writer.tag(8, WireType.Varint).int32(message.commentcount);
    /* repeated string tags = 9; */
    for (let i = 0; i < message.tags.length; i++) writer.tag(9, WireType.LengthDelimited).string(message.tags[i]);
    /* optional int32 language = 10; */
    if (message.language !== undefined) writer.tag(10, WireType.Varint).int32(message.language);
    /* optional bool hidden = 11; */
    if (message.hidden !== undefined) writer.tag(11, WireType.Varint).bool(message.hidden);
    /* optional fixed64 forum_topic_id = 12; */
    if (message.forum_topic_id !== undefined) writer.tag(12, WireType.Bit64).fixed64(message.forum_topic_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCommunity_ClanAnnouncementInfo
 */
export const CCommunity_ClanAnnouncementInfo = new CCommunity_ClanAnnouncementInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCommunity_GetClanAnnouncements_Request$Type extends MessageType<CCommunity_GetClanAnnouncements_Request> {
  constructor() {
    super("CCommunity_GetClanAnnouncements_Request", [
      {
        no: 1,
        name: "steamid",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "offset",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "count",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "maxchars",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "strip_html",
        kind: "scalar",
        localName: "strip_html",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 6,
        name: "required_tags",
        kind: "scalar",
        localName: "required_tags",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 7,
        name: "require_no_tags",
        kind: "scalar",
        localName: "require_no_tags",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 8,
        name: "language_preference",
        kind: "scalar",
        localName: "language_preference",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 9,
        name: "hidden_only",
        kind: "scalar",
        localName: "hidden_only",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 10,
        name: "only_gid",
        kind: "scalar",
        localName: "only_gid",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 11,
        name: "rtime_oldest_date",
        kind: "scalar",
        localName: "rtime_oldest_date",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 12,
        name: "include_hidden",
        kind: "scalar",
        localName: "include_hidden",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 13,
        name: "include_partner_events",
        kind: "scalar",
        localName: "include_partner_events",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<CCommunity_GetClanAnnouncements_Request>): CCommunity_GetClanAnnouncements_Request {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.required_tags = [];
    message.language_preference = [];
    if (value !== undefined) reflectionMergePartial<CCommunity_GetClanAnnouncements_Request>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCommunity_GetClanAnnouncements_Request,
  ): CCommunity_GetClanAnnouncements_Request {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 steamid */ 1:
          message.steamid = reader.uint64().toBigInt();
          break;
        case /* optional uint32 offset */ 2:
          message.offset = reader.uint32();
          break;
        case /* optional uint32 count */ 3:
          message.count = reader.uint32();
          break;
        case /* optional uint32 maxchars */ 4:
          message.maxchars = reader.uint32();
          break;
        case /* optional bool strip_html */ 5:
          message.strip_html = reader.bool();
          break;
        case /* repeated string required_tags */ 6:
          message.required_tags.push(reader.string());
          break;
        case /* optional bool require_no_tags */ 7:
          message.require_no_tags = reader.bool();
          break;
        case /* repeated uint32 language_preference */ 8:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.language_preference.push(reader.uint32());
          else message.language_preference.push(reader.uint32());
          break;
        case /* optional bool hidden_only */ 9:
          message.hidden_only = reader.bool();
          break;
        case /* optional bool only_gid */ 10:
          message.only_gid = reader.bool();
          break;
        case /* optional uint32 rtime_oldest_date */ 11:
          message.rtime_oldest_date = reader.uint32();
          break;
        case /* optional bool include_hidden */ 12:
          message.include_hidden = reader.bool();
          break;
        case /* optional bool include_partner_events */ 13:
          message.include_partner_events = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCommunity_GetClanAnnouncements_Request,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 steamid = 1; */
    if (message.steamid !== undefined) writer.tag(1, WireType.Varint).uint64(message.steamid);
    /* optional uint32 offset = 2; */
    if (message.offset !== undefined) writer.tag(2, WireType.Varint).uint32(message.offset);
    /* optional uint32 count = 3; */
    if (message.count !== undefined) writer.tag(3, WireType.Varint).uint32(message.count);
    /* optional uint32 maxchars = 4; */
    if (message.maxchars !== undefined) writer.tag(4, WireType.Varint).uint32(message.maxchars);
    /* optional bool strip_html = 5; */
    if (message.strip_html !== undefined) writer.tag(5, WireType.Varint).bool(message.strip_html);
    /* repeated string required_tags = 6; */
    for (let i = 0; i < message.required_tags.length; i++)
      writer.tag(6, WireType.LengthDelimited).string(message.required_tags[i]);
    /* optional bool require_no_tags = 7; */
    if (message.require_no_tags !== undefined) writer.tag(7, WireType.Varint).bool(message.require_no_tags);
    /* repeated uint32 language_preference = 8; */
    for (let i = 0; i < message.language_preference.length; i++)
      writer.tag(8, WireType.Varint).uint32(message.language_preference[i]);
    /* optional bool hidden_only = 9; */
    if (message.hidden_only !== undefined) writer.tag(9, WireType.Varint).bool(message.hidden_only);
    /* optional bool only_gid = 10; */
    if (message.only_gid !== undefined) writer.tag(10, WireType.Varint).bool(message.only_gid);
    /* optional uint32 rtime_oldest_date = 11; */
    if (message.rtime_oldest_date !== undefined) writer.tag(11, WireType.Varint).uint32(message.rtime_oldest_date);
    /* optional bool include_hidden = 12; */
    if (message.include_hidden !== undefined) writer.tag(12, WireType.Varint).bool(message.include_hidden);
    /* optional bool include_partner_events = 13; */
    if (message.include_partner_events !== undefined)
      writer.tag(13, WireType.Varint).bool(message.include_partner_events);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCommunity_GetClanAnnouncements_Request
 */
export const CCommunity_GetClanAnnouncements_Request = new CCommunity_GetClanAnnouncements_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCommunity_GetClanAnnouncements_Response$Type extends MessageType<CCommunity_GetClanAnnouncements_Response> {
  constructor() {
    super("CCommunity_GetClanAnnouncements_Response", [
      {
        no: 1,
        name: "maxchars",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "strip_html",
        kind: "scalar",
        localName: "strip_html",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 3,
        name: "announcements",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CCommunity_ClanAnnouncementInfo,
      },
    ]);
  }
  create(value?: PartialMessage<CCommunity_GetClanAnnouncements_Response>): CCommunity_GetClanAnnouncements_Response {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.announcements = [];
    if (value !== undefined) reflectionMergePartial<CCommunity_GetClanAnnouncements_Response>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCommunity_GetClanAnnouncements_Response,
  ): CCommunity_GetClanAnnouncements_Response {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 maxchars */ 1:
          message.maxchars = reader.uint32();
          break;
        case /* optional bool strip_html */ 2:
          message.strip_html = reader.bool();
          break;
        case /* repeated CCommunity_ClanAnnouncementInfo announcements */ 3:
          message.announcements.push(
            CCommunity_ClanAnnouncementInfo.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCommunity_GetClanAnnouncements_Response,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 maxchars = 1; */
    if (message.maxchars !== undefined) writer.tag(1, WireType.Varint).uint32(message.maxchars);
    /* optional bool strip_html = 2; */
    if (message.strip_html !== undefined) writer.tag(2, WireType.Varint).bool(message.strip_html);
    /* repeated CCommunity_ClanAnnouncementInfo announcements = 3; */
    for (let i = 0; i < message.announcements.length; i++)
      CCommunity_ClanAnnouncementInfo.internalBinaryWrite(
        message.announcements[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCommunity_GetClanAnnouncements_Response
 */
export const CCommunity_GetClanAnnouncements_Response = new CCommunity_GetClanAnnouncements_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CBroadcast_PostGameDataFrame_Request$Type extends MessageType<CBroadcast_PostGameDataFrame_Request> {
  constructor() {
    super("CBroadcast_PostGameDataFrame_Request", [
      {
        no: 1,
        name: "appid",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "steamid",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "broadcast_id",
        kind: "scalar",
        localName: "broadcast_id",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 4,
        name: "frame_data",
        kind: "scalar",
        localName: "frame_data",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<CBroadcast_PostGameDataFrame_Request>): CBroadcast_PostGameDataFrame_Request {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CBroadcast_PostGameDataFrame_Request>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CBroadcast_PostGameDataFrame_Request,
  ): CBroadcast_PostGameDataFrame_Request {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 appid */ 1:
          message.appid = reader.uint32();
          break;
        case /* optional fixed64 steamid */ 2:
          message.steamid = reader.fixed64().toBigInt();
          break;
        case /* optional fixed64 broadcast_id */ 3:
          message.broadcast_id = reader.fixed64().toBigInt();
          break;
        case /* optional bytes frame_data */ 4:
          message.frame_data = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CBroadcast_PostGameDataFrame_Request,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 appid = 1; */
    if (message.appid !== undefined) writer.tag(1, WireType.Varint).uint32(message.appid);
    /* optional fixed64 steamid = 2; */
    if (message.steamid !== undefined) writer.tag(2, WireType.Bit64).fixed64(message.steamid);
    /* optional fixed64 broadcast_id = 3; */
    if (message.broadcast_id !== undefined) writer.tag(3, WireType.Bit64).fixed64(message.broadcast_id);
    /* optional bytes frame_data = 4; */
    if (message.frame_data !== undefined) writer.tag(4, WireType.LengthDelimited).bytes(message.frame_data);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CBroadcast_PostGameDataFrame_Request
 */
export const CBroadcast_PostGameDataFrame_Request = new CBroadcast_PostGameDataFrame_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSerializedSOCache$Type extends MessageType<CMsgSerializedSOCache> {
  constructor() {
    super("CMsgSerializedSOCache", [
      {
        no: 1,
        name: "file_version",
        kind: "scalar",
        localName: "file_version",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "caches",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgSerializedSOCache_Cache,
      },
      {
        no: 3,
        name: "gc_socache_file_version",
        kind: "scalar",
        localName: "gc_socache_file_version",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSerializedSOCache>): CMsgSerializedSOCache {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.caches = [];
    if (value !== undefined) reflectionMergePartial<CMsgSerializedSOCache>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSerializedSOCache,
  ): CMsgSerializedSOCache {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 file_version */ 1:
          message.file_version = reader.uint32();
          break;
        case /* repeated CMsgSerializedSOCache.Cache caches */ 2:
          message.caches.push(CMsgSerializedSOCache_Cache.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* optional uint32 gc_socache_file_version */ 3:
          message.gc_socache_file_version = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSerializedSOCache,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 file_version = 1; */
    if (message.file_version !== undefined) writer.tag(1, WireType.Varint).uint32(message.file_version);
    /* repeated CMsgSerializedSOCache.Cache caches = 2; */
    for (let i = 0; i < message.caches.length; i++)
      CMsgSerializedSOCache_Cache.internalBinaryWrite(
        message.caches[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 gc_socache_file_version = 3; */
    if (message.gc_socache_file_version !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.gc_socache_file_version);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSerializedSOCache
 */
export const CMsgSerializedSOCache = new CMsgSerializedSOCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSerializedSOCache_TypeCache$Type extends MessageType<CMsgSerializedSOCache_TypeCache> {
  constructor() {
    super("CMsgSerializedSOCache.TypeCache", [
      {
        no: 1,
        name: "type",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "objects",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 3,
        name: "service_id",
        kind: "scalar",
        localName: "service_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSerializedSOCache_TypeCache>): CMsgSerializedSOCache_TypeCache {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.objects = [];
    if (value !== undefined) reflectionMergePartial<CMsgSerializedSOCache_TypeCache>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSerializedSOCache_TypeCache,
  ): CMsgSerializedSOCache_TypeCache {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 type */ 1:
          message.type = reader.uint32();
          break;
        case /* repeated bytes objects */ 2:
          message.objects.push(reader.bytes());
          break;
        case /* optional uint32 service_id */ 3:
          message.service_id = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSerializedSOCache_TypeCache,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 type = 1; */
    if (message.type !== undefined) writer.tag(1, WireType.Varint).uint32(message.type);
    /* repeated bytes objects = 2; */
    for (let i = 0; i < message.objects.length; i++) writer.tag(2, WireType.LengthDelimited).bytes(message.objects[i]);
    /* optional uint32 service_id = 3; */
    if (message.service_id !== undefined) writer.tag(3, WireType.Varint).uint32(message.service_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSerializedSOCache.TypeCache
 */
export const CMsgSerializedSOCache_TypeCache = new CMsgSerializedSOCache_TypeCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSerializedSOCache_Cache$Type extends MessageType<CMsgSerializedSOCache_Cache> {
  constructor() {
    super("CMsgSerializedSOCache.Cache", [
      {
        no: 1,
        name: "type",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "versions",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgSerializedSOCache_Cache_Version,
      },
      {
        no: 4,
        name: "type_caches",
        kind: "message",
        localName: "type_caches",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgSerializedSOCache_TypeCache,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSerializedSOCache_Cache>): CMsgSerializedSOCache_Cache {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.versions = [];
    message.type_caches = [];
    if (value !== undefined) reflectionMergePartial<CMsgSerializedSOCache_Cache>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSerializedSOCache_Cache,
  ): CMsgSerializedSOCache_Cache {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 type */ 1:
          message.type = reader.uint32();
          break;
        case /* optional uint64 id */ 2:
          message.id = reader.uint64().toBigInt();
          break;
        case /* repeated CMsgSerializedSOCache.Cache.Version versions */ 3:
          message.versions.push(
            CMsgSerializedSOCache_Cache_Version.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated CMsgSerializedSOCache.TypeCache type_caches */ 4:
          message.type_caches.push(
            CMsgSerializedSOCache_TypeCache.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSerializedSOCache_Cache,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 type = 1; */
    if (message.type !== undefined) writer.tag(1, WireType.Varint).uint32(message.type);
    /* optional uint64 id = 2; */
    if (message.id !== undefined) writer.tag(2, WireType.Varint).uint64(message.id);
    /* repeated CMsgSerializedSOCache.Cache.Version versions = 3; */
    for (let i = 0; i < message.versions.length; i++)
      CMsgSerializedSOCache_Cache_Version.internalBinaryWrite(
        message.versions[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated CMsgSerializedSOCache.TypeCache type_caches = 4; */
    for (let i = 0; i < message.type_caches.length; i++)
      CMsgSerializedSOCache_TypeCache.internalBinaryWrite(
        message.type_caches[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSerializedSOCache.Cache
 */
export const CMsgSerializedSOCache_Cache = new CMsgSerializedSOCache_Cache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSerializedSOCache_Cache_Version$Type extends MessageType<CMsgSerializedSOCache_Cache_Version> {
  constructor() {
    super("CMsgSerializedSOCache.Cache.Version", [
      {
        no: 1,
        name: "service",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSerializedSOCache_Cache_Version>): CMsgSerializedSOCache_Cache_Version {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgSerializedSOCache_Cache_Version>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSerializedSOCache_Cache_Version,
  ): CMsgSerializedSOCache_Cache_Version {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 service */ 1:
          message.service = reader.uint32();
          break;
        case /* optional uint64 version */ 2:
          message.version = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSerializedSOCache_Cache_Version,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 service = 1; */
    if (message.service !== undefined) writer.tag(1, WireType.Varint).uint32(message.service);
    /* optional uint64 version = 2; */
    if (message.version !== undefined) writer.tag(2, WireType.Varint).uint64(message.version);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSerializedSOCache.Cache.Version
 */
export const CMsgSerializedSOCache_Cache_Version = new CMsgSerializedSOCache_Cache_Version$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToClientPollConvarRequest$Type extends MessageType<CMsgGCToClientPollConvarRequest> {
  constructor() {
    super("CMsgGCToClientPollConvarRequest", [
      {
        no: 1,
        name: "convar_name",
        kind: "scalar",
        localName: "convar_name",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "poll_id",
        kind: "scalar",
        localName: "poll_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToClientPollConvarRequest>): CMsgGCToClientPollConvarRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToClientPollConvarRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToClientPollConvarRequest,
  ): CMsgGCToClientPollConvarRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string convar_name */ 1:
          message.convar_name = reader.string();
          break;
        case /* optional uint32 poll_id */ 2:
          message.poll_id = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToClientPollConvarRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string convar_name = 1; */
    if (message.convar_name !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.convar_name);
    /* optional uint32 poll_id = 2; */
    if (message.poll_id !== undefined) writer.tag(2, WireType.Varint).uint32(message.poll_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToClientPollConvarRequest
 */
export const CMsgGCToClientPollConvarRequest = new CMsgGCToClientPollConvarRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToClientPollConvarResponse$Type extends MessageType<CMsgGCToClientPollConvarResponse> {
  constructor() {
    super("CMsgGCToClientPollConvarResponse", [
      {
        no: 1,
        name: "poll_id",
        kind: "scalar",
        localName: "poll_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "convar_value",
        kind: "scalar",
        localName: "convar_value",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToClientPollConvarResponse>): CMsgGCToClientPollConvarResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToClientPollConvarResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToClientPollConvarResponse,
  ): CMsgGCToClientPollConvarResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 poll_id */ 1:
          message.poll_id = reader.uint32();
          break;
        case /* optional string convar_value */ 2:
          message.convar_value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToClientPollConvarResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 poll_id = 1; */
    if (message.poll_id !== undefined) writer.tag(1, WireType.Varint).uint32(message.poll_id);
    /* optional string convar_value = 2; */
    if (message.convar_value !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.convar_value);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToClientPollConvarResponse
 */
export const CMsgGCToClientPollConvarResponse = new CMsgGCToClientPollConvarResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgCompressedMsgToClient$Type extends MessageType<CGCMsgCompressedMsgToClient> {
  constructor() {
    super("CGCMsgCompressedMsgToClient", [
      {
        no: 1,
        name: "msg_id",
        kind: "scalar",
        localName: "msg_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "compressed_msg",
        kind: "scalar",
        localName: "compressed_msg",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<CGCMsgCompressedMsgToClient>): CGCMsgCompressedMsgToClient {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CGCMsgCompressedMsgToClient>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CGCMsgCompressedMsgToClient,
  ): CGCMsgCompressedMsgToClient {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 msg_id */ 1:
          message.msg_id = reader.uint32();
          break;
        case /* optional bytes compressed_msg */ 2:
          message.compressed_msg = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CGCMsgCompressedMsgToClient,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 msg_id = 1; */
    if (message.msg_id !== undefined) writer.tag(1, WireType.Varint).uint32(message.msg_id);
    /* optional bytes compressed_msg = 2; */
    if (message.compressed_msg !== undefined) writer.tag(2, WireType.LengthDelimited).bytes(message.compressed_msg);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CGCMsgCompressedMsgToClient
 */
export const CGCMsgCompressedMsgToClient = new CGCMsgCompressedMsgToClient$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCMasterBroadcastMessage$Type extends MessageType<CMsgGCToGCMasterBroadcastMessage> {
  constructor() {
    super("CMsgGCToGCMasterBroadcastMessage", [
      {
        no: 1,
        name: "users_per_second",
        kind: "scalar",
        localName: "users_per_second",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "send_to_users",
        kind: "scalar",
        localName: "send_to_users",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 3,
        name: "send_to_servers",
        kind: "scalar",
        localName: "send_to_servers",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 4,
        name: "msg_id",
        kind: "scalar",
        localName: "msg_id",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "msg_data",
        kind: "scalar",
        localName: "msg_data",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCMasterBroadcastMessage>): CMsgGCToGCMasterBroadcastMessage {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCMasterBroadcastMessage>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCMasterBroadcastMessage,
  ): CMsgGCToGCMasterBroadcastMessage {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 users_per_second */ 1:
          message.users_per_second = reader.uint32();
          break;
        case /* optional bool send_to_users */ 2:
          message.send_to_users = reader.bool();
          break;
        case /* optional bool send_to_servers */ 3:
          message.send_to_servers = reader.bool();
          break;
        case /* optional uint32 msg_id */ 4:
          message.msg_id = reader.uint32();
          break;
        case /* optional bytes msg_data */ 5:
          message.msg_data = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCMasterBroadcastMessage,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 users_per_second = 1; */
    if (message.users_per_second !== undefined) writer.tag(1, WireType.Varint).uint32(message.users_per_second);
    /* optional bool send_to_users = 2; */
    if (message.send_to_users !== undefined) writer.tag(2, WireType.Varint).bool(message.send_to_users);
    /* optional bool send_to_servers = 3; */
    if (message.send_to_servers !== undefined) writer.tag(3, WireType.Varint).bool(message.send_to_servers);
    /* optional uint32 msg_id = 4; */
    if (message.msg_id !== undefined) writer.tag(4, WireType.Varint).uint32(message.msg_id);
    /* optional bytes msg_data = 5; */
    if (message.msg_data !== undefined) writer.tag(5, WireType.LengthDelimited).bytes(message.msg_data);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCMasterBroadcastMessage
 */
export const CMsgGCToGCMasterBroadcastMessage = new CMsgGCToGCMasterBroadcastMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCMasterSubscribeToCache$Type extends MessageType<CMsgGCToGCMasterSubscribeToCache> {
  constructor() {
    super("CMsgGCToGCMasterSubscribeToCache", [
      {
        no: 1,
        name: "soid_type",
        kind: "scalar",
        localName: "soid_type",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "soid_id",
        kind: "scalar",
        localName: "soid_id",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "account_ids",
        kind: "scalar",
        localName: "account_ids",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "steam_ids",
        kind: "scalar",
        localName: "steam_ids",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCMasterSubscribeToCache>): CMsgGCToGCMasterSubscribeToCache {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.account_ids = [];
    message.steam_ids = [];
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCMasterSubscribeToCache>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCMasterSubscribeToCache,
  ): CMsgGCToGCMasterSubscribeToCache {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 soid_type */ 1:
          message.soid_type = reader.uint32();
          break;
        case /* optional fixed64 soid_id */ 2:
          message.soid_id = reader.fixed64().toBigInt();
          break;
        case /* repeated uint32 account_ids */ 3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.account_ids.push(reader.uint32());
          else message.account_ids.push(reader.uint32());
          break;
        case /* repeated fixed64 steam_ids */ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.steam_ids.push(reader.fixed64().toBigInt());
          else message.steam_ids.push(reader.fixed64().toBigInt());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCMasterSubscribeToCache,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 soid_type = 1; */
    if (message.soid_type !== undefined) writer.tag(1, WireType.Varint).uint32(message.soid_type);
    /* optional fixed64 soid_id = 2; */
    if (message.soid_id !== undefined) writer.tag(2, WireType.Bit64).fixed64(message.soid_id);
    /* repeated uint32 account_ids = 3; */
    for (let i = 0; i < message.account_ids.length; i++) writer.tag(3, WireType.Varint).uint32(message.account_ids[i]);
    /* repeated fixed64 steam_ids = 4; */
    for (let i = 0; i < message.steam_ids.length; i++) writer.tag(4, WireType.Bit64).fixed64(message.steam_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCMasterSubscribeToCache
 */
export const CMsgGCToGCMasterSubscribeToCache = new CMsgGCToGCMasterSubscribeToCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCMasterSubscribeToCacheResponse$Type extends MessageType<CMsgGCToGCMasterSubscribeToCacheResponse> {
  constructor() {
    super("CMsgGCToGCMasterSubscribeToCacheResponse", []);
  }
  create(value?: PartialMessage<CMsgGCToGCMasterSubscribeToCacheResponse>): CMsgGCToGCMasterSubscribeToCacheResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCMasterSubscribeToCacheResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCMasterSubscribeToCacheResponse,
  ): CMsgGCToGCMasterSubscribeToCacheResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CMsgGCToGCMasterSubscribeToCacheResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCMasterSubscribeToCacheResponse
 */
export const CMsgGCToGCMasterSubscribeToCacheResponse = new CMsgGCToGCMasterSubscribeToCacheResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCMasterSubscribeToCacheAsync$Type extends MessageType<CMsgGCToGCMasterSubscribeToCacheAsync> {
  constructor() {
    super("CMsgGCToGCMasterSubscribeToCacheAsync", [
      {
        no: 1,
        name: "subscribe_msg",
        kind: "message",
        localName: "subscribe_msg",
        T: () => CMsgGCToGCMasterSubscribeToCache,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCMasterSubscribeToCacheAsync>): CMsgGCToGCMasterSubscribeToCacheAsync {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCMasterSubscribeToCacheAsync>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCMasterSubscribeToCacheAsync,
  ): CMsgGCToGCMasterSubscribeToCacheAsync {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgGCToGCMasterSubscribeToCache subscribe_msg */ 1:
          message.subscribe_msg = CMsgGCToGCMasterSubscribeToCache.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.subscribe_msg,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCMasterSubscribeToCacheAsync,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgGCToGCMasterSubscribeToCache subscribe_msg = 1; */
    if (message.subscribe_msg)
      CMsgGCToGCMasterSubscribeToCache.internalBinaryWrite(
        message.subscribe_msg,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCMasterSubscribeToCacheAsync
 */
export const CMsgGCToGCMasterSubscribeToCacheAsync = new CMsgGCToGCMasterSubscribeToCacheAsync$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCMasterUnsubscribeFromCache$Type extends MessageType<CMsgGCToGCMasterUnsubscribeFromCache> {
  constructor() {
    super("CMsgGCToGCMasterUnsubscribeFromCache", [
      {
        no: 1,
        name: "soid_type",
        kind: "scalar",
        localName: "soid_type",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "soid_id",
        kind: "scalar",
        localName: "soid_id",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "account_ids",
        kind: "scalar",
        localName: "account_ids",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "steam_ids",
        kind: "scalar",
        localName: "steam_ids",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCMasterUnsubscribeFromCache>): CMsgGCToGCMasterUnsubscribeFromCache {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.account_ids = [];
    message.steam_ids = [];
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCMasterUnsubscribeFromCache>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCMasterUnsubscribeFromCache,
  ): CMsgGCToGCMasterUnsubscribeFromCache {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 soid_type */ 1:
          message.soid_type = reader.uint32();
          break;
        case /* optional fixed64 soid_id */ 2:
          message.soid_id = reader.fixed64().toBigInt();
          break;
        case /* repeated uint32 account_ids */ 3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.account_ids.push(reader.uint32());
          else message.account_ids.push(reader.uint32());
          break;
        case /* repeated fixed64 steam_ids */ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.steam_ids.push(reader.fixed64().toBigInt());
          else message.steam_ids.push(reader.fixed64().toBigInt());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCMasterUnsubscribeFromCache,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 soid_type = 1; */
    if (message.soid_type !== undefined) writer.tag(1, WireType.Varint).uint32(message.soid_type);
    /* optional fixed64 soid_id = 2; */
    if (message.soid_id !== undefined) writer.tag(2, WireType.Bit64).fixed64(message.soid_id);
    /* repeated uint32 account_ids = 3; */
    for (let i = 0; i < message.account_ids.length; i++) writer.tag(3, WireType.Varint).uint32(message.account_ids[i]);
    /* repeated fixed64 steam_ids = 4; */
    for (let i = 0; i < message.steam_ids.length; i++) writer.tag(4, WireType.Bit64).fixed64(message.steam_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCMasterUnsubscribeFromCache
 */
export const CMsgGCToGCMasterUnsubscribeFromCache = new CMsgGCToGCMasterUnsubscribeFromCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCMasterDestroyCache$Type extends MessageType<CMsgGCToGCMasterDestroyCache> {
  constructor() {
    super("CMsgGCToGCMasterDestroyCache", [
      {
        no: 1,
        name: "soid_type",
        kind: "scalar",
        localName: "soid_type",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "soid_id",
        kind: "scalar",
        localName: "soid_id",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgGCToGCMasterDestroyCache>): CMsgGCToGCMasterDestroyCache {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CMsgGCToGCMasterDestroyCache>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCMasterDestroyCache,
  ): CMsgGCToGCMasterDestroyCache {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 soid_type */ 1:
          message.soid_type = reader.uint32();
          break;
        case /* optional fixed64 soid_id */ 2:
          message.soid_id = reader.fixed64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCMasterDestroyCache,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 soid_type = 1; */
    if (message.soid_type !== undefined) writer.tag(1, WireType.Varint).uint32(message.soid_type);
    /* optional fixed64 soid_id = 2; */
    if (message.soid_id !== undefined) writer.tag(2, WireType.Bit64).fixed64(message.soid_id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCMasterDestroyCache
 */
export const CMsgGCToGCMasterDestroyCache = new CMsgGCToGCMasterDestroyCache$Type();

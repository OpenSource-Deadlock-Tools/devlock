// @generated by protobuf-ts 2.9.4 with parameter use_proto_field_name
// @generated from protobuf file "citadel_usermessages.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CMsgSosSetLibraryStackFields } from "./gameevents.js";
import { CMsgSosSetSoundEventParams } from "./gameevents.js";
import { CMsgSosStopSoundEventHash } from "./gameevents.js";
import { CMsgSosStopSoundEvent } from "./gameevents.js";
import { CMsgSosStartSoundEvent } from "./gameevents.js";
import { CMsgQAngle } from "./networkbasetypes.js";
import { CEntityMsg } from "./networkbasetypes.js";
import { CMsgMapLine } from "./citadel_gcmessages_common.js";
import { CMsgLaneColor } from "./citadel_gcmessages_common.js";
import { CMsgVector } from "./networkbasetypes.js";
/**
 * @generated from protobuf message CUserMessageEmpty
 */
export interface CUserMessageEmpty {
	/**
	 * @generated from protobuf field: optional uint32 empty = 1;
	 */
	empty?: number;
}
/**
 * @generated from protobuf message CCitadelUserMessage_Damage
 */
export interface CCitadelUserMessage_Damage {
	/**
	 * @generated from protobuf field: optional int32 damage = 1;
	 */
	damage?: number;
	/**
	 * @generated from protobuf field: optional int32 pre_damage = 2;
	 */
	pre_damage?: number;
	/**
	 * @generated from protobuf field: optional int32 type = 3;
	 */
	type?: number;
	/**
	 * @generated from protobuf field: optional int32 citadel_type = 4;
	 */
	citadel_type?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector origin = 5;
	 */
	origin?: CMsgVector;
	/**
	 * @generated from protobuf field: optional int32 entindex_victim = 6;
	 */
	entindex_victim?: number;
	/**
	 * @generated from protobuf field: optional int32 entindex_inflictor = 7;
	 */
	entindex_inflictor?: number;
	/**
	 * @generated from protobuf field: optional int32 entindex_attacker = 8;
	 */
	entindex_attacker?: number;
	/**
	 * @generated from protobuf field: optional int32 entindex_ability = 9;
	 */
	entindex_ability?: number;
	/**
	 * @generated from protobuf field: optional int32 damage_absorbed = 10;
	 */
	damage_absorbed?: number;
	/**
	 * @generated from protobuf field: optional int32 victim_health_max = 11;
	 */
	victim_health_max?: number;
	/**
	 * @generated from protobuf field: optional int32 victim_health_new = 12;
	 */
	victim_health_new?: number;
	/**
	 * @generated from protobuf field: optional uint64 flags = 13;
	 */
	flags?: bigint;
	/**
	 * @generated from protobuf field: optional uint32 ability_id = 14;
	 */
	ability_id?: number;
	/**
	 * @generated from protobuf field: optional uint32 attacker_class = 15;
	 */
	attacker_class?: number;
	/**
	 * @generated from protobuf field: optional uint32 victim_class = 16;
	 */
	victim_class?: number;
	/**
	 * @generated from protobuf field: optional int32 victim_shield_max = 17;
	 */
	victim_shield_max?: number;
	/**
	 * @generated from protobuf field: optional int32 victim_shield_new = 18;
	 */
	victim_shield_new?: number;
	/**
	 * @generated from protobuf field: optional int32 hits = 19;
	 */
	hits?: number;
	/**
	 * @generated from protobuf field: optional int32 health_lost = 20;
	 */
	health_lost?: number;
}
/**
 * @generated from protobuf message PingCommonData
 */
export interface PingCommonData {
	/**
	 * @generated from protobuf field: optional uint32 ping_message_id = 1;
	 */
	ping_message_id?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector ping_location = 2;
	 */
	ping_location?: CMsgVector;
	/**
	 * @generated from protobuf field: optional uint32 entity_index = 3;
	 */
	entity_index?: number;
	/**
	 * @generated from protobuf field: optional int32 sender_player_slot = 4;
	 */
	sender_player_slot?: number;
	/**
	 * @generated from protobuf field: optional int32 speech_concept = 5;
	 */
	speech_concept?: number;
	/**
	 * @generated from protobuf field: optional string response_chosen = 6;
	 */
	response_chosen?: string;
	/**
	 * @generated from protobuf field: optional float cooldown_time = 7;
	 */
	cooldown_time?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_MapPing
 */
export interface CCitadelUserMsg_MapPing {
	/**
	 * @generated from protobuf field: PingCommonData ping_data = 1;
	 */
	ping_data?: PingCommonData;
	/**
	 * @generated from protobuf field: optional uint32 event_type = 2;
	 */
	event_type?: number;
	/**
	 * @generated from protobuf field: optional ChatMsgPingMarkerInfo ping_marker_and_sound_info = 3;
	 */
	ping_marker_and_sound_info?: ChatMsgPingMarkerInfo;
	/**
	 * @generated from protobuf field: optional bool pinged_enemy_entity = 4;
	 */
	pinged_enemy_entity?: boolean;
	/**
	 * @generated from protobuf field: optional uint32 pinged_entity_class = 5;
	 */
	pinged_entity_class?: number;
	/**
	 * @generated from protobuf field: optional bool is_minimap_ping = 6;
	 */
	is_minimap_ping?: boolean;
	/**
	 * @generated from protobuf field: optional string pinged_hero_name = 7;
	 */
	pinged_hero_name?: string;
	/**
	 * @generated from protobuf field: optional bool is_blind_ping = 8;
	 */
	is_blind_ping?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_PingWheel
 */
export interface CCitadelUserMsg_PingWheel {
	/**
	 * @generated from protobuf field: PingCommonData ping_data = 1;
	 */
	ping_data?: PingCommonData;
	/**
	 * @generated from protobuf field: optional uint32 ping_wheel_option_id = 2;
	 */
	ping_wheel_option_id?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_AbilityPing
 */
export interface CCitadelUserMsg_AbilityPing {
	/**
	 * @generated from protobuf field: optional PingCommonData ping_data = 1;
	 */
	ping_data?: PingCommonData;
	/**
	 * @generated from protobuf field: optional uint32 ability_id = 2;
	 */
	ability_id?: number;
	/**
	 * @generated from protobuf field: optional float ability_cooldown = 3;
	 */
	ability_cooldown?: number;
	/**
	 * @generated from protobuf field: optional ChatMsgPingMarkerInfo ping_marker_and_sound_info = 4;
	 */
	ping_marker_and_sound_info?: ChatMsgPingMarkerInfo;
}
/**
 * @generated from protobuf message CCitadelUserMsg_QuickResponse
 */
export interface CCitadelUserMsg_QuickResponse {
	/**
	 * @generated from protobuf field: PingCommonData ping_data = 1;
	 */
	ping_data?: PingCommonData;
	/**
	 * @generated from protobuf field: optional uint32 responding_to_ping_message_id = 2;
	 */
	responding_to_ping_message_id?: number;
	/**
	 * @generated from protobuf field: optional int32 responding_to_player_slot = 3;
	 */
	responding_to_player_slot?: number;
	/**
	 * @generated from protobuf field: optional CMsgLaneColor lane_color = 4;
	 */
	lane_color?: CMsgLaneColor;
}
/**
 * @generated from protobuf message CCitadelUserMsg_MapLine
 */
export interface CCitadelUserMsg_MapLine {
	/**
	 * @generated from protobuf field: optional int32 sender_player_slot = 1;
	 */
	sender_player_slot?: number;
	/**
	 * @generated from protobuf field: optional CMsgMapLine mapline = 2;
	 */
	mapline?: CMsgMapLine;
}
/**
 * @generated from protobuf message CCitadelUserMsg_TeamRewards
 */
export interface CCitadelUserMsg_TeamRewards {
	/**
	 * @generated from protobuf field: optional uint32 xp = 1;
	 */
	xp?: number;
	/**
	 * @generated from protobuf field: optional uint32 gold = 2;
	 */
	gold?: number;
	/**
	 * @generated from protobuf field: optional bool winner = 3;
	 */
	winner?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_TriggerDamageFlash
 */
export interface CCitadelUserMsg_TriggerDamageFlash {
	/**
	 * @generated from protobuf field: optional int32 entindex_flash_victim = 1;
	 */
	entindex_flash_victim?: number;
	/**
	 * @generated from protobuf field: optional int32 entindex_flash_attacker = 2;
	 */
	entindex_flash_attacker?: number;
	/**
	 * @generated from protobuf field: optional int32 entindex_flash_hitgroup = 3;
	 */
	entindex_flash_hitgroup?: number;
	/**
	 * @generated from protobuf field: optional uint32 flash_value = 4;
	 */
	flash_value?: number;
	/**
	 * @generated from protobuf field: optional uint32 flash_type = 5;
	 */
	flash_type?: number;
	/**
	 * @generated from protobuf field: optional uint32 flash_flags = 6;
	 */
	flash_flags?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector flash_position = 7;
	 */
	flash_position?: CMsgVector;
}
/**
 * @generated from protobuf message CCitadelUserMsg_AbilitiesChanged
 */
export interface CCitadelUserMsg_AbilitiesChanged {
	/**
	 * @generated from protobuf field: optional int32 entindex_purchaser = 1;
	 */
	entindex_purchaser?: number;
	/**
	 * @generated from protobuf field: optional int32 entindex_ability = 2;
	 */
	entindex_ability?: number;
	/**
	 * @generated from protobuf field: optional uint32 ability_id = 3;
	 */
	ability_id?: number;
	/**
	 * @generated from protobuf field: optional CCitadelUserMsg_AbilitiesChanged.Change change = 4;
	 */
	change?: CCitadelUserMsg_AbilitiesChanged_Change;
}
/**
 * @generated from protobuf enum CCitadelUserMsg_AbilitiesChanged.Change
 */
export enum CCitadelUserMsg_AbilitiesChanged_Change {
	/**
	 * @generated from protobuf enum value: EInvalid = -1;
	 */
	EInvalid = -1,
	/**
	 * @generated from protobuf enum value: EPurchased = 0;
	 */
	EPurchased = 0,
	/**
	 * @generated from protobuf enum value: EUpgraded = 1;
	 */
	EUpgraded = 1,
	/**
	 * @generated from protobuf enum value: ESold = 2;
	 */
	ESold = 2,
	/**
	 * @generated from protobuf enum value: ESwappedActivatedAbility = 3;
	 */
	ESwappedActivatedAbility = 3,
}
/**
 * @generated from protobuf message CCitadelUserMsg_AbilityInterrupted
 */
export interface CCitadelUserMsg_AbilityInterrupted {
	/**
	 * @generated from protobuf field: optional int32 entindex_victim = 1;
	 */
	entindex_victim?: number;
	/**
	 * @generated from protobuf field: optional int32 entindex_interrupter = 2;
	 */
	entindex_interrupter?: number;
	/**
	 * @generated from protobuf field: optional uint32 ability_id_interrupted = 3;
	 */
	ability_id_interrupted?: number;
	/**
	 * @generated from protobuf field: optional uint32 ability_id_interrupter = 4;
	 */
	ability_id_interrupter?: number;
	/**
	 * @generated from protobuf field: optional uint32 hero_id_interrupter = 5;
	 */
	hero_id_interrupter?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_AbilityLateFailure
 */
export interface CCitadelUserMsg_AbilityLateFailure {
	/**
	 * @generated from protobuf field: optional int32 entindex_caster = 1;
	 */
	entindex_caster?: number;
	/**
	 * @generated from protobuf field: optional int32 entindex_ability = 2;
	 */
	entindex_ability?: number;
	/**
	 * @generated from protobuf field: optional uint32 failure_type = 3;
	 */
	failure_type?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_RecentDamageSummary
 */
export interface CCitadelUserMsg_RecentDamageSummary {
	/**
	 * @generated from protobuf field: optional int32 player_slot = 1;
	 */
	player_slot?: number;
	/**
	 * @generated from protobuf field: repeated CCitadelUserMsg_RecentDamageSummary.DamageRecord damage_records = 2;
	 */
	damage_records: CCitadelUserMsg_RecentDamageSummary_DamageRecord[];
	/**
	 * @generated from protobuf field: optional float start_time = 3;
	 */
	start_time?: number;
	/**
	 * @generated from protobuf field: optional float end_time = 4;
	 */
	end_time?: number;
	/**
	 * @generated from protobuf field: optional int32 total_damage = 5;
	 */
	total_damage?: number;
	/**
	 * @generated from protobuf field: optional int32 lost_gold = 6;
	 */
	lost_gold?: number;
	/**
	 * @generated from protobuf field: repeated CCitadelUserMsg_RecentDamageSummary.ModifierRecord modifier_records = 7;
	 */
	modifier_records: CCitadelUserMsg_RecentDamageSummary_ModifierRecord[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_RecentDamageSummary.DamageRecord
 */
export interface CCitadelUserMsg_RecentDamageSummary_DamageRecord {
	/**
	 * @generated from protobuf field: optional int32 damage = 1;
	 */
	damage?: number;
	/**
	 * @generated from protobuf field: optional int32 hits = 2;
	 */
	hits?: number;
	/**
	 * @generated from protobuf field: optional uint32 damage_type = 3;
	 */
	damage_type?: number;
	/**
	 * @generated from protobuf field: optional uint32 hero_id = 4;
	 */
	hero_id?: number;
	/**
	 * @generated from protobuf field: optional uint32 ability_id = 5;
	 */
	ability_id?: number;
	/**
	 * @generated from protobuf field: optional uint32 attacker_class = 6;
	 */
	attacker_class?: number;
	/**
	 * @generated from protobuf field: optional int32 damage_absorbed = 7;
	 */
	damage_absorbed?: number;
	/**
	 * @generated from protobuf field: optional bool is_killing_blow = 8;
	 */
	is_killing_blow?: boolean;
	/**
	 * @generated from protobuf field: optional uint32 victim_hero_id = 9;
	 */
	victim_hero_id?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_RecentDamageSummary.ModifierRecord
 */
export interface CCitadelUserMsg_RecentDamageSummary_ModifierRecord {
	/**
	 * @generated from protobuf field: optional uint32 ability_id = 1;
	 */
	ability_id?: number;
	/**
	 * @generated from protobuf field: optional uint32 modifier_type_id = 2;
	 */
	modifier_type_id?: number;
	/**
	 * @generated from protobuf field: optional int32 entindex_caster = 3;
	 */
	entindex_caster?: number;
	/**
	 * @generated from protobuf field: optional float start_time = 4;
	 */
	start_time?: number;
	/**
	 * @generated from protobuf field: optional float end_time = 5;
	 */
	end_time?: number;
	/**
	 * @generated from protobuf field: optional bool debuff = 6;
	 */
	debuff?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_SpectatorTeamChanged
 */
export interface CCitadelUserMsg_SpectatorTeamChanged {
	/**
	 * @generated from protobuf field: optional int32 teamnumber = 1;
	 */
	teamnumber?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_ChatWheel
 */
export interface CCitadelUserMsg_ChatWheel {
	/**
	 * @generated from protobuf field: optional uint32 chat_message_id = 1;
	 */
	chat_message_id?: number;
	/**
	 * @generated from protobuf field: optional int32 player_slot = 2;
	 */
	player_slot?: number;
	/**
	 * @generated from protobuf field: optional int32 pawn_entindex = 3;
	 */
	pawn_entindex?: number;
	/**
	 * @generated from protobuf field: optional uint32 account_id = 4;
	 */
	account_id?: number;
	/**
	 * @generated from protobuf field: optional uint32 hero_id = 5;
	 */
	hero_id?: number;
	/**
	 * @generated from protobuf field: optional string param_1 = 6;
	 */
	param_1?: string;
	/**
	 * @generated from protobuf field: optional CMsgLaneColor lane_color = 7;
	 */
	lane_color?: CMsgLaneColor;
}
/**
 * @generated from protobuf message CCitadelUserMsg_ChatMsg
 */
export interface CCitadelUserMsg_ChatMsg {
	/**
	 * @generated from protobuf field: optional int32 player_slot = 1;
	 */
	player_slot?: number;
	/**
	 * @generated from protobuf field: optional string text = 2;
	 */
	text?: string;
	/**
	 * @generated from protobuf field: optional bool all_chat = 3;
	 */
	all_chat?: boolean;
	/**
	 * @generated from protobuf field: optional CMsgLaneColor lane_color = 4;
	 */
	lane_color?: CMsgLaneColor;
}
/**
 * @generated from protobuf message CCitadelUserMsg_GoldHistory
 */
export interface CCitadelUserMsg_GoldHistory {
	/**
	 * @generated from protobuf field: optional int32 entindex_player = 1;
	 */
	entindex_player?: number;
	/**
	 * @generated from protobuf field: repeated CCitadelUserMsg_GoldHistory.MinuteRecord minute_records = 2;
	 */
	minute_records: CCitadelUserMsg_GoldHistory_MinuteRecord[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_GoldHistory.GoldRecord
 */
export interface CCitadelUserMsg_GoldHistory_GoldRecord {
	/**
	 * @generated from protobuf field: optional int32 currency_source = 1;
	 */
	currency_source?: number;
	/**
	 * @generated from protobuf field: optional int32 gold = 2;
	 */
	gold?: number;
	/**
	 * @generated from protobuf field: optional int32 events = 3;
	 */
	events?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_GoldHistory.MinuteRecord
 */
export interface CCitadelUserMsg_GoldHistory_MinuteRecord {
	/**
	 * @generated from protobuf field: optional int32 match_minute = 1;
	 */
	match_minute?: number;
	/**
	 * @generated from protobuf field: repeated CCitadelUserMsg_GoldHistory.GoldRecord gold_records = 2;
	 */
	gold_records: CCitadelUserMsg_GoldHistory_GoldRecord[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_CameraController
 */
export interface CCitadelUserMsg_CameraController {
	/**
	 * @generated from protobuf field: CameraAction action = 1;
	 */
	action: CameraAction;
	/**
	 * @generated from protobuf field: optional CameraOperation operation = 2;
	 */
	operation?: CameraOperation;
	/**
	 * @generated from protobuf field: optional CameraParam param = 3;
	 */
	param?: CameraParam;
	/**
	 * @generated from protobuf field: optional CameraParamMode param_mode = 12;
	 */
	param_mode?: CameraParamMode;
	/**
	 * @generated from protobuf field: optional float delay = 4;
	 */
	delay?: number;
	/**
	 * @generated from protobuf field: optional bool relative_values = 11;
	 */
	relative_values?: boolean;
	/**
	 * @generated from protobuf field: optional uint32 context_symbol_id = 5;
	 */
	context_symbol_id?: number;
	/**
	 * @generated from protobuf field: optional uint32 priority = 13;
	 */
	priority?: number;
	/**
	 * @generated from protobuf field: optional CCitadelUserMsg_CameraController.Maintain maintain = 6;
	 */
	maintain?: CCitadelUserMsg_CameraController_Maintain;
	/**
	 * @generated from protobuf field: optional CCitadelUserMsg_CameraController.Approach approach = 7;
	 */
	approach?: CCitadelUserMsg_CameraController_Approach;
	/**
	 * @generated from protobuf field: optional CCitadelUserMsg_CameraController.Spring spring = 8;
	 */
	spring?: CCitadelUserMsg_CameraController_Spring;
	/**
	 * @generated from protobuf field: optional CCitadelUserMsg_CameraController.Lerp lerp = 9;
	 */
	lerp?: CCitadelUserMsg_CameraController_Lerp;
	/**
	 * @generated from protobuf field: optional CCitadelUserMsg_CameraController.Lag lag = 10;
	 */
	lag?: CCitadelUserMsg_CameraController_Lag;
}
/**
 * @generated from protobuf message CCitadelUserMsg_CameraController.Maintain
 */
export interface CCitadelUserMsg_CameraController_Maintain {
	/**
	 * @generated from protobuf field: optional float duration = 1;
	 */
	duration?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector maintain_vector = 2;
	 */
	maintain_vector?: CMsgVector;
	/**
	 * @generated from protobuf field: optional float maintain_float = 3;
	 */
	maintain_float?: number;
	/**
	 * @generated from protobuf field: optional bool maintain_current = 4;
	 */
	maintain_current?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_CameraController.Approach
 */
export interface CCitadelUserMsg_CameraController_Approach {
	/**
	 * @generated from protobuf field: optional float speed = 1;
	 */
	speed?: number;
	/**
	 * @generated from protobuf field: optional float default_speed = 2;
	 */
	default_speed?: number;
	/**
	 * @generated from protobuf field: optional float acceleration = 3;
	 */
	acceleration?: number;
	/**
	 * @generated from protobuf field: optional float min_duration = 4;
	 */
	min_duration?: number;
	/**
	 * @generated from protobuf field: optional float approach_float = 5;
	 */
	approach_float?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector approach_vector = 6;
	 */
	approach_vector?: CMsgVector;
	/**
	 * @generated from protobuf field: optional bool chase_default = 7;
	 */
	chase_default?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_CameraController.Spring
 */
export interface CCitadelUserMsg_CameraController_Spring {
	/**
	 * @generated from protobuf field: optional float spring_strength = 1;
	 */
	spring_strength?: number;
	/**
	 * @generated from protobuf field: optional float min_speed = 4;
	 */
	min_speed?: number;
	/**
	 * @generated from protobuf field: optional float max_duration = 5;
	 */
	max_duration?: number;
	/**
	 * @generated from protobuf field: optional float target_float = 6;
	 */
	target_float?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector target_vector = 7;
	 */
	target_vector?: CMsgVector;
}
/**
 * @generated from protobuf message CCitadelUserMsg_CameraController.Lerp
 */
export interface CCitadelUserMsg_CameraController_Lerp {
	/**
	 * @generated from protobuf field: optional float start_float = 1;
	 */
	start_float?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector start_vector = 2;
	 */
	start_vector?: CMsgVector;
	/**
	 * @generated from protobuf field: optional float end_float = 3;
	 */
	end_float?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector end_vector = 4;
	 */
	end_vector?: CMsgVector;
	/**
	 * @generated from protobuf field: optional float bias = 5;
	 */
	bias?: number;
	/**
	 * @generated from protobuf field: optional float gain = 6;
	 */
	gain?: number;
	/**
	 * @generated from protobuf field: optional float duration = 7;
	 */
	duration?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_CameraController.Lag
 */
export interface CCitadelUserMsg_CameraController_Lag {
	/**
	 * @generated from protobuf field: optional float min_duration = 1;
	 */
	min_duration?: number;
	/**
	 * @generated from protobuf field: optional float lag_time = 2;
	 */
	lag_time?: number;
	/**
	 * @generated from protobuf field: optional float max_speed = 3;
	 */
	max_speed?: number;
	/**
	 * @generated from protobuf field: optional float spring_strength = 4;
	 */
	spring_strength?: number;
	/**
	 * @generated from protobuf field: optional bool increase_spring_strength_to_keep_target_on_screen = 5;
	 */
	increase_spring_strength_to_keep_target_on_screen?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_PostMatchDetails
 */
export interface CCitadelUserMsg_PostMatchDetails {
	/**
	 * @generated from protobuf field: optional bytes match_details = 1;
	 */
	match_details?: Uint8Array;
}
/**
 * @generated from protobuf message CCitadelUserMsg_ChatEvent
 */
export interface CCitadelUserMsg_ChatEvent {
	/**
	 * @generated from protobuf field: optional ECitadelChatMessage type = 1;
	 */
	type?: ECitadelChatMessage;
	/**
	 * @generated from protobuf field: repeated uint32 values = 2;
	 */
	values: number[];
	/**
	 * @generated from protobuf field: repeated int32 player_slots = 3;
	 */
	player_slots: number[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_HeroKilled
 */
export interface CCitadelUserMsg_HeroKilled {
	/**
	 * @generated from protobuf field: optional int32 entindex_victim = 1;
	 */
	entindex_victim?: number;
	/**
	 * @generated from protobuf field: optional int32 entindex_inflictor = 2;
	 */
	entindex_inflictor?: number;
	/**
	 * @generated from protobuf field: optional int32 entindex_attacker = 3;
	 */
	entindex_attacker?: number;
	/**
	 * @generated from protobuf field: repeated int32 entindex_assisters = 4;
	 */
	entindex_assisters: number[];
	/**
	 * @generated from protobuf field: optional int32 entindex_scorer = 5;
	 */
	entindex_scorer?: number;
	/**
	 * @generated from protobuf field: optional int32 respawn_reason = 6;
	 */
	respawn_reason?: number;
	/**
	 * @generated from protobuf field: optional int32 victim_team_number = 7;
	 */
	victim_team_number?: number;
}
/**
 * @generated from protobuf message CCitadelEntityMsg_BreakablePropSpawnDebris
 */
export interface CCitadelEntityMsg_BreakablePropSpawnDebris {
	/**
	 * @generated from protobuf field: optional CEntityMsg entity_msg = 1;
	 */
	entity_msg?: CEntityMsg;
	/**
	 * @generated from protobuf field: optional CMsgVector damage_pos = 2;
	 */
	damage_pos?: CMsgVector;
	/**
	 * @generated from protobuf field: optional float damage = 3;
	 */
	damage?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_ReturnIdol
 */
export interface CCitadelUserMsg_ReturnIdol {
	/**
	 * @generated from protobuf field: optional int32 location_index = 1;
	 */
	location_index?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector return_location = 2;
	 */
	return_location?: CMsgVector;
	/**
	 * @generated from protobuf field: optional bool location_enabled = 3;
	 */
	location_enabled?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_SetClientCameraAngles
 */
export interface CCitadelUserMsg_SetClientCameraAngles {
	/**
	 * @generated from protobuf field: optional int32 player_slot = 1;
	 */
	player_slot?: number;
	/**
	 * @generated from protobuf field: optional CMsgQAngle camera_angles = 2;
	 */
	camera_angles?: CMsgQAngle;
}
/**
 * @generated from protobuf message CCitadelUserMessage_BulletHit
 */
export interface CCitadelUserMessage_BulletHit {
	/**
	 * @generated from protobuf field: optional int32 shotid = 1;
	 */
	shotid?: number;
	/**
	 * @generated from protobuf field: optional int32 pellet = 2;
	 */
	pellet?: number;
	/**
	 * @generated from protobuf field: optional int32 hit_entindex = 3;
	 */
	hit_entindex?: number;
}
/**
 * @generated from protobuf message CCitadelUserMessage_ObjectiveMask
 */
export interface CCitadelUserMessage_ObjectiveMask {
	/**
	 * @generated from protobuf field: optional uint64 objective_mask_team0 = 2;
	 */
	objective_mask_team0?: bigint;
	/**
	 * @generated from protobuf field: optional uint64 objective_mask_team1 = 3;
	 */
	objective_mask_team1?: bigint;
}
/**
 * @generated from protobuf message CCitadelUserMessage_ModifierApplied
 */
export interface CCitadelUserMessage_ModifierApplied {
	/**
	 * @generated from protobuf field: optional int32 entindex_caster = 1;
	 */
	entindex_caster?: number;
	/**
	 * @generated from protobuf field: optional int32 entindex_parent = 2;
	 */
	entindex_parent?: number;
	/**
	 * @generated from protobuf field: optional int32 serial_number = 3;
	 */
	serial_number?: number;
}
/**
 * @generated from protobuf message CCitadelUserMessage_AuraModifierApplied
 */
export interface CCitadelUserMessage_AuraModifierApplied {
	/**
	 * @generated from protobuf field: optional int32 entindex_caster = 1;
	 */
	entindex_caster?: number;
	/**
	 * @generated from protobuf field: optional int32 entindex_target = 2;
	 */
	entindex_target?: number;
	/**
	 * @generated from protobuf field: optional uint32 modifier_type_id = 3;
	 */
	modifier_type_id?: number;
	/**
	 * @generated from protobuf field: optional int32 modifier_serial_number = 4;
	 */
	modifier_serial_number?: number;
	/**
	 * @generated from protobuf field: optional float aura_start_time = 5;
	 */
	aura_start_time?: number;
	/**
	 * @generated from protobuf field: optional float aura_end_time = 6;
	 */
	aura_end_time?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_ObstructedShotFired
 */
export interface CCitadelUserMsg_ObstructedShotFired {}
/**
 * @generated from protobuf message CCitadelUserMsg_PostProcessingAnim
 */
export interface CCitadelUserMsg_PostProcessingAnim {
	/**
	 * @generated from protobuf field: optional int32 entindex_owner = 1;
	 */
	entindex_owner?: number;
	/**
	 * @generated from protobuf field: optional bool clear_all_states = 2;
	 */
	clear_all_states?: boolean;
	/**
	 * @generated from protobuf field: optional PostProcessingGameStates state = 3;
	 */
	state?: PostProcessingGameStates;
	/**
	 * @generated from protobuf field: optional float start_time = 4;
	 */
	start_time?: number;
	/**
	 * @generated from protobuf field: optional float fade_in_time = 5;
	 */
	fade_in_time?: number;
	/**
	 * @generated from protobuf field: optional float hold_time = 6;
	 */
	hold_time?: number;
	/**
	 * @generated from protobuf field: optional float fade_out_time = 7;
	 */
	fade_out_time?: number;
	/**
	 * @generated from protobuf field: optional float scale = 8;
	 */
	scale?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_DeathReplayData
 */
export interface CCitadelUserMsg_DeathReplayData {
	/**
	 * @generated from protobuf field: optional int32 killer_scorer = 1;
	 */
	killer_scorer?: number;
	/**
	 * @generated from protobuf field: optional int32 killer_inflictor = 2;
	 */
	killer_inflictor?: number;
	/**
	 * @generated from protobuf field: optional CCitadelUserMsg_RecentDamageSummary damage_summary = 3;
	 */
	damage_summary?: CCitadelUserMsg_RecentDamageSummary;
}
/**
 * @generated from protobuf message CCitadelUserMsg_ForceShopClosed
 */
export interface CCitadelUserMsg_ForceShopClosed {}
/**
 * @generated from protobuf message CCitadelUserMsg_PlayerLifetimeStatInfo
 */
export interface CCitadelUserMsg_PlayerLifetimeStatInfo {
	/**
	 * @generated from protobuf field: repeated CCitadelUserMsg_PlayerLifetimeStatInfo.Stat stats = 1;
	 */
	stats: CCitadelUserMsg_PlayerLifetimeStatInfo_Stat[];
	/**
	 * @generated from protobuf field: optional uint64 match_id = 2;
	 */
	match_id?: bigint;
	/**
	 * @generated from protobuf field: optional bool end_of_match = 3;
	 */
	end_of_match?: boolean;
	/**
	 * @generated from protobuf field: optional bool is_official_match = 4;
	 */
	is_official_match?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_PlayerLifetimeStatInfo.Stat
 */
export interface CCitadelUserMsg_PlayerLifetimeStatInfo_Stat {
	/**
	 * @generated from protobuf field: optional string stat_name = 1;
	 */
	stat_name?: string;
	/**
	 * @generated from protobuf field: optional uint32 match_total = 2;
	 */
	match_total?: number;
	/**
	 * @generated from protobuf field: optional uint32 lifetime_value = 3;
	 */
	lifetime_value?: number;
	/**
	 * @generated from protobuf field: optional uint32 priority = 4;
	 */
	priority?: number;
	/**
	 * @generated from protobuf field: optional uint32 prev_lifetime_max = 5;
	 */
	prev_lifetime_max?: number;
	/**
	 * @generated from protobuf field: optional uint32 stat_type = 6;
	 */
	stat_type?: number;
	/**
	 * @generated from protobuf field: optional uint32 stat_type_id = 7;
	 */
	stat_type_id?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_StaminaDrained
 */
export interface CCitadelUserMsg_StaminaDrained {
	/**
	 * @generated from protobuf field: optional int32 entindex_victim = 1;
	 */
	entindex_victim?: number;
	/**
	 * @generated from protobuf field: optional int32 stamina_drained = 2;
	 */
	stamina_drained?: number;
}
/**
 * @generated from protobuf message CCitadelUserMessage_AbilityNotify
 */
export interface CCitadelUserMessage_AbilityNotify {
	/**
	 * @generated from protobuf field: optional int32 entindex_victim = 1;
	 */
	entindex_victim?: number;
	/**
	 * @generated from protobuf field: optional int32 entindex_attacker = 2;
	 */
	entindex_attacker?: number;
	/**
	 * @generated from protobuf field: optional uint32 ability_id = 3;
	 */
	ability_id?: number;
}
/**
 * @generated from protobuf message CCitadelUserMessage_CurrencyChanged
 */
export interface CCitadelUserMessage_CurrencyChanged {
	/**
	 * @generated from protobuf field: optional int32 entindex_hero_pawn = 1;
	 */
	entindex_hero_pawn?: number;
	/**
	 * @generated from protobuf field: optional int32 currency_type = 2;
	 */
	currency_type?: number;
	/**
	 * @generated from protobuf field: optional int32 currency_source = 3;
	 */
	currency_source?: number;
	/**
	 * @generated from protobuf field: optional int32 delta = 4;
	 */
	delta?: number;
	/**
	 * @generated from protobuf field: optional bool notification = 5;
	 */
	notification?: boolean;
	/**
	 * @generated from protobuf field: optional int32 entindex_victim = 6;
	 */
	entindex_victim?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector victim_pos = 7;
	 */
	victim_pos?: CMsgVector;
	/**
	 * @generated from protobuf field: optional int32 playsound = 8;
	 */
	playsound?: number;
	/**
	 * @generated from protobuf field: optional uint32 ability_id = 9;
	 */
	ability_id?: number;
}
/**
 * @generated from protobuf message CCitadelUserMessage_GameOver
 */
export interface CCitadelUserMessage_GameOver {
	/**
	 * @generated from protobuf field: optional int32 winning_team = 1;
	 */
	winning_team?: number;
	/**
	 * @generated from protobuf field: optional bool just_a_test = 2;
	 */
	just_a_test?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_GetDamageStatsResponse
 */
export interface CCitadelUserMsg_GetDamageStatsResponse {
	/**
	 * @generated from protobuf field: optional uint32 player_slot = 1;
	 */
	player_slot?: number;
	/**
	 * @generated from protobuf field: optional string ability_name = 2;
	 */
	ability_name?: string;
	/**
	 * @generated from protobuf field: optional CCitadelUserMsg_GetDamageStatsResponse.StatType damage = 3;
	 */
	damage?: CCitadelUserMsg_GetDamageStatsResponse_StatType;
	/**
	 * @generated from protobuf field: optional CCitadelUserMsg_GetDamageStatsResponse.StatType healing = 4;
	 */
	healing?: CCitadelUserMsg_GetDamageStatsResponse_StatType;
}
/**
 * @generated from protobuf message CCitadelUserMsg_GetDamageStatsResponse.StatType
 */
export interface CCitadelUserMsg_GetDamageStatsResponse_StatType {
	/**
	 * @generated from protobuf field: repeated uint32 target_player_slot = 1 [packed = true];
	 */
	target_player_slot: number[];
	/**
	 * @generated from protobuf field: repeated uint32 value = 2 [packed = true];
	 */
	value: number[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_ParticipantStartSoundEvent
 */
export interface CCitadelUserMsg_ParticipantStartSoundEvent {
	/**
	 * @generated from protobuf field: CMsgSosStartSoundEvent event = 1;
	 */
	event?: CMsgSosStartSoundEvent;
	/**
	 * @generated from protobuf field: repeated int32 player_slots = 2;
	 */
	player_slots: number[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_ParticipantStopSoundEvent
 */
export interface CCitadelUserMsg_ParticipantStopSoundEvent {
	/**
	 * @generated from protobuf field: CMsgSosStopSoundEvent event = 1;
	 */
	event?: CMsgSosStopSoundEvent;
	/**
	 * @generated from protobuf field: repeated int32 player_slots = 2;
	 */
	player_slots: number[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_ParticipantStopSoundEventHash
 */
export interface CCitadelUserMsg_ParticipantStopSoundEventHash {
	/**
	 * @generated from protobuf field: CMsgSosStopSoundEventHash event = 1;
	 */
	event?: CMsgSosStopSoundEventHash;
	/**
	 * @generated from protobuf field: repeated int32 player_slots = 2;
	 */
	player_slots: number[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_ParticipantSetSoundEventParams
 */
export interface CCitadelUserMsg_ParticipantSetSoundEventParams {
	/**
	 * @generated from protobuf field: CMsgSosSetSoundEventParams event = 1;
	 */
	event?: CMsgSosSetSoundEventParams;
	/**
	 * @generated from protobuf field: repeated int32 player_slots = 2;
	 */
	player_slots: number[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_ParticipantSetLibraryStackFields
 */
export interface CCitadelUserMsg_ParticipantSetLibraryStackFields {
	/**
	 * @generated from protobuf field: CMsgSosSetLibraryStackFields event = 1;
	 */
	event?: CMsgSosSetLibraryStackFields;
	/**
	 * @generated from protobuf field: repeated int32 player_slots = 2;
	 */
	player_slots: number[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_BossKilled
 */
export interface CCitadelUserMsg_BossKilled {
	/**
	 * @generated from protobuf field: optional int32 objective_team = 1;
	 */
	objective_team?: number;
	/**
	 * @generated from protobuf field: optional int32 objective_mask_change = 2;
	 */
	objective_mask_change?: number;
	/**
	 * @generated from protobuf field: optional uint32 entity_killed = 3;
	 */
	entity_killed?: number;
	/**
	 * @generated from protobuf field: optional int32 entity_killed_class = 4;
	 */
	entity_killed_class?: number;
	/**
	 * @generated from protobuf field: optional uint32 entity_killer = 5;
	 */
	entity_killer?: number;
	/**
	 * @generated from protobuf field: optional float gametime = 6;
	 */
	gametime?: number;
	/**
	 * @generated from protobuf field: optional int32 bosses_remaining = 7;
	 */
	bosses_remaining?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector entity_position = 8;
	 */
	entity_position?: CMsgVector;
}
/**
 * @generated from protobuf message CCitadelUserMsg_BossDamaged
 */
export interface CCitadelUserMsg_BossDamaged {
	/**
	 * @generated from protobuf field: int32 objective_team = 1;
	 */
	objective_team: number;
	/**
	 * @generated from protobuf field: int32 objective_id = 2;
	 */
	objective_id: number;
	/**
	 * @generated from protobuf field: uint32 entity_damaged = 3;
	 */
	entity_damaged: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_MidBossSpawned
 */
export interface CCitadelUserMsg_MidBossSpawned {}
/**
 * @generated from protobuf message CCitadelUserMsg_RejuvStatus
 */
export interface CCitadelUserMsg_RejuvStatus {
	/**
	 * @generated from protobuf field: optional int32 killing_team = 1;
	 */
	killing_team?: number;
	/**
	 * @generated from protobuf field: uint32 player_pawn = 2;
	 */
	player_pawn: number;
	/**
	 * @generated from protobuf field: int32 user_team = 3;
	 */
	user_team: number;
	/**
	 * @generated from protobuf field: int32 event_type = 4;
	 */
	event_type: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_KillStreak
 */
export interface CCitadelUserMsg_KillStreak {
	/**
	 * @generated from protobuf field: uint32 player_pawn = 1;
	 */
	player_pawn: number;
	/**
	 * @generated from protobuf field: int32 num_kills = 2;
	 */
	num_kills: number;
	/**
	 * @generated from protobuf field: bool is_first_blood = 3;
	 */
	is_first_blood: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_TeamMsg
 */
export interface CCitadelUserMsg_TeamMsg {
	/**
	 * @generated from protobuf field: int32 event_type = 1;
	 */
	event_type: number;
	/**
	 * @generated from protobuf field: int32 team_number = 2;
	 */
	team_number: number;
	/**
	 * @generated from protobuf field: int32 lane_color = 3;
	 */
	lane_color: number;
	/**
	 * @generated from protobuf field: uint32 player_controller = 4;
	 */
	player_controller: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_PlayerRespawned
 */
export interface CCitadelUserMsg_PlayerRespawned {
	/**
	 * @generated from protobuf field: uint32 player_pawn = 1;
	 */
	player_pawn: number;
	/**
	 * @generated from protobuf field: float facing_yaw = 2;
	 */
	facing_yaw: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_CallCheaterVote
 */
export interface CCitadelUserMsg_CallCheaterVote {
	/**
	 * @generated from protobuf field: int32 player_slot = 1;
	 */
	player_slot: number;
}
/**
 * @generated from protobuf enum CitadelUserMessageIds
 */
export enum CitadelUserMessageIds {
	/**
	 * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
	 */
	UNSPECIFIED$ = 0,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_Damage = 300;
	 */
	k_EUserMsg_Damage = 300,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_MapPing = 303;
	 */
	k_EUserMsg_MapPing = 303,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_TeamRewards = 304;
	 */
	k_EUserMsg_TeamRewards = 304,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_AbilityFailed = 306;
	 */
	k_EUserMsg_AbilityFailed = 306,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_TriggerDamageFlash = 308;
	 */
	k_EUserMsg_TriggerDamageFlash = 308,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_AbilitiesChanged = 309;
	 */
	k_EUserMsg_AbilitiesChanged = 309,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_RecentDamageSummary = 310;
	 */
	k_EUserMsg_RecentDamageSummary = 310,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_SpectatorTeamChanged = 311;
	 */
	k_EUserMsg_SpectatorTeamChanged = 311,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_ChatWheel = 312;
	 */
	k_EUserMsg_ChatWheel = 312,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_GoldHistory = 313;
	 */
	k_EUserMsg_GoldHistory = 313,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_ChatMsg = 314;
	 */
	k_EUserMsg_ChatMsg = 314,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_QuickResponse = 315;
	 */
	k_EUserMsg_QuickResponse = 315,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_PostMatchDetails = 316;
	 */
	k_EUserMsg_PostMatchDetails = 316,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_ChatEvent = 317;
	 */
	k_EUserMsg_ChatEvent = 317,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_AbilityInterrupted = 318;
	 */
	k_EUserMsg_AbilityInterrupted = 318,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_HeroKilled = 319;
	 */
	k_EUserMsg_HeroKilled = 319,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_ReturnIdol = 320;
	 */
	k_EUserMsg_ReturnIdol = 320,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_SetClientCameraAngles = 321;
	 */
	k_EUserMsg_SetClientCameraAngles = 321,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_MapLine = 322;
	 */
	k_EUserMsg_MapLine = 322,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_BulletHit = 323;
	 */
	k_EUserMsg_BulletHit = 323,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_ObjectiveMask = 324;
	 */
	k_EUserMsg_ObjectiveMask = 324,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_ModifierApplied = 325;
	 */
	k_EUserMsg_ModifierApplied = 325,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_CameraController = 326;
	 */
	k_EUserMsg_CameraController = 326,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_AuraModifierApplied = 327;
	 */
	k_EUserMsg_AuraModifierApplied = 327,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_ObstructedShotFired = 329;
	 */
	k_EUserMsg_ObstructedShotFired = 329,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_AbilityLateFailure = 330;
	 */
	k_EUserMsg_AbilityLateFailure = 330,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_AbilityPing = 331;
	 */
	k_EUserMsg_AbilityPing = 331,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_PostProcessingAnim = 332;
	 */
	k_EUserMsg_PostProcessingAnim = 332,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_DeathReplayData = 333;
	 */
	k_EUserMsg_DeathReplayData = 333,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_PlayerLifetimeStatInfo = 334;
	 */
	k_EUserMsg_PlayerLifetimeStatInfo = 334,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_ForceShopClosed = 336;
	 */
	k_EUserMsg_ForceShopClosed = 336,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_StaminaDrained = 337;
	 */
	k_EUserMsg_StaminaDrained = 337,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_AbilityNotify = 338;
	 */
	k_EUserMsg_AbilityNotify = 338,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_GetDamageStatsResponse = 339;
	 */
	k_EUserMsg_GetDamageStatsResponse = 339,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_ParticipantStartSoundEvent = 340;
	 */
	k_EUserMsg_ParticipantStartSoundEvent = 340,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_ParticipantStopSoundEvent = 341;
	 */
	k_EUserMsg_ParticipantStopSoundEvent = 341,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_ParticipantStopSoundEventHash = 342;
	 */
	k_EUserMsg_ParticipantStopSoundEventHash = 342,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_ParticipantSetSoundEventParams = 343;
	 */
	k_EUserMsg_ParticipantSetSoundEventParams = 343,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_ParticipantSetLibraryStackFields = 344;
	 */
	k_EUserMsg_ParticipantSetLibraryStackFields = 344,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_CurrencyChanged = 345;
	 */
	k_EUserMsg_CurrencyChanged = 345,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_GameOver = 346;
	 */
	k_EUserMsg_GameOver = 346,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_BossKilled = 347;
	 */
	k_EUserMsg_BossKilled = 347,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_BossDamaged = 348;
	 */
	k_EUserMsg_BossDamaged = 348,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_MidBossSpawned = 349;
	 */
	k_EUserMsg_MidBossSpawned = 349,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_RejuvStatus = 350;
	 */
	k_EUserMsg_RejuvStatus = 350,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_KillStreak = 351;
	 */
	k_EUserMsg_KillStreak = 351,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_TeamMsg = 352;
	 */
	k_EUserMsg_TeamMsg = 352,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_PlayerRespawned = 353;
	 */
	k_EUserMsg_PlayerRespawned = 353,
	/**
	 * @generated from protobuf enum value: k_EUserMsg_CallCheaterVote = 354;
	 */
	k_EUserMsg_CallCheaterVote = 354,
}
/**
 * @generated from protobuf enum CitadelEntityMessageIds
 */
export enum CitadelEntityMessageIds {
	/**
	 * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
	 */
	UNSPECIFIED$ = 0,
	/**
	 * @generated from protobuf enum value: k_EEntityMsg_BreakablePropSpawnDebris = 500;
	 */
	k_EEntityMsg_BreakablePropSpawnDebris = 500,
}
/**
 * @generated from protobuf enum ChatMsgPingMarkerInfo
 */
export enum ChatMsgPingMarkerInfo {
	/**
	 * @generated from protobuf enum value: k_EPingMarkerInfo_ShowMarkerAndSound = 0;
	 */
	k_EPingMarkerInfo_ShowMarkerAndSound = 0,
	/**
	 * @generated from protobuf enum value: k_EPingMarkerInfo_HideMarkerAndSound = 1;
	 */
	k_EPingMarkerInfo_HideMarkerAndSound = 1,
	/**
	 * @generated from protobuf enum value: k_EPingMarkerInfo_ShowMarkerOnSender = 2;
	 */
	k_EPingMarkerInfo_ShowMarkerOnSender = 2,
	/**
	 * @generated from protobuf enum value: k_EPingMarkerInfo_OnlyShowMarker = 3;
	 */
	k_EPingMarkerInfo_OnlyShowMarker = 3,
	/**
	 * @generated from protobuf enum value: k_EPingMarkerInfo_OnlyPlaySound = 4;
	 */
	k_EPingMarkerInfo_OnlyPlaySound = 4,
}
/**
 * @generated from protobuf enum CameraOperation
 */
export enum CameraOperation {
	/**
	 * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
	 */
	UNSPECIFIED$ = 0,
	/**
	 * @generated from protobuf enum value: k_ECameraOp_Maintain = 2;
	 */
	k_ECameraOp_Maintain = 2,
	/**
	 * @generated from protobuf enum value: k_ECameraOp_Approach = 3;
	 */
	k_ECameraOp_Approach = 3,
	/**
	 * @generated from protobuf enum value: k_ECameraOp_Spring = 4;
	 */
	k_ECameraOp_Spring = 4,
	/**
	 * @generated from protobuf enum value: k_ECameraOp_Lerp = 5;
	 */
	k_ECameraOp_Lerp = 5,
	/**
	 * @generated from protobuf enum value: k_ECameraOp_Lag = 6;
	 */
	k_ECameraOp_Lag = 6,
}
/**
 * @generated from protobuf enum CameraParam
 */
export enum CameraParam {
	/**
	 * @generated from protobuf enum value: k_EParam_ClearAllOps = 0;
	 */
	k_EParam_ClearAllOps = 0,
	/**
	 * @generated from protobuf enum value: k_EParam_ClearAllOpsForContext = 1;
	 */
	k_EParam_ClearAllOpsForContext = 1,
	/**
	 * @generated from protobuf enum value: k_EParam_Distance = 2;
	 */
	k_EParam_Distance = 2,
	/**
	 * @generated from protobuf enum value: k_EParam_FOV = 3;
	 */
	k_EParam_FOV = 3,
	/**
	 * @generated from protobuf enum value: k_EParam_TargetPosition = 4;
	 */
	k_EParam_TargetPosition = 4,
	/**
	 * @generated from protobuf enum value: k_EParam_VertOffset = 5;
	 */
	k_EParam_VertOffset = 5,
	/**
	 * @generated from protobuf enum value: k_EParam_HorizOffset = 6;
	 */
	k_EParam_HorizOffset = 6,
}
/**
 * @generated from protobuf enum CameraParamMode
 */
export enum CameraParamMode {
	/**
	 * @generated from protobuf enum value: k_EParamMode_AllowInOneContext = 0;
	 */
	k_EParamMode_AllowInOneContext = 0,
	/**
	 * @generated from protobuf enum value: k_EParamMode_AllowInMultipleContexts = 1;
	 */
	k_EParamMode_AllowInMultipleContexts = 1,
}
/**
 * @generated from protobuf enum CameraAction
 */
export enum CameraAction {
	/**
	 * @generated from protobuf enum value: k_EAction_AddOp = 0;
	 */
	k_EAction_AddOp = 0,
	/**
	 * @generated from protobuf enum value: k_EAction_ClearAllOps = 1;
	 */
	k_EAction_ClearAllOps = 1,
	/**
	 * @generated from protobuf enum value: k_EAction_ClearOpsForContext = 2;
	 */
	k_EAction_ClearOpsForContext = 2,
}
/**
 * @generated from protobuf enum ECitadelChatMessage
 */
export enum ECitadelChatMessage {
	/**
	 * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
	 */
	UNSPECIFIED$ = 0,
	/**
	 * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_UNPAUSE_COUNTDOWN = 1;
	 */
	CITADEL_CHAT_MESSAGE_UNPAUSE_COUNTDOWN = 1,
	/**
	 * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_UNPAUSED = 2;
	 */
	CITADEL_CHAT_MESSAGE_UNPAUSED = 2,
	/**
	 * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_AUTO_UNPAUSED = 3;
	 */
	CITADEL_CHAT_MESSAGE_AUTO_UNPAUSED = 3,
	/**
	 * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_PAUSE_COUNTDOWN = 4;
	 */
	CITADEL_CHAT_MESSAGE_PAUSE_COUNTDOWN = 4,
	/**
	 * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_PAUSED = 5;
	 */
	CITADEL_CHAT_MESSAGE_PAUSED = 5,
	/**
	 * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_YOUPAUSED = 6;
	 */
	CITADEL_CHAT_MESSAGE_YOUPAUSED = 6,
	/**
	 * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_CANTPAUSE = 7;
	 */
	CITADEL_CHAT_MESSAGE_CANTPAUSE = 7,
	/**
	 * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_CANTUNPAUSETEAM = 8;
	 */
	CITADEL_CHAT_MESSAGE_CANTUNPAUSETEAM = 8,
	/**
	 * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_NOPAUSESLEFT = 9;
	 */
	CITADEL_CHAT_MESSAGE_NOPAUSESLEFT = 9,
	/**
	 * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_CANTPAUSEYET = 10;
	 */
	CITADEL_CHAT_MESSAGE_CANTPAUSEYET = 10,
	/**
	 * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_PREGAME_COUNTDOWN = 11;
	 */
	CITADEL_CHAT_MESSAGE_PREGAME_COUNTDOWN = 11,
	/**
	 * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_NOTEAMPAUSESLEFT = 12;
	 */
	CITADEL_CHAT_MESSAGE_NOTEAMPAUSESLEFT = 12,
	/**
	 * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_COMMS_RESTRICTED = 13;
	 */
	CITADEL_CHAT_MESSAGE_COMMS_RESTRICTED = 13,
}
/**
 * @generated from protobuf enum PostProcessingGameStates
 */
export enum PostProcessingGameStates {
	/**
	 * @generated from protobuf enum value: PostProcState_Killed = 0;
	 */
	PostProcState_Killed = 0,
	/**
	 * @generated from protobuf enum value: PostProcState_Black = 1;
	 */
	PostProcState_Black = 1,
	/**
	 * @generated from protobuf enum value: PostProcState_Blinded = 2;
	 */
	PostProcState_Blinded = 2,
	/**
	 * @generated from protobuf enum value: PostProcState_ShivPossessed = 3;
	 */
	PostProcState_ShivPossessed = 3,
}
// @generated message type with reflection information, may provide speed optimized methods
class CUserMessageEmpty$Type extends MessageType<CUserMessageEmpty> {
	constructor() {
		super("CUserMessageEmpty", [
			{
				no: 1,
				name: "empty",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CUserMessageEmpty>): CUserMessageEmpty {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CUserMessageEmpty>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CUserMessageEmpty,
	): CUserMessageEmpty {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 empty */ 1:
					message.empty = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CUserMessageEmpty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional uint32 empty = 1; */
		if (message.empty !== undefined) writer.tag(1, WireType.Varint).uint32(message.empty);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CUserMessageEmpty
 */
export const CUserMessageEmpty = new CUserMessageEmpty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMessage_Damage$Type extends MessageType<CCitadelUserMessage_Damage> {
	constructor() {
		super("CCitadelUserMessage_Damage", [
			{
				no: 1,
				name: "damage",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "pre_damage",
				kind: "scalar",
				localName: "pre_damage",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "type",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 4,
				name: "citadel_type",
				kind: "scalar",
				localName: "citadel_type",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{ no: 5, name: "origin", kind: "message", T: () => CMsgVector },
			{
				no: 6,
				name: "entindex_victim",
				kind: "scalar",
				localName: "entindex_victim",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 7,
				name: "entindex_inflictor",
				kind: "scalar",
				localName: "entindex_inflictor",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 8,
				name: "entindex_attacker",
				kind: "scalar",
				localName: "entindex_attacker",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 9,
				name: "entindex_ability",
				kind: "scalar",
				localName: "entindex_ability",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 10,
				name: "damage_absorbed",
				kind: "scalar",
				localName: "damage_absorbed",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 11,
				name: "victim_health_max",
				kind: "scalar",
				localName: "victim_health_max",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 12,
				name: "victim_health_new",
				kind: "scalar",
				localName: "victim_health_new",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 13,
				name: "flags",
				kind: "scalar",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 14,
				name: "ability_id",
				kind: "scalar",
				localName: "ability_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 15,
				name: "attacker_class",
				kind: "scalar",
				localName: "attacker_class",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 16,
				name: "victim_class",
				kind: "scalar",
				localName: "victim_class",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 17,
				name: "victim_shield_max",
				kind: "scalar",
				localName: "victim_shield_max",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 18,
				name: "victim_shield_new",
				kind: "scalar",
				localName: "victim_shield_new",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 19,
				name: "hits",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 20,
				name: "health_lost",
				kind: "scalar",
				localName: "health_lost",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMessage_Damage>): CCitadelUserMessage_Damage {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMessage_Damage>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMessage_Damage,
	): CCitadelUserMessage_Damage {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 damage */ 1:
					message.damage = reader.int32();
					break;
				case /* optional int32 pre_damage */ 2:
					message.pre_damage = reader.int32();
					break;
				case /* optional int32 type */ 3:
					message.type = reader.int32();
					break;
				case /* optional int32 citadel_type */ 4:
					message.citadel_type = reader.int32();
					break;
				case /* optional CMsgVector origin */ 5:
					message.origin = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.origin);
					break;
				case /* optional int32 entindex_victim */ 6:
					message.entindex_victim = reader.int32();
					break;
				case /* optional int32 entindex_inflictor */ 7:
					message.entindex_inflictor = reader.int32();
					break;
				case /* optional int32 entindex_attacker */ 8:
					message.entindex_attacker = reader.int32();
					break;
				case /* optional int32 entindex_ability */ 9:
					message.entindex_ability = reader.int32();
					break;
				case /* optional int32 damage_absorbed */ 10:
					message.damage_absorbed = reader.int32();
					break;
				case /* optional int32 victim_health_max */ 11:
					message.victim_health_max = reader.int32();
					break;
				case /* optional int32 victim_health_new */ 12:
					message.victim_health_new = reader.int32();
					break;
				case /* optional uint64 flags */ 13:
					message.flags = reader.uint64().toBigInt();
					break;
				case /* optional uint32 ability_id */ 14:
					message.ability_id = reader.uint32();
					break;
				case /* optional uint32 attacker_class */ 15:
					message.attacker_class = reader.uint32();
					break;
				case /* optional uint32 victim_class */ 16:
					message.victim_class = reader.uint32();
					break;
				case /* optional int32 victim_shield_max */ 17:
					message.victim_shield_max = reader.int32();
					break;
				case /* optional int32 victim_shield_new */ 18:
					message.victim_shield_new = reader.int32();
					break;
				case /* optional int32 hits */ 19:
					message.hits = reader.int32();
					break;
				case /* optional int32 health_lost */ 20:
					message.health_lost = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMessage_Damage,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 damage = 1; */
		if (message.damage !== undefined) writer.tag(1, WireType.Varint).int32(message.damage);
		/* optional int32 pre_damage = 2; */
		if (message.pre_damage !== undefined) writer.tag(2, WireType.Varint).int32(message.pre_damage);
		/* optional int32 type = 3; */
		if (message.type !== undefined) writer.tag(3, WireType.Varint).int32(message.type);
		/* optional int32 citadel_type = 4; */
		if (message.citadel_type !== undefined) writer.tag(4, WireType.Varint).int32(message.citadel_type);
		/* optional CMsgVector origin = 5; */
		if (message.origin)
			CMsgVector.internalBinaryWrite(message.origin, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
		/* optional int32 entindex_victim = 6; */
		if (message.entindex_victim !== undefined) writer.tag(6, WireType.Varint).int32(message.entindex_victim);
		/* optional int32 entindex_inflictor = 7; */
		if (message.entindex_inflictor !== undefined) writer.tag(7, WireType.Varint).int32(message.entindex_inflictor);
		/* optional int32 entindex_attacker = 8; */
		if (message.entindex_attacker !== undefined) writer.tag(8, WireType.Varint).int32(message.entindex_attacker);
		/* optional int32 entindex_ability = 9; */
		if (message.entindex_ability !== undefined) writer.tag(9, WireType.Varint).int32(message.entindex_ability);
		/* optional int32 damage_absorbed = 10; */
		if (message.damage_absorbed !== undefined) writer.tag(10, WireType.Varint).int32(message.damage_absorbed);
		/* optional int32 victim_health_max = 11; */
		if (message.victim_health_max !== undefined) writer.tag(11, WireType.Varint).int32(message.victim_health_max);
		/* optional int32 victim_health_new = 12; */
		if (message.victim_health_new !== undefined) writer.tag(12, WireType.Varint).int32(message.victim_health_new);
		/* optional uint64 flags = 13; */
		if (message.flags !== undefined) writer.tag(13, WireType.Varint).uint64(message.flags);
		/* optional uint32 ability_id = 14; */
		if (message.ability_id !== undefined) writer.tag(14, WireType.Varint).uint32(message.ability_id);
		/* optional uint32 attacker_class = 15; */
		if (message.attacker_class !== undefined) writer.tag(15, WireType.Varint).uint32(message.attacker_class);
		/* optional uint32 victim_class = 16; */
		if (message.victim_class !== undefined) writer.tag(16, WireType.Varint).uint32(message.victim_class);
		/* optional int32 victim_shield_max = 17; */
		if (message.victim_shield_max !== undefined) writer.tag(17, WireType.Varint).int32(message.victim_shield_max);
		/* optional int32 victim_shield_new = 18; */
		if (message.victim_shield_new !== undefined) writer.tag(18, WireType.Varint).int32(message.victim_shield_new);
		/* optional int32 hits = 19; */
		if (message.hits !== undefined) writer.tag(19, WireType.Varint).int32(message.hits);
		/* optional int32 health_lost = 20; */
		if (message.health_lost !== undefined) writer.tag(20, WireType.Varint).int32(message.health_lost);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMessage_Damage
 */
export const CCitadelUserMessage_Damage = new CCitadelUserMessage_Damage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingCommonData$Type extends MessageType<PingCommonData> {
	constructor() {
		super("PingCommonData", [
			{
				no: 1,
				name: "ping_message_id",
				kind: "scalar",
				localName: "ping_message_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "ping_location",
				kind: "message",
				localName: "ping_location",
				T: () => CMsgVector,
			},
			{
				no: 3,
				name: "entity_index",
				kind: "scalar",
				localName: "entity_index",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 4,
				name: "sender_player_slot",
				kind: "scalar",
				localName: "sender_player_slot",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 5,
				name: "speech_concept",
				kind: "scalar",
				localName: "speech_concept",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 6,
				name: "response_chosen",
				kind: "scalar",
				localName: "response_chosen",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 7,
				name: "cooldown_time",
				kind: "scalar",
				localName: "cooldown_time",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
		]);
	}
	create(value?: PartialMessage<PingCommonData>): PingCommonData {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<PingCommonData>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: PingCommonData,
	): PingCommonData {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 ping_message_id */ 1:
					message.ping_message_id = reader.uint32();
					break;
				case /* optional CMsgVector ping_location */ 2:
					message.ping_location = CMsgVector.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.ping_location,
					);
					break;
				case /* optional uint32 entity_index */ 3:
					message.entity_index = reader.uint32();
					break;
				case /* optional int32 sender_player_slot */ 4:
					message.sender_player_slot = reader.int32();
					break;
				case /* optional int32 speech_concept */ 5:
					message.speech_concept = reader.int32();
					break;
				case /* optional string response_chosen */ 6:
					message.response_chosen = reader.string();
					break;
				case /* optional float cooldown_time */ 7:
					message.cooldown_time = reader.float();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: PingCommonData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional uint32 ping_message_id = 1; */
		if (message.ping_message_id !== undefined) writer.tag(1, WireType.Varint).uint32(message.ping_message_id);
		/* optional CMsgVector ping_location = 2; */
		if (message.ping_location)
			CMsgVector.internalBinaryWrite(
				message.ping_location,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional uint32 entity_index = 3; */
		if (message.entity_index !== undefined) writer.tag(3, WireType.Varint).uint32(message.entity_index);
		/* optional int32 sender_player_slot = 4; */
		if (message.sender_player_slot !== undefined) writer.tag(4, WireType.Varint).int32(message.sender_player_slot);
		/* optional int32 speech_concept = 5; */
		if (message.speech_concept !== undefined) writer.tag(5, WireType.Varint).int32(message.speech_concept);
		/* optional string response_chosen = 6; */
		if (message.response_chosen !== undefined) writer.tag(6, WireType.LengthDelimited).string(message.response_chosen);
		/* optional float cooldown_time = 7; */
		if (message.cooldown_time !== undefined) writer.tag(7, WireType.Bit32).float(message.cooldown_time);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message PingCommonData
 */
export const PingCommonData = new PingCommonData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_MapPing$Type extends MessageType<CCitadelUserMsg_MapPing> {
	constructor() {
		super("CCitadelUserMsg_MapPing", [
			{
				no: 1,
				name: "ping_data",
				kind: "message",
				localName: "ping_data",
				T: () => PingCommonData,
			},
			{
				no: 2,
				name: "event_type",
				kind: "scalar",
				localName: "event_type",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "ping_marker_and_sound_info",
				kind: "enum",
				localName: "ping_marker_and_sound_info",
				opt: true,
				T: () => ["ChatMsgPingMarkerInfo", ChatMsgPingMarkerInfo],
			},
			{
				no: 4,
				name: "pinged_enemy_entity",
				kind: "scalar",
				localName: "pinged_enemy_entity",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 5,
				name: "pinged_entity_class",
				kind: "scalar",
				localName: "pinged_entity_class",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 6,
				name: "is_minimap_ping",
				kind: "scalar",
				localName: "is_minimap_ping",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 7,
				name: "pinged_hero_name",
				kind: "scalar",
				localName: "pinged_hero_name",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 8,
				name: "is_blind_ping",
				kind: "scalar",
				localName: "is_blind_ping",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_MapPing>): CCitadelUserMsg_MapPing {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_MapPing>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_MapPing,
	): CCitadelUserMsg_MapPing {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* PingCommonData ping_data */ 1:
					message.ping_data = PingCommonData.internalBinaryRead(reader, reader.uint32(), options, message.ping_data);
					break;
				case /* optional uint32 event_type */ 2:
					message.event_type = reader.uint32();
					break;
				case /* optional ChatMsgPingMarkerInfo ping_marker_and_sound_info */ 3:
					message.ping_marker_and_sound_info = reader.int32();
					break;
				case /* optional bool pinged_enemy_entity */ 4:
					message.pinged_enemy_entity = reader.bool();
					break;
				case /* optional uint32 pinged_entity_class */ 5:
					message.pinged_entity_class = reader.uint32();
					break;
				case /* optional bool is_minimap_ping */ 6:
					message.is_minimap_ping = reader.bool();
					break;
				case /* optional string pinged_hero_name */ 7:
					message.pinged_hero_name = reader.string();
					break;
				case /* optional bool is_blind_ping */ 8:
					message.is_blind_ping = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_MapPing,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* PingCommonData ping_data = 1; */
		if (message.ping_data)
			PingCommonData.internalBinaryWrite(
				message.ping_data,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional uint32 event_type = 2; */
		if (message.event_type !== undefined) writer.tag(2, WireType.Varint).uint32(message.event_type);
		/* optional ChatMsgPingMarkerInfo ping_marker_and_sound_info = 3; */
		if (message.ping_marker_and_sound_info !== undefined)
			writer.tag(3, WireType.Varint).int32(message.ping_marker_and_sound_info);
		/* optional bool pinged_enemy_entity = 4; */
		if (message.pinged_enemy_entity !== undefined) writer.tag(4, WireType.Varint).bool(message.pinged_enemy_entity);
		/* optional uint32 pinged_entity_class = 5; */
		if (message.pinged_entity_class !== undefined) writer.tag(5, WireType.Varint).uint32(message.pinged_entity_class);
		/* optional bool is_minimap_ping = 6; */
		if (message.is_minimap_ping !== undefined) writer.tag(6, WireType.Varint).bool(message.is_minimap_ping);
		/* optional string pinged_hero_name = 7; */
		if (message.pinged_hero_name !== undefined)
			writer.tag(7, WireType.LengthDelimited).string(message.pinged_hero_name);
		/* optional bool is_blind_ping = 8; */
		if (message.is_blind_ping !== undefined) writer.tag(8, WireType.Varint).bool(message.is_blind_ping);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_MapPing
 */
export const CCitadelUserMsg_MapPing = new CCitadelUserMsg_MapPing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_PingWheel$Type extends MessageType<CCitadelUserMsg_PingWheel> {
	constructor() {
		super("CCitadelUserMsg_PingWheel", [
			{
				no: 1,
				name: "ping_data",
				kind: "message",
				localName: "ping_data",
				T: () => PingCommonData,
			},
			{
				no: 2,
				name: "ping_wheel_option_id",
				kind: "scalar",
				localName: "ping_wheel_option_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_PingWheel>): CCitadelUserMsg_PingWheel {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_PingWheel>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_PingWheel,
	): CCitadelUserMsg_PingWheel {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* PingCommonData ping_data */ 1:
					message.ping_data = PingCommonData.internalBinaryRead(reader, reader.uint32(), options, message.ping_data);
					break;
				case /* optional uint32 ping_wheel_option_id */ 2:
					message.ping_wheel_option_id = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_PingWheel,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* PingCommonData ping_data = 1; */
		if (message.ping_data)
			PingCommonData.internalBinaryWrite(
				message.ping_data,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional uint32 ping_wheel_option_id = 2; */
		if (message.ping_wheel_option_id !== undefined) writer.tag(2, WireType.Varint).uint32(message.ping_wheel_option_id);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_PingWheel
 */
export const CCitadelUserMsg_PingWheel = new CCitadelUserMsg_PingWheel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_AbilityPing$Type extends MessageType<CCitadelUserMsg_AbilityPing> {
	constructor() {
		super("CCitadelUserMsg_AbilityPing", [
			{
				no: 1,
				name: "ping_data",
				kind: "message",
				localName: "ping_data",
				T: () => PingCommonData,
			},
			{
				no: 2,
				name: "ability_id",
				kind: "scalar",
				localName: "ability_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "ability_cooldown",
				kind: "scalar",
				localName: "ability_cooldown",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 4,
				name: "ping_marker_and_sound_info",
				kind: "enum",
				localName: "ping_marker_and_sound_info",
				opt: true,
				T: () => ["ChatMsgPingMarkerInfo", ChatMsgPingMarkerInfo],
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_AbilityPing>): CCitadelUserMsg_AbilityPing {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_AbilityPing>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_AbilityPing,
	): CCitadelUserMsg_AbilityPing {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional PingCommonData ping_data */ 1:
					message.ping_data = PingCommonData.internalBinaryRead(reader, reader.uint32(), options, message.ping_data);
					break;
				case /* optional uint32 ability_id */ 2:
					message.ability_id = reader.uint32();
					break;
				case /* optional float ability_cooldown */ 3:
					message.ability_cooldown = reader.float();
					break;
				case /* optional ChatMsgPingMarkerInfo ping_marker_and_sound_info */ 4:
					message.ping_marker_and_sound_info = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_AbilityPing,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional PingCommonData ping_data = 1; */
		if (message.ping_data)
			PingCommonData.internalBinaryWrite(
				message.ping_data,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional uint32 ability_id = 2; */
		if (message.ability_id !== undefined) writer.tag(2, WireType.Varint).uint32(message.ability_id);
		/* optional float ability_cooldown = 3; */
		if (message.ability_cooldown !== undefined) writer.tag(3, WireType.Bit32).float(message.ability_cooldown);
		/* optional ChatMsgPingMarkerInfo ping_marker_and_sound_info = 4; */
		if (message.ping_marker_and_sound_info !== undefined)
			writer.tag(4, WireType.Varint).int32(message.ping_marker_and_sound_info);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_AbilityPing
 */
export const CCitadelUserMsg_AbilityPing = new CCitadelUserMsg_AbilityPing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_QuickResponse$Type extends MessageType<CCitadelUserMsg_QuickResponse> {
	constructor() {
		super("CCitadelUserMsg_QuickResponse", [
			{
				no: 1,
				name: "ping_data",
				kind: "message",
				localName: "ping_data",
				T: () => PingCommonData,
			},
			{
				no: 2,
				name: "responding_to_ping_message_id",
				kind: "scalar",
				localName: "responding_to_ping_message_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "responding_to_player_slot",
				kind: "scalar",
				localName: "responding_to_player_slot",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 4,
				name: "lane_color",
				kind: "enum",
				localName: "lane_color",
				opt: true,
				T: () => ["CMsgLaneColor", CMsgLaneColor],
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_QuickResponse>): CCitadelUserMsg_QuickResponse {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_QuickResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_QuickResponse,
	): CCitadelUserMsg_QuickResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* PingCommonData ping_data */ 1:
					message.ping_data = PingCommonData.internalBinaryRead(reader, reader.uint32(), options, message.ping_data);
					break;
				case /* optional uint32 responding_to_ping_message_id */ 2:
					message.responding_to_ping_message_id = reader.uint32();
					break;
				case /* optional int32 responding_to_player_slot */ 3:
					message.responding_to_player_slot = reader.int32();
					break;
				case /* optional CMsgLaneColor lane_color */ 4:
					message.lane_color = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_QuickResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* PingCommonData ping_data = 1; */
		if (message.ping_data)
			PingCommonData.internalBinaryWrite(
				message.ping_data,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional uint32 responding_to_ping_message_id = 2; */
		if (message.responding_to_ping_message_id !== undefined)
			writer.tag(2, WireType.Varint).uint32(message.responding_to_ping_message_id);
		/* optional int32 responding_to_player_slot = 3; */
		if (message.responding_to_player_slot !== undefined)
			writer.tag(3, WireType.Varint).int32(message.responding_to_player_slot);
		/* optional CMsgLaneColor lane_color = 4; */
		if (message.lane_color !== undefined) writer.tag(4, WireType.Varint).int32(message.lane_color);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_QuickResponse
 */
export const CCitadelUserMsg_QuickResponse = new CCitadelUserMsg_QuickResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_MapLine$Type extends MessageType<CCitadelUserMsg_MapLine> {
	constructor() {
		super("CCitadelUserMsg_MapLine", [
			{
				no: 1,
				name: "sender_player_slot",
				kind: "scalar",
				localName: "sender_player_slot",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{ no: 2, name: "mapline", kind: "message", T: () => CMsgMapLine },
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_MapLine>): CCitadelUserMsg_MapLine {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_MapLine>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_MapLine,
	): CCitadelUserMsg_MapLine {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 sender_player_slot */ 1:
					message.sender_player_slot = reader.int32();
					break;
				case /* optional CMsgMapLine mapline */ 2:
					message.mapline = CMsgMapLine.internalBinaryRead(reader, reader.uint32(), options, message.mapline);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_MapLine,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 sender_player_slot = 1; */
		if (message.sender_player_slot !== undefined) writer.tag(1, WireType.Varint).int32(message.sender_player_slot);
		/* optional CMsgMapLine mapline = 2; */
		if (message.mapline)
			CMsgMapLine.internalBinaryWrite(message.mapline, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_MapLine
 */
export const CCitadelUserMsg_MapLine = new CCitadelUserMsg_MapLine$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_TeamRewards$Type extends MessageType<CCitadelUserMsg_TeamRewards> {
	constructor() {
		super("CCitadelUserMsg_TeamRewards", [
			{
				no: 1,
				name: "xp",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "gold",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "winner",
				kind: "scalar",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_TeamRewards>): CCitadelUserMsg_TeamRewards {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_TeamRewards>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_TeamRewards,
	): CCitadelUserMsg_TeamRewards {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 xp */ 1:
					message.xp = reader.uint32();
					break;
				case /* optional uint32 gold */ 2:
					message.gold = reader.uint32();
					break;
				case /* optional bool winner */ 3:
					message.winner = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_TeamRewards,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 xp = 1; */
		if (message.xp !== undefined) writer.tag(1, WireType.Varint).uint32(message.xp);
		/* optional uint32 gold = 2; */
		if (message.gold !== undefined) writer.tag(2, WireType.Varint).uint32(message.gold);
		/* optional bool winner = 3; */
		if (message.winner !== undefined) writer.tag(3, WireType.Varint).bool(message.winner);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_TeamRewards
 */
export const CCitadelUserMsg_TeamRewards = new CCitadelUserMsg_TeamRewards$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_TriggerDamageFlash$Type extends MessageType<CCitadelUserMsg_TriggerDamageFlash> {
	constructor() {
		super("CCitadelUserMsg_TriggerDamageFlash", [
			{
				no: 1,
				name: "entindex_flash_victim",
				kind: "scalar",
				localName: "entindex_flash_victim",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "entindex_flash_attacker",
				kind: "scalar",
				localName: "entindex_flash_attacker",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "entindex_flash_hitgroup",
				kind: "scalar",
				localName: "entindex_flash_hitgroup",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 4,
				name: "flash_value",
				kind: "scalar",
				localName: "flash_value",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 5,
				name: "flash_type",
				kind: "scalar",
				localName: "flash_type",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 6,
				name: "flash_flags",
				kind: "scalar",
				localName: "flash_flags",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 7,
				name: "flash_position",
				kind: "message",
				localName: "flash_position",
				T: () => CMsgVector,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_TriggerDamageFlash>): CCitadelUserMsg_TriggerDamageFlash {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_TriggerDamageFlash>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_TriggerDamageFlash,
	): CCitadelUserMsg_TriggerDamageFlash {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 entindex_flash_victim */ 1:
					message.entindex_flash_victim = reader.int32();
					break;
				case /* optional int32 entindex_flash_attacker */ 2:
					message.entindex_flash_attacker = reader.int32();
					break;
				case /* optional int32 entindex_flash_hitgroup */ 3:
					message.entindex_flash_hitgroup = reader.int32();
					break;
				case /* optional uint32 flash_value */ 4:
					message.flash_value = reader.uint32();
					break;
				case /* optional uint32 flash_type */ 5:
					message.flash_type = reader.uint32();
					break;
				case /* optional uint32 flash_flags */ 6:
					message.flash_flags = reader.uint32();
					break;
				case /* optional CMsgVector flash_position */ 7:
					message.flash_position = CMsgVector.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.flash_position,
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_TriggerDamageFlash,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 entindex_flash_victim = 1; */
		if (message.entindex_flash_victim !== undefined)
			writer.tag(1, WireType.Varint).int32(message.entindex_flash_victim);
		/* optional int32 entindex_flash_attacker = 2; */
		if (message.entindex_flash_attacker !== undefined)
			writer.tag(2, WireType.Varint).int32(message.entindex_flash_attacker);
		/* optional int32 entindex_flash_hitgroup = 3; */
		if (message.entindex_flash_hitgroup !== undefined)
			writer.tag(3, WireType.Varint).int32(message.entindex_flash_hitgroup);
		/* optional uint32 flash_value = 4; */
		if (message.flash_value !== undefined) writer.tag(4, WireType.Varint).uint32(message.flash_value);
		/* optional uint32 flash_type = 5; */
		if (message.flash_type !== undefined) writer.tag(5, WireType.Varint).uint32(message.flash_type);
		/* optional uint32 flash_flags = 6; */
		if (message.flash_flags !== undefined) writer.tag(6, WireType.Varint).uint32(message.flash_flags);
		/* optional CMsgVector flash_position = 7; */
		if (message.flash_position)
			CMsgVector.internalBinaryWrite(
				message.flash_position,
				writer.tag(7, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_TriggerDamageFlash
 */
export const CCitadelUserMsg_TriggerDamageFlash = new CCitadelUserMsg_TriggerDamageFlash$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_AbilitiesChanged$Type extends MessageType<CCitadelUserMsg_AbilitiesChanged> {
	constructor() {
		super("CCitadelUserMsg_AbilitiesChanged", [
			{
				no: 1,
				name: "entindex_purchaser",
				kind: "scalar",
				localName: "entindex_purchaser",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "entindex_ability",
				kind: "scalar",
				localName: "entindex_ability",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "ability_id",
				kind: "scalar",
				localName: "ability_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 4,
				name: "change",
				kind: "enum",
				opt: true,
				T: () => ["CCitadelUserMsg_AbilitiesChanged.Change", CCitadelUserMsg_AbilitiesChanged_Change],
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_AbilitiesChanged>): CCitadelUserMsg_AbilitiesChanged {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_AbilitiesChanged>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_AbilitiesChanged,
	): CCitadelUserMsg_AbilitiesChanged {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 entindex_purchaser */ 1:
					message.entindex_purchaser = reader.int32();
					break;
				case /* optional int32 entindex_ability */ 2:
					message.entindex_ability = reader.int32();
					break;
				case /* optional uint32 ability_id */ 3:
					message.ability_id = reader.uint32();
					break;
				case /* optional CCitadelUserMsg_AbilitiesChanged.Change change */ 4:
					message.change = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_AbilitiesChanged,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 entindex_purchaser = 1; */
		if (message.entindex_purchaser !== undefined) writer.tag(1, WireType.Varint).int32(message.entindex_purchaser);
		/* optional int32 entindex_ability = 2; */
		if (message.entindex_ability !== undefined) writer.tag(2, WireType.Varint).int32(message.entindex_ability);
		/* optional uint32 ability_id = 3; */
		if (message.ability_id !== undefined) writer.tag(3, WireType.Varint).uint32(message.ability_id);
		/* optional CCitadelUserMsg_AbilitiesChanged.Change change = 4; */
		if (message.change !== undefined) writer.tag(4, WireType.Varint).int32(message.change);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_AbilitiesChanged
 */
export const CCitadelUserMsg_AbilitiesChanged = new CCitadelUserMsg_AbilitiesChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_AbilityInterrupted$Type extends MessageType<CCitadelUserMsg_AbilityInterrupted> {
	constructor() {
		super("CCitadelUserMsg_AbilityInterrupted", [
			{
				no: 1,
				name: "entindex_victim",
				kind: "scalar",
				localName: "entindex_victim",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "entindex_interrupter",
				kind: "scalar",
				localName: "entindex_interrupter",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "ability_id_interrupted",
				kind: "scalar",
				localName: "ability_id_interrupted",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 4,
				name: "ability_id_interrupter",
				kind: "scalar",
				localName: "ability_id_interrupter",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 5,
				name: "hero_id_interrupter",
				kind: "scalar",
				localName: "hero_id_interrupter",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_AbilityInterrupted>): CCitadelUserMsg_AbilityInterrupted {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_AbilityInterrupted>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_AbilityInterrupted,
	): CCitadelUserMsg_AbilityInterrupted {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 entindex_victim */ 1:
					message.entindex_victim = reader.int32();
					break;
				case /* optional int32 entindex_interrupter */ 2:
					message.entindex_interrupter = reader.int32();
					break;
				case /* optional uint32 ability_id_interrupted */ 3:
					message.ability_id_interrupted = reader.uint32();
					break;
				case /* optional uint32 ability_id_interrupter */ 4:
					message.ability_id_interrupter = reader.uint32();
					break;
				case /* optional uint32 hero_id_interrupter */ 5:
					message.hero_id_interrupter = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_AbilityInterrupted,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 entindex_victim = 1; */
		if (message.entindex_victim !== undefined) writer.tag(1, WireType.Varint).int32(message.entindex_victim);
		/* optional int32 entindex_interrupter = 2; */
		if (message.entindex_interrupter !== undefined) writer.tag(2, WireType.Varint).int32(message.entindex_interrupter);
		/* optional uint32 ability_id_interrupted = 3; */
		if (message.ability_id_interrupted !== undefined)
			writer.tag(3, WireType.Varint).uint32(message.ability_id_interrupted);
		/* optional uint32 ability_id_interrupter = 4; */
		if (message.ability_id_interrupter !== undefined)
			writer.tag(4, WireType.Varint).uint32(message.ability_id_interrupter);
		/* optional uint32 hero_id_interrupter = 5; */
		if (message.hero_id_interrupter !== undefined) writer.tag(5, WireType.Varint).uint32(message.hero_id_interrupter);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_AbilityInterrupted
 */
export const CCitadelUserMsg_AbilityInterrupted = new CCitadelUserMsg_AbilityInterrupted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_AbilityLateFailure$Type extends MessageType<CCitadelUserMsg_AbilityLateFailure> {
	constructor() {
		super("CCitadelUserMsg_AbilityLateFailure", [
			{
				no: 1,
				name: "entindex_caster",
				kind: "scalar",
				localName: "entindex_caster",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "entindex_ability",
				kind: "scalar",
				localName: "entindex_ability",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "failure_type",
				kind: "scalar",
				localName: "failure_type",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_AbilityLateFailure>): CCitadelUserMsg_AbilityLateFailure {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_AbilityLateFailure>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_AbilityLateFailure,
	): CCitadelUserMsg_AbilityLateFailure {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 entindex_caster */ 1:
					message.entindex_caster = reader.int32();
					break;
				case /* optional int32 entindex_ability */ 2:
					message.entindex_ability = reader.int32();
					break;
				case /* optional uint32 failure_type */ 3:
					message.failure_type = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_AbilityLateFailure,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 entindex_caster = 1; */
		if (message.entindex_caster !== undefined) writer.tag(1, WireType.Varint).int32(message.entindex_caster);
		/* optional int32 entindex_ability = 2; */
		if (message.entindex_ability !== undefined) writer.tag(2, WireType.Varint).int32(message.entindex_ability);
		/* optional uint32 failure_type = 3; */
		if (message.failure_type !== undefined) writer.tag(3, WireType.Varint).uint32(message.failure_type);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_AbilityLateFailure
 */
export const CCitadelUserMsg_AbilityLateFailure = new CCitadelUserMsg_AbilityLateFailure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_RecentDamageSummary$Type extends MessageType<CCitadelUserMsg_RecentDamageSummary> {
	constructor() {
		super("CCitadelUserMsg_RecentDamageSummary", [
			{
				no: 1,
				name: "player_slot",
				kind: "scalar",
				localName: "player_slot",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "damage_records",
				kind: "message",
				localName: "damage_records",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CCitadelUserMsg_RecentDamageSummary_DamageRecord,
			},
			{
				no: 3,
				name: "start_time",
				kind: "scalar",
				localName: "start_time",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 4,
				name: "end_time",
				kind: "scalar",
				localName: "end_time",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 5,
				name: "total_damage",
				kind: "scalar",
				localName: "total_damage",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 6,
				name: "lost_gold",
				kind: "scalar",
				localName: "lost_gold",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 7,
				name: "modifier_records",
				kind: "message",
				localName: "modifier_records",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CCitadelUserMsg_RecentDamageSummary_ModifierRecord,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_RecentDamageSummary>): CCitadelUserMsg_RecentDamageSummary {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.damage_records = [];
		message.modifier_records = [];
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_RecentDamageSummary>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_RecentDamageSummary,
	): CCitadelUserMsg_RecentDamageSummary {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 player_slot */ 1:
					message.player_slot = reader.int32();
					break;
				case /* repeated CCitadelUserMsg_RecentDamageSummary.DamageRecord damage_records */ 2:
					message.damage_records.push(
						CCitadelUserMsg_RecentDamageSummary_DamageRecord.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				case /* optional float start_time */ 3:
					message.start_time = reader.float();
					break;
				case /* optional float end_time */ 4:
					message.end_time = reader.float();
					break;
				case /* optional int32 total_damage */ 5:
					message.total_damage = reader.int32();
					break;
				case /* optional int32 lost_gold */ 6:
					message.lost_gold = reader.int32();
					break;
				case /* repeated CCitadelUserMsg_RecentDamageSummary.ModifierRecord modifier_records */ 7:
					message.modifier_records.push(
						CCitadelUserMsg_RecentDamageSummary_ModifierRecord.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_RecentDamageSummary,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 player_slot = 1; */
		if (message.player_slot !== undefined) writer.tag(1, WireType.Varint).int32(message.player_slot);
		/* repeated CCitadelUserMsg_RecentDamageSummary.DamageRecord damage_records = 2; */
		for (let i = 0; i < message.damage_records.length; i++)
			CCitadelUserMsg_RecentDamageSummary_DamageRecord.internalBinaryWrite(
				message.damage_records[i],
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional float start_time = 3; */
		if (message.start_time !== undefined) writer.tag(3, WireType.Bit32).float(message.start_time);
		/* optional float end_time = 4; */
		if (message.end_time !== undefined) writer.tag(4, WireType.Bit32).float(message.end_time);
		/* optional int32 total_damage = 5; */
		if (message.total_damage !== undefined) writer.tag(5, WireType.Varint).int32(message.total_damage);
		/* optional int32 lost_gold = 6; */
		if (message.lost_gold !== undefined) writer.tag(6, WireType.Varint).int32(message.lost_gold);
		/* repeated CCitadelUserMsg_RecentDamageSummary.ModifierRecord modifier_records = 7; */
		for (let i = 0; i < message.modifier_records.length; i++)
			CCitadelUserMsg_RecentDamageSummary_ModifierRecord.internalBinaryWrite(
				message.modifier_records[i],
				writer.tag(7, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_RecentDamageSummary
 */
export const CCitadelUserMsg_RecentDamageSummary = new CCitadelUserMsg_RecentDamageSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_RecentDamageSummary_DamageRecord$Type extends MessageType<CCitadelUserMsg_RecentDamageSummary_DamageRecord> {
	constructor() {
		super("CCitadelUserMsg_RecentDamageSummary.DamageRecord", [
			{
				no: 1,
				name: "damage",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "hits",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "damage_type",
				kind: "scalar",
				localName: "damage_type",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 4,
				name: "hero_id",
				kind: "scalar",
				localName: "hero_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 5,
				name: "ability_id",
				kind: "scalar",
				localName: "ability_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 6,
				name: "attacker_class",
				kind: "scalar",
				localName: "attacker_class",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 7,
				name: "damage_absorbed",
				kind: "scalar",
				localName: "damage_absorbed",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 8,
				name: "is_killing_blow",
				kind: "scalar",
				localName: "is_killing_blow",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 9,
				name: "victim_hero_id",
				kind: "scalar",
				localName: "victim_hero_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CCitadelUserMsg_RecentDamageSummary_DamageRecord>,
	): CCitadelUserMsg_RecentDamageSummary_DamageRecord {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined)
			reflectionMergePartial<CCitadelUserMsg_RecentDamageSummary_DamageRecord>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_RecentDamageSummary_DamageRecord,
	): CCitadelUserMsg_RecentDamageSummary_DamageRecord {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 damage */ 1:
					message.damage = reader.int32();
					break;
				case /* optional int32 hits */ 2:
					message.hits = reader.int32();
					break;
				case /* optional uint32 damage_type */ 3:
					message.damage_type = reader.uint32();
					break;
				case /* optional uint32 hero_id */ 4:
					message.hero_id = reader.uint32();
					break;
				case /* optional uint32 ability_id */ 5:
					message.ability_id = reader.uint32();
					break;
				case /* optional uint32 attacker_class */ 6:
					message.attacker_class = reader.uint32();
					break;
				case /* optional int32 damage_absorbed */ 7:
					message.damage_absorbed = reader.int32();
					break;
				case /* optional bool is_killing_blow */ 8:
					message.is_killing_blow = reader.bool();
					break;
				case /* optional uint32 victim_hero_id */ 9:
					message.victim_hero_id = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_RecentDamageSummary_DamageRecord,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 damage = 1; */
		if (message.damage !== undefined) writer.tag(1, WireType.Varint).int32(message.damage);
		/* optional int32 hits = 2; */
		if (message.hits !== undefined) writer.tag(2, WireType.Varint).int32(message.hits);
		/* optional uint32 damage_type = 3; */
		if (message.damage_type !== undefined) writer.tag(3, WireType.Varint).uint32(message.damage_type);
		/* optional uint32 hero_id = 4; */
		if (message.hero_id !== undefined) writer.tag(4, WireType.Varint).uint32(message.hero_id);
		/* optional uint32 ability_id = 5; */
		if (message.ability_id !== undefined) writer.tag(5, WireType.Varint).uint32(message.ability_id);
		/* optional uint32 attacker_class = 6; */
		if (message.attacker_class !== undefined) writer.tag(6, WireType.Varint).uint32(message.attacker_class);
		/* optional int32 damage_absorbed = 7; */
		if (message.damage_absorbed !== undefined) writer.tag(7, WireType.Varint).int32(message.damage_absorbed);
		/* optional bool is_killing_blow = 8; */
		if (message.is_killing_blow !== undefined) writer.tag(8, WireType.Varint).bool(message.is_killing_blow);
		/* optional uint32 victim_hero_id = 9; */
		if (message.victim_hero_id !== undefined) writer.tag(9, WireType.Varint).uint32(message.victim_hero_id);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_RecentDamageSummary.DamageRecord
 */
export const CCitadelUserMsg_RecentDamageSummary_DamageRecord =
	new CCitadelUserMsg_RecentDamageSummary_DamageRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_RecentDamageSummary_ModifierRecord$Type extends MessageType<CCitadelUserMsg_RecentDamageSummary_ModifierRecord> {
	constructor() {
		super("CCitadelUserMsg_RecentDamageSummary.ModifierRecord", [
			{
				no: 1,
				name: "ability_id",
				kind: "scalar",
				localName: "ability_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "modifier_type_id",
				kind: "scalar",
				localName: "modifier_type_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "entindex_caster",
				kind: "scalar",
				localName: "entindex_caster",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 4,
				name: "start_time",
				kind: "scalar",
				localName: "start_time",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 5,
				name: "end_time",
				kind: "scalar",
				localName: "end_time",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 6,
				name: "debuff",
				kind: "scalar",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CCitadelUserMsg_RecentDamageSummary_ModifierRecord>,
	): CCitadelUserMsg_RecentDamageSummary_ModifierRecord {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined)
			reflectionMergePartial<CCitadelUserMsg_RecentDamageSummary_ModifierRecord>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_RecentDamageSummary_ModifierRecord,
	): CCitadelUserMsg_RecentDamageSummary_ModifierRecord {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 ability_id */ 1:
					message.ability_id = reader.uint32();
					break;
				case /* optional uint32 modifier_type_id */ 2:
					message.modifier_type_id = reader.uint32();
					break;
				case /* optional int32 entindex_caster */ 3:
					message.entindex_caster = reader.int32();
					break;
				case /* optional float start_time */ 4:
					message.start_time = reader.float();
					break;
				case /* optional float end_time */ 5:
					message.end_time = reader.float();
					break;
				case /* optional bool debuff */ 6:
					message.debuff = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_RecentDamageSummary_ModifierRecord,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 ability_id = 1; */
		if (message.ability_id !== undefined) writer.tag(1, WireType.Varint).uint32(message.ability_id);
		/* optional uint32 modifier_type_id = 2; */
		if (message.modifier_type_id !== undefined) writer.tag(2, WireType.Varint).uint32(message.modifier_type_id);
		/* optional int32 entindex_caster = 3; */
		if (message.entindex_caster !== undefined) writer.tag(3, WireType.Varint).int32(message.entindex_caster);
		/* optional float start_time = 4; */
		if (message.start_time !== undefined) writer.tag(4, WireType.Bit32).float(message.start_time);
		/* optional float end_time = 5; */
		if (message.end_time !== undefined) writer.tag(5, WireType.Bit32).float(message.end_time);
		/* optional bool debuff = 6; */
		if (message.debuff !== undefined) writer.tag(6, WireType.Varint).bool(message.debuff);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_RecentDamageSummary.ModifierRecord
 */
export const CCitadelUserMsg_RecentDamageSummary_ModifierRecord =
	new CCitadelUserMsg_RecentDamageSummary_ModifierRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_SpectatorTeamChanged$Type extends MessageType<CCitadelUserMsg_SpectatorTeamChanged> {
	constructor() {
		super("CCitadelUserMsg_SpectatorTeamChanged", [
			{
				no: 1,
				name: "teamnumber",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_SpectatorTeamChanged>): CCitadelUserMsg_SpectatorTeamChanged {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_SpectatorTeamChanged>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_SpectatorTeamChanged,
	): CCitadelUserMsg_SpectatorTeamChanged {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 teamnumber */ 1:
					message.teamnumber = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_SpectatorTeamChanged,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 teamnumber = 1; */
		if (message.teamnumber !== undefined) writer.tag(1, WireType.Varint).int32(message.teamnumber);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_SpectatorTeamChanged
 */
export const CCitadelUserMsg_SpectatorTeamChanged = new CCitadelUserMsg_SpectatorTeamChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ChatWheel$Type extends MessageType<CCitadelUserMsg_ChatWheel> {
	constructor() {
		super("CCitadelUserMsg_ChatWheel", [
			{
				no: 1,
				name: "chat_message_id",
				kind: "scalar",
				localName: "chat_message_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "player_slot",
				kind: "scalar",
				localName: "player_slot",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "pawn_entindex",
				kind: "scalar",
				localName: "pawn_entindex",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 4,
				name: "account_id",
				kind: "scalar",
				localName: "account_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 5,
				name: "hero_id",
				kind: "scalar",
				localName: "hero_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 6,
				name: "param_1",
				kind: "scalar",
				localName: "param_1",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 7,
				name: "lane_color",
				kind: "enum",
				localName: "lane_color",
				opt: true,
				T: () => ["CMsgLaneColor", CMsgLaneColor],
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_ChatWheel>): CCitadelUserMsg_ChatWheel {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_ChatWheel>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_ChatWheel,
	): CCitadelUserMsg_ChatWheel {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 chat_message_id */ 1:
					message.chat_message_id = reader.uint32();
					break;
				case /* optional int32 player_slot */ 2:
					message.player_slot = reader.int32();
					break;
				case /* optional int32 pawn_entindex */ 3:
					message.pawn_entindex = reader.int32();
					break;
				case /* optional uint32 account_id */ 4:
					message.account_id = reader.uint32();
					break;
				case /* optional uint32 hero_id */ 5:
					message.hero_id = reader.uint32();
					break;
				case /* optional string param_1 */ 6:
					message.param_1 = reader.string();
					break;
				case /* optional CMsgLaneColor lane_color */ 7:
					message.lane_color = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_ChatWheel,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 chat_message_id = 1; */
		if (message.chat_message_id !== undefined) writer.tag(1, WireType.Varint).uint32(message.chat_message_id);
		/* optional int32 player_slot = 2; */
		if (message.player_slot !== undefined) writer.tag(2, WireType.Varint).int32(message.player_slot);
		/* optional int32 pawn_entindex = 3; */
		if (message.pawn_entindex !== undefined) writer.tag(3, WireType.Varint).int32(message.pawn_entindex);
		/* optional uint32 account_id = 4; */
		if (message.account_id !== undefined) writer.tag(4, WireType.Varint).uint32(message.account_id);
		/* optional uint32 hero_id = 5; */
		if (message.hero_id !== undefined) writer.tag(5, WireType.Varint).uint32(message.hero_id);
		/* optional string param_1 = 6; */
		if (message.param_1 !== undefined) writer.tag(6, WireType.LengthDelimited).string(message.param_1);
		/* optional CMsgLaneColor lane_color = 7; */
		if (message.lane_color !== undefined) writer.tag(7, WireType.Varint).int32(message.lane_color);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ChatWheel
 */
export const CCitadelUserMsg_ChatWheel = new CCitadelUserMsg_ChatWheel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ChatMsg$Type extends MessageType<CCitadelUserMsg_ChatMsg> {
	constructor() {
		super("CCitadelUserMsg_ChatMsg", [
			{
				no: 1,
				name: "player_slot",
				kind: "scalar",
				localName: "player_slot",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "text",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 3,
				name: "all_chat",
				kind: "scalar",
				localName: "all_chat",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 4,
				name: "lane_color",
				kind: "enum",
				localName: "lane_color",
				opt: true,
				T: () => ["CMsgLaneColor", CMsgLaneColor],
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_ChatMsg>): CCitadelUserMsg_ChatMsg {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_ChatMsg>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_ChatMsg,
	): CCitadelUserMsg_ChatMsg {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 player_slot */ 1:
					message.player_slot = reader.int32();
					break;
				case /* optional string text */ 2:
					message.text = reader.string();
					break;
				case /* optional bool all_chat */ 3:
					message.all_chat = reader.bool();
					break;
				case /* optional CMsgLaneColor lane_color */ 4:
					message.lane_color = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_ChatMsg,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 player_slot = 1; */
		if (message.player_slot !== undefined) writer.tag(1, WireType.Varint).int32(message.player_slot);
		/* optional string text = 2; */
		if (message.text !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.text);
		/* optional bool all_chat = 3; */
		if (message.all_chat !== undefined) writer.tag(3, WireType.Varint).bool(message.all_chat);
		/* optional CMsgLaneColor lane_color = 4; */
		if (message.lane_color !== undefined) writer.tag(4, WireType.Varint).int32(message.lane_color);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ChatMsg
 */
export const CCitadelUserMsg_ChatMsg = new CCitadelUserMsg_ChatMsg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_GoldHistory$Type extends MessageType<CCitadelUserMsg_GoldHistory> {
	constructor() {
		super("CCitadelUserMsg_GoldHistory", [
			{
				no: 1,
				name: "entindex_player",
				kind: "scalar",
				localName: "entindex_player",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "minute_records",
				kind: "message",
				localName: "minute_records",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CCitadelUserMsg_GoldHistory_MinuteRecord,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_GoldHistory>): CCitadelUserMsg_GoldHistory {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.minute_records = [];
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_GoldHistory>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_GoldHistory,
	): CCitadelUserMsg_GoldHistory {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 entindex_player */ 1:
					message.entindex_player = reader.int32();
					break;
				case /* repeated CCitadelUserMsg_GoldHistory.MinuteRecord minute_records */ 2:
					message.minute_records.push(
						CCitadelUserMsg_GoldHistory_MinuteRecord.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_GoldHistory,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 entindex_player = 1; */
		if (message.entindex_player !== undefined) writer.tag(1, WireType.Varint).int32(message.entindex_player);
		/* repeated CCitadelUserMsg_GoldHistory.MinuteRecord minute_records = 2; */
		for (let i = 0; i < message.minute_records.length; i++)
			CCitadelUserMsg_GoldHistory_MinuteRecord.internalBinaryWrite(
				message.minute_records[i],
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_GoldHistory
 */
export const CCitadelUserMsg_GoldHistory = new CCitadelUserMsg_GoldHistory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_GoldHistory_GoldRecord$Type extends MessageType<CCitadelUserMsg_GoldHistory_GoldRecord> {
	constructor() {
		super("CCitadelUserMsg_GoldHistory.GoldRecord", [
			{
				no: 1,
				name: "currency_source",
				kind: "scalar",
				localName: "currency_source",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "gold",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "events",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_GoldHistory_GoldRecord>): CCitadelUserMsg_GoldHistory_GoldRecord {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_GoldHistory_GoldRecord>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_GoldHistory_GoldRecord,
	): CCitadelUserMsg_GoldHistory_GoldRecord {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 currency_source */ 1:
					message.currency_source = reader.int32();
					break;
				case /* optional int32 gold */ 2:
					message.gold = reader.int32();
					break;
				case /* optional int32 events */ 3:
					message.events = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_GoldHistory_GoldRecord,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 currency_source = 1; */
		if (message.currency_source !== undefined) writer.tag(1, WireType.Varint).int32(message.currency_source);
		/* optional int32 gold = 2; */
		if (message.gold !== undefined) writer.tag(2, WireType.Varint).int32(message.gold);
		/* optional int32 events = 3; */
		if (message.events !== undefined) writer.tag(3, WireType.Varint).int32(message.events);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_GoldHistory.GoldRecord
 */
export const CCitadelUserMsg_GoldHistory_GoldRecord = new CCitadelUserMsg_GoldHistory_GoldRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_GoldHistory_MinuteRecord$Type extends MessageType<CCitadelUserMsg_GoldHistory_MinuteRecord> {
	constructor() {
		super("CCitadelUserMsg_GoldHistory.MinuteRecord", [
			{
				no: 1,
				name: "match_minute",
				kind: "scalar",
				localName: "match_minute",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "gold_records",
				kind: "message",
				localName: "gold_records",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CCitadelUserMsg_GoldHistory_GoldRecord,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_GoldHistory_MinuteRecord>): CCitadelUserMsg_GoldHistory_MinuteRecord {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.gold_records = [];
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_GoldHistory_MinuteRecord>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_GoldHistory_MinuteRecord,
	): CCitadelUserMsg_GoldHistory_MinuteRecord {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 match_minute */ 1:
					message.match_minute = reader.int32();
					break;
				case /* repeated CCitadelUserMsg_GoldHistory.GoldRecord gold_records */ 2:
					message.gold_records.push(
						CCitadelUserMsg_GoldHistory_GoldRecord.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_GoldHistory_MinuteRecord,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 match_minute = 1; */
		if (message.match_minute !== undefined) writer.tag(1, WireType.Varint).int32(message.match_minute);
		/* repeated CCitadelUserMsg_GoldHistory.GoldRecord gold_records = 2; */
		for (let i = 0; i < message.gold_records.length; i++)
			CCitadelUserMsg_GoldHistory_GoldRecord.internalBinaryWrite(
				message.gold_records[i],
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_GoldHistory.MinuteRecord
 */
export const CCitadelUserMsg_GoldHistory_MinuteRecord = new CCitadelUserMsg_GoldHistory_MinuteRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_CameraController$Type extends MessageType<CCitadelUserMsg_CameraController> {
	constructor() {
		super("CCitadelUserMsg_CameraController", [
			{
				no: 1,
				name: "action",
				kind: "enum",
				T: () => ["CameraAction", CameraAction],
			},
			{
				no: 2,
				name: "operation",
				kind: "enum",
				opt: true,
				T: () => ["CameraOperation", CameraOperation],
			},
			{
				no: 3,
				name: "param",
				kind: "enum",
				opt: true,
				T: () => ["CameraParam", CameraParam],
			},
			{
				no: 12,
				name: "param_mode",
				kind: "enum",
				localName: "param_mode",
				opt: true,
				T: () => ["CameraParamMode", CameraParamMode],
			},
			{
				no: 4,
				name: "delay",
				kind: "scalar",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 11,
				name: "relative_values",
				kind: "scalar",
				localName: "relative_values",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 5,
				name: "context_symbol_id",
				kind: "scalar",
				localName: "context_symbol_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 13,
				name: "priority",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 6,
				name: "maintain",
				kind: "message",
				T: () => CCitadelUserMsg_CameraController_Maintain,
			},
			{
				no: 7,
				name: "approach",
				kind: "message",
				T: () => CCitadelUserMsg_CameraController_Approach,
			},
			{
				no: 8,
				name: "spring",
				kind: "message",
				T: () => CCitadelUserMsg_CameraController_Spring,
			},
			{
				no: 9,
				name: "lerp",
				kind: "message",
				T: () => CCitadelUserMsg_CameraController_Lerp,
			},
			{
				no: 10,
				name: "lag",
				kind: "message",
				T: () => CCitadelUserMsg_CameraController_Lag,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_CameraController>): CCitadelUserMsg_CameraController {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.action = 0;
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_CameraController>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_CameraController,
	): CCitadelUserMsg_CameraController {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* CameraAction action */ 1:
					message.action = reader.int32();
					break;
				case /* optional CameraOperation operation */ 2:
					message.operation = reader.int32();
					break;
				case /* optional CameraParam param */ 3:
					message.param = reader.int32();
					break;
				case /* optional CameraParamMode param_mode */ 12:
					message.param_mode = reader.int32();
					break;
				case /* optional float delay */ 4:
					message.delay = reader.float();
					break;
				case /* optional bool relative_values */ 11:
					message.relative_values = reader.bool();
					break;
				case /* optional uint32 context_symbol_id */ 5:
					message.context_symbol_id = reader.uint32();
					break;
				case /* optional uint32 priority */ 13:
					message.priority = reader.uint32();
					break;
				case /* optional CCitadelUserMsg_CameraController.Maintain maintain */ 6:
					message.maintain = CCitadelUserMsg_CameraController_Maintain.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.maintain,
					);
					break;
				case /* optional CCitadelUserMsg_CameraController.Approach approach */ 7:
					message.approach = CCitadelUserMsg_CameraController_Approach.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.approach,
					);
					break;
				case /* optional CCitadelUserMsg_CameraController.Spring spring */ 8:
					message.spring = CCitadelUserMsg_CameraController_Spring.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.spring,
					);
					break;
				case /* optional CCitadelUserMsg_CameraController.Lerp lerp */ 9:
					message.lerp = CCitadelUserMsg_CameraController_Lerp.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.lerp,
					);
					break;
				case /* optional CCitadelUserMsg_CameraController.Lag lag */ 10:
					message.lag = CCitadelUserMsg_CameraController_Lag.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.lag,
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_CameraController,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* CameraAction action = 1; */
		if (message.action !== 0) writer.tag(1, WireType.Varint).int32(message.action);
		/* optional CameraOperation operation = 2; */
		if (message.operation !== undefined) writer.tag(2, WireType.Varint).int32(message.operation);
		/* optional CameraParam param = 3; */
		if (message.param !== undefined) writer.tag(3, WireType.Varint).int32(message.param);
		/* optional CameraParamMode param_mode = 12; */
		if (message.param_mode !== undefined) writer.tag(12, WireType.Varint).int32(message.param_mode);
		/* optional float delay = 4; */
		if (message.delay !== undefined) writer.tag(4, WireType.Bit32).float(message.delay);
		/* optional bool relative_values = 11; */
		if (message.relative_values !== undefined) writer.tag(11, WireType.Varint).bool(message.relative_values);
		/* optional uint32 context_symbol_id = 5; */
		if (message.context_symbol_id !== undefined) writer.tag(5, WireType.Varint).uint32(message.context_symbol_id);
		/* optional uint32 priority = 13; */
		if (message.priority !== undefined) writer.tag(13, WireType.Varint).uint32(message.priority);
		/* optional CCitadelUserMsg_CameraController.Maintain maintain = 6; */
		if (message.maintain)
			CCitadelUserMsg_CameraController_Maintain.internalBinaryWrite(
				message.maintain,
				writer.tag(6, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CCitadelUserMsg_CameraController.Approach approach = 7; */
		if (message.approach)
			CCitadelUserMsg_CameraController_Approach.internalBinaryWrite(
				message.approach,
				writer.tag(7, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CCitadelUserMsg_CameraController.Spring spring = 8; */
		if (message.spring)
			CCitadelUserMsg_CameraController_Spring.internalBinaryWrite(
				message.spring,
				writer.tag(8, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CCitadelUserMsg_CameraController.Lerp lerp = 9; */
		if (message.lerp)
			CCitadelUserMsg_CameraController_Lerp.internalBinaryWrite(
				message.lerp,
				writer.tag(9, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CCitadelUserMsg_CameraController.Lag lag = 10; */
		if (message.lag)
			CCitadelUserMsg_CameraController_Lag.internalBinaryWrite(
				message.lag,
				writer.tag(10, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_CameraController
 */
export const CCitadelUserMsg_CameraController = new CCitadelUserMsg_CameraController$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_CameraController_Maintain$Type extends MessageType<CCitadelUserMsg_CameraController_Maintain> {
	constructor() {
		super("CCitadelUserMsg_CameraController.Maintain", [
			{
				no: 1,
				name: "duration",
				kind: "scalar",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 2,
				name: "maintain_vector",
				kind: "message",
				localName: "maintain_vector",
				T: () => CMsgVector,
			},
			{
				no: 3,
				name: "maintain_float",
				kind: "scalar",
				localName: "maintain_float",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 4,
				name: "maintain_current",
				kind: "scalar",
				localName: "maintain_current",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_CameraController_Maintain>): CCitadelUserMsg_CameraController_Maintain {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_CameraController_Maintain>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_CameraController_Maintain,
	): CCitadelUserMsg_CameraController_Maintain {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional float duration */ 1:
					message.duration = reader.float();
					break;
				case /* optional CMsgVector maintain_vector */ 2:
					message.maintain_vector = CMsgVector.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.maintain_vector,
					);
					break;
				case /* optional float maintain_float */ 3:
					message.maintain_float = reader.float();
					break;
				case /* optional bool maintain_current */ 4:
					message.maintain_current = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_CameraController_Maintain,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional float duration = 1; */
		if (message.duration !== undefined) writer.tag(1, WireType.Bit32).float(message.duration);
		/* optional CMsgVector maintain_vector = 2; */
		if (message.maintain_vector)
			CMsgVector.internalBinaryWrite(
				message.maintain_vector,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional float maintain_float = 3; */
		if (message.maintain_float !== undefined) writer.tag(3, WireType.Bit32).float(message.maintain_float);
		/* optional bool maintain_current = 4; */
		if (message.maintain_current !== undefined) writer.tag(4, WireType.Varint).bool(message.maintain_current);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_CameraController.Maintain
 */
export const CCitadelUserMsg_CameraController_Maintain = new CCitadelUserMsg_CameraController_Maintain$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_CameraController_Approach$Type extends MessageType<CCitadelUserMsg_CameraController_Approach> {
	constructor() {
		super("CCitadelUserMsg_CameraController.Approach", [
			{
				no: 1,
				name: "speed",
				kind: "scalar",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 2,
				name: "default_speed",
				kind: "scalar",
				localName: "default_speed",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 3,
				name: "acceleration",
				kind: "scalar",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 4,
				name: "min_duration",
				kind: "scalar",
				localName: "min_duration",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 5,
				name: "approach_float",
				kind: "scalar",
				localName: "approach_float",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 6,
				name: "approach_vector",
				kind: "message",
				localName: "approach_vector",
				T: () => CMsgVector,
			},
			{
				no: 7,
				name: "chase_default",
				kind: "scalar",
				localName: "chase_default",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_CameraController_Approach>): CCitadelUserMsg_CameraController_Approach {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_CameraController_Approach>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_CameraController_Approach,
	): CCitadelUserMsg_CameraController_Approach {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional float speed */ 1:
					message.speed = reader.float();
					break;
				case /* optional float default_speed */ 2:
					message.default_speed = reader.float();
					break;
				case /* optional float acceleration */ 3:
					message.acceleration = reader.float();
					break;
				case /* optional float min_duration */ 4:
					message.min_duration = reader.float();
					break;
				case /* optional float approach_float */ 5:
					message.approach_float = reader.float();
					break;
				case /* optional CMsgVector approach_vector */ 6:
					message.approach_vector = CMsgVector.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.approach_vector,
					);
					break;
				case /* optional bool chase_default */ 7:
					message.chase_default = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_CameraController_Approach,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional float speed = 1; */
		if (message.speed !== undefined) writer.tag(1, WireType.Bit32).float(message.speed);
		/* optional float default_speed = 2; */
		if (message.default_speed !== undefined) writer.tag(2, WireType.Bit32).float(message.default_speed);
		/* optional float acceleration = 3; */
		if (message.acceleration !== undefined) writer.tag(3, WireType.Bit32).float(message.acceleration);
		/* optional float min_duration = 4; */
		if (message.min_duration !== undefined) writer.tag(4, WireType.Bit32).float(message.min_duration);
		/* optional float approach_float = 5; */
		if (message.approach_float !== undefined) writer.tag(5, WireType.Bit32).float(message.approach_float);
		/* optional CMsgVector approach_vector = 6; */
		if (message.approach_vector)
			CMsgVector.internalBinaryWrite(
				message.approach_vector,
				writer.tag(6, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional bool chase_default = 7; */
		if (message.chase_default !== undefined) writer.tag(7, WireType.Varint).bool(message.chase_default);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_CameraController.Approach
 */
export const CCitadelUserMsg_CameraController_Approach = new CCitadelUserMsg_CameraController_Approach$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_CameraController_Spring$Type extends MessageType<CCitadelUserMsg_CameraController_Spring> {
	constructor() {
		super("CCitadelUserMsg_CameraController.Spring", [
			{
				no: 1,
				name: "spring_strength",
				kind: "scalar",
				localName: "spring_strength",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 4,
				name: "min_speed",
				kind: "scalar",
				localName: "min_speed",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 5,
				name: "max_duration",
				kind: "scalar",
				localName: "max_duration",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 6,
				name: "target_float",
				kind: "scalar",
				localName: "target_float",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 7,
				name: "target_vector",
				kind: "message",
				localName: "target_vector",
				T: () => CMsgVector,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_CameraController_Spring>): CCitadelUserMsg_CameraController_Spring {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_CameraController_Spring>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_CameraController_Spring,
	): CCitadelUserMsg_CameraController_Spring {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional float spring_strength */ 1:
					message.spring_strength = reader.float();
					break;
				case /* optional float min_speed */ 4:
					message.min_speed = reader.float();
					break;
				case /* optional float max_duration */ 5:
					message.max_duration = reader.float();
					break;
				case /* optional float target_float */ 6:
					message.target_float = reader.float();
					break;
				case /* optional CMsgVector target_vector */ 7:
					message.target_vector = CMsgVector.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.target_vector,
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_CameraController_Spring,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional float spring_strength = 1; */
		if (message.spring_strength !== undefined) writer.tag(1, WireType.Bit32).float(message.spring_strength);
		/* optional float min_speed = 4; */
		if (message.min_speed !== undefined) writer.tag(4, WireType.Bit32).float(message.min_speed);
		/* optional float max_duration = 5; */
		if (message.max_duration !== undefined) writer.tag(5, WireType.Bit32).float(message.max_duration);
		/* optional float target_float = 6; */
		if (message.target_float !== undefined) writer.tag(6, WireType.Bit32).float(message.target_float);
		/* optional CMsgVector target_vector = 7; */
		if (message.target_vector)
			CMsgVector.internalBinaryWrite(
				message.target_vector,
				writer.tag(7, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_CameraController.Spring
 */
export const CCitadelUserMsg_CameraController_Spring = new CCitadelUserMsg_CameraController_Spring$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_CameraController_Lerp$Type extends MessageType<CCitadelUserMsg_CameraController_Lerp> {
	constructor() {
		super("CCitadelUserMsg_CameraController.Lerp", [
			{
				no: 1,
				name: "start_float",
				kind: "scalar",
				localName: "start_float",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 2,
				name: "start_vector",
				kind: "message",
				localName: "start_vector",
				T: () => CMsgVector,
			},
			{
				no: 3,
				name: "end_float",
				kind: "scalar",
				localName: "end_float",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 4,
				name: "end_vector",
				kind: "message",
				localName: "end_vector",
				T: () => CMsgVector,
			},
			{
				no: 5,
				name: "bias",
				kind: "scalar",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 6,
				name: "gain",
				kind: "scalar",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 7,
				name: "duration",
				kind: "scalar",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_CameraController_Lerp>): CCitadelUserMsg_CameraController_Lerp {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_CameraController_Lerp>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_CameraController_Lerp,
	): CCitadelUserMsg_CameraController_Lerp {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional float start_float */ 1:
					message.start_float = reader.float();
					break;
				case /* optional CMsgVector start_vector */ 2:
					message.start_vector = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.start_vector);
					break;
				case /* optional float end_float */ 3:
					message.end_float = reader.float();
					break;
				case /* optional CMsgVector end_vector */ 4:
					message.end_vector = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.end_vector);
					break;
				case /* optional float bias */ 5:
					message.bias = reader.float();
					break;
				case /* optional float gain */ 6:
					message.gain = reader.float();
					break;
				case /* optional float duration */ 7:
					message.duration = reader.float();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_CameraController_Lerp,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional float start_float = 1; */
		if (message.start_float !== undefined) writer.tag(1, WireType.Bit32).float(message.start_float);
		/* optional CMsgVector start_vector = 2; */
		if (message.start_vector)
			CMsgVector.internalBinaryWrite(
				message.start_vector,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional float end_float = 3; */
		if (message.end_float !== undefined) writer.tag(3, WireType.Bit32).float(message.end_float);
		/* optional CMsgVector end_vector = 4; */
		if (message.end_vector)
			CMsgVector.internalBinaryWrite(
				message.end_vector,
				writer.tag(4, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional float bias = 5; */
		if (message.bias !== undefined) writer.tag(5, WireType.Bit32).float(message.bias);
		/* optional float gain = 6; */
		if (message.gain !== undefined) writer.tag(6, WireType.Bit32).float(message.gain);
		/* optional float duration = 7; */
		if (message.duration !== undefined) writer.tag(7, WireType.Bit32).float(message.duration);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_CameraController.Lerp
 */
export const CCitadelUserMsg_CameraController_Lerp = new CCitadelUserMsg_CameraController_Lerp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_CameraController_Lag$Type extends MessageType<CCitadelUserMsg_CameraController_Lag> {
	constructor() {
		super("CCitadelUserMsg_CameraController.Lag", [
			{
				no: 1,
				name: "min_duration",
				kind: "scalar",
				localName: "min_duration",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 2,
				name: "lag_time",
				kind: "scalar",
				localName: "lag_time",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 3,
				name: "max_speed",
				kind: "scalar",
				localName: "max_speed",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 4,
				name: "spring_strength",
				kind: "scalar",
				localName: "spring_strength",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 5,
				name: "increase_spring_strength_to_keep_target_on_screen",
				kind: "scalar",
				localName: "increase_spring_strength_to_keep_target_on_screen",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_CameraController_Lag>): CCitadelUserMsg_CameraController_Lag {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_CameraController_Lag>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_CameraController_Lag,
	): CCitadelUserMsg_CameraController_Lag {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional float min_duration */ 1:
					message.min_duration = reader.float();
					break;
				case /* optional float lag_time */ 2:
					message.lag_time = reader.float();
					break;
				case /* optional float max_speed */ 3:
					message.max_speed = reader.float();
					break;
				case /* optional float spring_strength */ 4:
					message.spring_strength = reader.float();
					break;
				case /* optional bool increase_spring_strength_to_keep_target_on_screen */ 5:
					message.increase_spring_strength_to_keep_target_on_screen = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_CameraController_Lag,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional float min_duration = 1; */
		if (message.min_duration !== undefined) writer.tag(1, WireType.Bit32).float(message.min_duration);
		/* optional float lag_time = 2; */
		if (message.lag_time !== undefined) writer.tag(2, WireType.Bit32).float(message.lag_time);
		/* optional float max_speed = 3; */
		if (message.max_speed !== undefined) writer.tag(3, WireType.Bit32).float(message.max_speed);
		/* optional float spring_strength = 4; */
		if (message.spring_strength !== undefined) writer.tag(4, WireType.Bit32).float(message.spring_strength);
		/* optional bool increase_spring_strength_to_keep_target_on_screen = 5; */
		if (message.increase_spring_strength_to_keep_target_on_screen !== undefined)
			writer.tag(5, WireType.Varint).bool(message.increase_spring_strength_to_keep_target_on_screen);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_CameraController.Lag
 */
export const CCitadelUserMsg_CameraController_Lag = new CCitadelUserMsg_CameraController_Lag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_PostMatchDetails$Type extends MessageType<CCitadelUserMsg_PostMatchDetails> {
	constructor() {
		super("CCitadelUserMsg_PostMatchDetails", [
			{
				no: 1,
				name: "match_details",
				kind: "scalar",
				localName: "match_details",
				opt: true,
				T: 12 /*ScalarType.BYTES*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_PostMatchDetails>): CCitadelUserMsg_PostMatchDetails {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_PostMatchDetails>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_PostMatchDetails,
	): CCitadelUserMsg_PostMatchDetails {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional bytes match_details */ 1:
					message.match_details = reader.bytes();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_PostMatchDetails,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional bytes match_details = 1; */
		if (message.match_details !== undefined) writer.tag(1, WireType.LengthDelimited).bytes(message.match_details);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_PostMatchDetails
 */
export const CCitadelUserMsg_PostMatchDetails = new CCitadelUserMsg_PostMatchDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ChatEvent$Type extends MessageType<CCitadelUserMsg_ChatEvent> {
	constructor() {
		super("CCitadelUserMsg_ChatEvent", [
			{
				no: 1,
				name: "type",
				kind: "enum",
				opt: true,
				T: () => ["ECitadelChatMessage", ECitadelChatMessage],
			},
			{
				no: 2,
				name: "values",
				kind: "scalar",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "player_slots",
				kind: "scalar",
				localName: "player_slots",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_ChatEvent>): CCitadelUserMsg_ChatEvent {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.values = [];
		message.player_slots = [];
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_ChatEvent>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_ChatEvent,
	): CCitadelUserMsg_ChatEvent {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional ECitadelChatMessage type */ 1:
					message.type = reader.int32();
					break;
				case /* repeated uint32 values */ 2:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.values.push(reader.uint32());
					else message.values.push(reader.uint32());
					break;
				case /* repeated int32 player_slots */ 3:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.player_slots.push(reader.int32());
					else message.player_slots.push(reader.int32());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_ChatEvent,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional ECitadelChatMessage type = 1; */
		if (message.type !== undefined) writer.tag(1, WireType.Varint).int32(message.type);
		/* repeated uint32 values = 2; */
		for (let i = 0; i < message.values.length; i++) writer.tag(2, WireType.Varint).uint32(message.values[i]);
		/* repeated int32 player_slots = 3; */
		for (let i = 0; i < message.player_slots.length; i++) writer.tag(3, WireType.Varint).int32(message.player_slots[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ChatEvent
 */
export const CCitadelUserMsg_ChatEvent = new CCitadelUserMsg_ChatEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_HeroKilled$Type extends MessageType<CCitadelUserMsg_HeroKilled> {
	constructor() {
		super("CCitadelUserMsg_HeroKilled", [
			{
				no: 1,
				name: "entindex_victim",
				kind: "scalar",
				localName: "entindex_victim",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "entindex_inflictor",
				kind: "scalar",
				localName: "entindex_inflictor",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "entindex_attacker",
				kind: "scalar",
				localName: "entindex_attacker",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 4,
				name: "entindex_assisters",
				kind: "scalar",
				localName: "entindex_assisters",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 5,
				name: "entindex_scorer",
				kind: "scalar",
				localName: "entindex_scorer",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 6,
				name: "respawn_reason",
				kind: "scalar",
				localName: "respawn_reason",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 7,
				name: "victim_team_number",
				kind: "scalar",
				localName: "victim_team_number",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_HeroKilled>): CCitadelUserMsg_HeroKilled {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.entindex_assisters = [];
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_HeroKilled>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_HeroKilled,
	): CCitadelUserMsg_HeroKilled {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 entindex_victim */ 1:
					message.entindex_victim = reader.int32();
					break;
				case /* optional int32 entindex_inflictor */ 2:
					message.entindex_inflictor = reader.int32();
					break;
				case /* optional int32 entindex_attacker */ 3:
					message.entindex_attacker = reader.int32();
					break;
				case /* repeated int32 entindex_assisters */ 4:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.entindex_assisters.push(reader.int32());
					else message.entindex_assisters.push(reader.int32());
					break;
				case /* optional int32 entindex_scorer */ 5:
					message.entindex_scorer = reader.int32();
					break;
				case /* optional int32 respawn_reason */ 6:
					message.respawn_reason = reader.int32();
					break;
				case /* optional int32 victim_team_number */ 7:
					message.victim_team_number = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_HeroKilled,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 entindex_victim = 1; */
		if (message.entindex_victim !== undefined) writer.tag(1, WireType.Varint).int32(message.entindex_victim);
		/* optional int32 entindex_inflictor = 2; */
		if (message.entindex_inflictor !== undefined) writer.tag(2, WireType.Varint).int32(message.entindex_inflictor);
		/* optional int32 entindex_attacker = 3; */
		if (message.entindex_attacker !== undefined) writer.tag(3, WireType.Varint).int32(message.entindex_attacker);
		/* repeated int32 entindex_assisters = 4; */
		for (let i = 0; i < message.entindex_assisters.length; i++)
			writer.tag(4, WireType.Varint).int32(message.entindex_assisters[i]);
		/* optional int32 entindex_scorer = 5; */
		if (message.entindex_scorer !== undefined) writer.tag(5, WireType.Varint).int32(message.entindex_scorer);
		/* optional int32 respawn_reason = 6; */
		if (message.respawn_reason !== undefined) writer.tag(6, WireType.Varint).int32(message.respawn_reason);
		/* optional int32 victim_team_number = 7; */
		if (message.victim_team_number !== undefined) writer.tag(7, WireType.Varint).int32(message.victim_team_number);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_HeroKilled
 */
export const CCitadelUserMsg_HeroKilled = new CCitadelUserMsg_HeroKilled$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelEntityMsg_BreakablePropSpawnDebris$Type extends MessageType<CCitadelEntityMsg_BreakablePropSpawnDebris> {
	constructor() {
		super("CCitadelEntityMsg_BreakablePropSpawnDebris", [
			{
				no: 1,
				name: "entity_msg",
				kind: "message",
				localName: "entity_msg",
				T: () => CEntityMsg,
			},
			{
				no: 2,
				name: "damage_pos",
				kind: "message",
				localName: "damage_pos",
				T: () => CMsgVector,
			},
			{
				no: 3,
				name: "damage",
				kind: "scalar",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CCitadelEntityMsg_BreakablePropSpawnDebris>,
	): CCitadelEntityMsg_BreakablePropSpawnDebris {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelEntityMsg_BreakablePropSpawnDebris>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelEntityMsg_BreakablePropSpawnDebris,
	): CCitadelEntityMsg_BreakablePropSpawnDebris {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional CEntityMsg entity_msg */ 1:
					message.entity_msg = CEntityMsg.internalBinaryRead(reader, reader.uint32(), options, message.entity_msg);
					break;
				case /* optional CMsgVector damage_pos */ 2:
					message.damage_pos = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.damage_pos);
					break;
				case /* optional float damage */ 3:
					message.damage = reader.float();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelEntityMsg_BreakablePropSpawnDebris,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional CEntityMsg entity_msg = 1; */
		if (message.entity_msg)
			CEntityMsg.internalBinaryWrite(
				message.entity_msg,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgVector damage_pos = 2; */
		if (message.damage_pos)
			CMsgVector.internalBinaryWrite(
				message.damage_pos,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional float damage = 3; */
		if (message.damage !== undefined) writer.tag(3, WireType.Bit32).float(message.damage);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelEntityMsg_BreakablePropSpawnDebris
 */
export const CCitadelEntityMsg_BreakablePropSpawnDebris = new CCitadelEntityMsg_BreakablePropSpawnDebris$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ReturnIdol$Type extends MessageType<CCitadelUserMsg_ReturnIdol> {
	constructor() {
		super("CCitadelUserMsg_ReturnIdol", [
			{
				no: 1,
				name: "location_index",
				kind: "scalar",
				localName: "location_index",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "return_location",
				kind: "message",
				localName: "return_location",
				T: () => CMsgVector,
			},
			{
				no: 3,
				name: "location_enabled",
				kind: "scalar",
				localName: "location_enabled",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_ReturnIdol>): CCitadelUserMsg_ReturnIdol {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_ReturnIdol>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_ReturnIdol,
	): CCitadelUserMsg_ReturnIdol {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 location_index */ 1:
					message.location_index = reader.int32();
					break;
				case /* optional CMsgVector return_location */ 2:
					message.return_location = CMsgVector.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.return_location,
					);
					break;
				case /* optional bool location_enabled */ 3:
					message.location_enabled = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_ReturnIdol,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 location_index = 1; */
		if (message.location_index !== undefined) writer.tag(1, WireType.Varint).int32(message.location_index);
		/* optional CMsgVector return_location = 2; */
		if (message.return_location)
			CMsgVector.internalBinaryWrite(
				message.return_location,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional bool location_enabled = 3; */
		if (message.location_enabled !== undefined) writer.tag(3, WireType.Varint).bool(message.location_enabled);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ReturnIdol
 */
export const CCitadelUserMsg_ReturnIdol = new CCitadelUserMsg_ReturnIdol$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_SetClientCameraAngles$Type extends MessageType<CCitadelUserMsg_SetClientCameraAngles> {
	constructor() {
		super("CCitadelUserMsg_SetClientCameraAngles", [
			{
				no: 1,
				name: "player_slot",
				kind: "scalar",
				localName: "player_slot",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "camera_angles",
				kind: "message",
				localName: "camera_angles",
				T: () => CMsgQAngle,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_SetClientCameraAngles>): CCitadelUserMsg_SetClientCameraAngles {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_SetClientCameraAngles>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_SetClientCameraAngles,
	): CCitadelUserMsg_SetClientCameraAngles {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 player_slot */ 1:
					message.player_slot = reader.int32();
					break;
				case /* optional CMsgQAngle camera_angles */ 2:
					message.camera_angles = CMsgQAngle.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.camera_angles,
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_SetClientCameraAngles,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 player_slot = 1; */
		if (message.player_slot !== undefined) writer.tag(1, WireType.Varint).int32(message.player_slot);
		/* optional CMsgQAngle camera_angles = 2; */
		if (message.camera_angles)
			CMsgQAngle.internalBinaryWrite(
				message.camera_angles,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_SetClientCameraAngles
 */
export const CCitadelUserMsg_SetClientCameraAngles = new CCitadelUserMsg_SetClientCameraAngles$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMessage_BulletHit$Type extends MessageType<CCitadelUserMessage_BulletHit> {
	constructor() {
		super("CCitadelUserMessage_BulletHit", [
			{
				no: 1,
				name: "shotid",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "pellet",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "hit_entindex",
				kind: "scalar",
				localName: "hit_entindex",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMessage_BulletHit>): CCitadelUserMessage_BulletHit {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMessage_BulletHit>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMessage_BulletHit,
	): CCitadelUserMessage_BulletHit {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 shotid */ 1:
					message.shotid = reader.int32();
					break;
				case /* optional int32 pellet */ 2:
					message.pellet = reader.int32();
					break;
				case /* optional int32 hit_entindex */ 3:
					message.hit_entindex = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMessage_BulletHit,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 shotid = 1; */
		if (message.shotid !== undefined) writer.tag(1, WireType.Varint).int32(message.shotid);
		/* optional int32 pellet = 2; */
		if (message.pellet !== undefined) writer.tag(2, WireType.Varint).int32(message.pellet);
		/* optional int32 hit_entindex = 3; */
		if (message.hit_entindex !== undefined) writer.tag(3, WireType.Varint).int32(message.hit_entindex);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMessage_BulletHit
 */
export const CCitadelUserMessage_BulletHit = new CCitadelUserMessage_BulletHit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMessage_ObjectiveMask$Type extends MessageType<CCitadelUserMessage_ObjectiveMask> {
	constructor() {
		super("CCitadelUserMessage_ObjectiveMask", [
			{
				no: 2,
				name: "objective_mask_team0",
				kind: "scalar",
				localName: "objective_mask_team0",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 3,
				name: "objective_mask_team1",
				kind: "scalar",
				localName: "objective_mask_team1",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMessage_ObjectiveMask>): CCitadelUserMessage_ObjectiveMask {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMessage_ObjectiveMask>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMessage_ObjectiveMask,
	): CCitadelUserMessage_ObjectiveMask {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint64 objective_mask_team0 */ 2:
					message.objective_mask_team0 = reader.uint64().toBigInt();
					break;
				case /* optional uint64 objective_mask_team1 */ 3:
					message.objective_mask_team1 = reader.uint64().toBigInt();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMessage_ObjectiveMask,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint64 objective_mask_team0 = 2; */
		if (message.objective_mask_team0 !== undefined) writer.tag(2, WireType.Varint).uint64(message.objective_mask_team0);
		/* optional uint64 objective_mask_team1 = 3; */
		if (message.objective_mask_team1 !== undefined) writer.tag(3, WireType.Varint).uint64(message.objective_mask_team1);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMessage_ObjectiveMask
 */
export const CCitadelUserMessage_ObjectiveMask = new CCitadelUserMessage_ObjectiveMask$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMessage_ModifierApplied$Type extends MessageType<CCitadelUserMessage_ModifierApplied> {
	constructor() {
		super("CCitadelUserMessage_ModifierApplied", [
			{
				no: 1,
				name: "entindex_caster",
				kind: "scalar",
				localName: "entindex_caster",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "entindex_parent",
				kind: "scalar",
				localName: "entindex_parent",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "serial_number",
				kind: "scalar",
				localName: "serial_number",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMessage_ModifierApplied>): CCitadelUserMessage_ModifierApplied {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMessage_ModifierApplied>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMessage_ModifierApplied,
	): CCitadelUserMessage_ModifierApplied {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 entindex_caster */ 1:
					message.entindex_caster = reader.int32();
					break;
				case /* optional int32 entindex_parent */ 2:
					message.entindex_parent = reader.int32();
					break;
				case /* optional int32 serial_number */ 3:
					message.serial_number = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMessage_ModifierApplied,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 entindex_caster = 1; */
		if (message.entindex_caster !== undefined) writer.tag(1, WireType.Varint).int32(message.entindex_caster);
		/* optional int32 entindex_parent = 2; */
		if (message.entindex_parent !== undefined) writer.tag(2, WireType.Varint).int32(message.entindex_parent);
		/* optional int32 serial_number = 3; */
		if (message.serial_number !== undefined) writer.tag(3, WireType.Varint).int32(message.serial_number);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMessage_ModifierApplied
 */
export const CCitadelUserMessage_ModifierApplied = new CCitadelUserMessage_ModifierApplied$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMessage_AuraModifierApplied$Type extends MessageType<CCitadelUserMessage_AuraModifierApplied> {
	constructor() {
		super("CCitadelUserMessage_AuraModifierApplied", [
			{
				no: 1,
				name: "entindex_caster",
				kind: "scalar",
				localName: "entindex_caster",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "entindex_target",
				kind: "scalar",
				localName: "entindex_target",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "modifier_type_id",
				kind: "scalar",
				localName: "modifier_type_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 4,
				name: "modifier_serial_number",
				kind: "scalar",
				localName: "modifier_serial_number",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 5,
				name: "aura_start_time",
				kind: "scalar",
				localName: "aura_start_time",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 6,
				name: "aura_end_time",
				kind: "scalar",
				localName: "aura_end_time",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMessage_AuraModifierApplied>): CCitadelUserMessage_AuraModifierApplied {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMessage_AuraModifierApplied>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMessage_AuraModifierApplied,
	): CCitadelUserMessage_AuraModifierApplied {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 entindex_caster */ 1:
					message.entindex_caster = reader.int32();
					break;
				case /* optional int32 entindex_target */ 2:
					message.entindex_target = reader.int32();
					break;
				case /* optional uint32 modifier_type_id */ 3:
					message.modifier_type_id = reader.uint32();
					break;
				case /* optional int32 modifier_serial_number */ 4:
					message.modifier_serial_number = reader.int32();
					break;
				case /* optional float aura_start_time */ 5:
					message.aura_start_time = reader.float();
					break;
				case /* optional float aura_end_time */ 6:
					message.aura_end_time = reader.float();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMessage_AuraModifierApplied,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 entindex_caster = 1; */
		if (message.entindex_caster !== undefined) writer.tag(1, WireType.Varint).int32(message.entindex_caster);
		/* optional int32 entindex_target = 2; */
		if (message.entindex_target !== undefined) writer.tag(2, WireType.Varint).int32(message.entindex_target);
		/* optional uint32 modifier_type_id = 3; */
		if (message.modifier_type_id !== undefined) writer.tag(3, WireType.Varint).uint32(message.modifier_type_id);
		/* optional int32 modifier_serial_number = 4; */
		if (message.modifier_serial_number !== undefined)
			writer.tag(4, WireType.Varint).int32(message.modifier_serial_number);
		/* optional float aura_start_time = 5; */
		if (message.aura_start_time !== undefined) writer.tag(5, WireType.Bit32).float(message.aura_start_time);
		/* optional float aura_end_time = 6; */
		if (message.aura_end_time !== undefined) writer.tag(6, WireType.Bit32).float(message.aura_end_time);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMessage_AuraModifierApplied
 */
export const CCitadelUserMessage_AuraModifierApplied = new CCitadelUserMessage_AuraModifierApplied$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ObstructedShotFired$Type extends MessageType<CCitadelUserMsg_ObstructedShotFired> {
	constructor() {
		super("CCitadelUserMsg_ObstructedShotFired", []);
	}
	create(value?: PartialMessage<CCitadelUserMsg_ObstructedShotFired>): CCitadelUserMsg_ObstructedShotFired {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_ObstructedShotFired>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_ObstructedShotFired,
	): CCitadelUserMsg_ObstructedShotFired {
		return target ?? this.create();
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_ObstructedShotFired,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ObstructedShotFired
 */
export const CCitadelUserMsg_ObstructedShotFired = new CCitadelUserMsg_ObstructedShotFired$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_PostProcessingAnim$Type extends MessageType<CCitadelUserMsg_PostProcessingAnim> {
	constructor() {
		super("CCitadelUserMsg_PostProcessingAnim", [
			{
				no: 1,
				name: "entindex_owner",
				kind: "scalar",
				localName: "entindex_owner",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "clear_all_states",
				kind: "scalar",
				localName: "clear_all_states",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 3,
				name: "state",
				kind: "enum",
				opt: true,
				T: () => ["PostProcessingGameStates", PostProcessingGameStates],
			},
			{
				no: 4,
				name: "start_time",
				kind: "scalar",
				localName: "start_time",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 5,
				name: "fade_in_time",
				kind: "scalar",
				localName: "fade_in_time",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 6,
				name: "hold_time",
				kind: "scalar",
				localName: "hold_time",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 7,
				name: "fade_out_time",
				kind: "scalar",
				localName: "fade_out_time",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 8,
				name: "scale",
				kind: "scalar",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_PostProcessingAnim>): CCitadelUserMsg_PostProcessingAnim {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_PostProcessingAnim>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_PostProcessingAnim,
	): CCitadelUserMsg_PostProcessingAnim {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 entindex_owner */ 1:
					message.entindex_owner = reader.int32();
					break;
				case /* optional bool clear_all_states */ 2:
					message.clear_all_states = reader.bool();
					break;
				case /* optional PostProcessingGameStates state */ 3:
					message.state = reader.int32();
					break;
				case /* optional float start_time */ 4:
					message.start_time = reader.float();
					break;
				case /* optional float fade_in_time */ 5:
					message.fade_in_time = reader.float();
					break;
				case /* optional float hold_time */ 6:
					message.hold_time = reader.float();
					break;
				case /* optional float fade_out_time */ 7:
					message.fade_out_time = reader.float();
					break;
				case /* optional float scale */ 8:
					message.scale = reader.float();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_PostProcessingAnim,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 entindex_owner = 1; */
		if (message.entindex_owner !== undefined) writer.tag(1, WireType.Varint).int32(message.entindex_owner);
		/* optional bool clear_all_states = 2; */
		if (message.clear_all_states !== undefined) writer.tag(2, WireType.Varint).bool(message.clear_all_states);
		/* optional PostProcessingGameStates state = 3; */
		if (message.state !== undefined) writer.tag(3, WireType.Varint).int32(message.state);
		/* optional float start_time = 4; */
		if (message.start_time !== undefined) writer.tag(4, WireType.Bit32).float(message.start_time);
		/* optional float fade_in_time = 5; */
		if (message.fade_in_time !== undefined) writer.tag(5, WireType.Bit32).float(message.fade_in_time);
		/* optional float hold_time = 6; */
		if (message.hold_time !== undefined) writer.tag(6, WireType.Bit32).float(message.hold_time);
		/* optional float fade_out_time = 7; */
		if (message.fade_out_time !== undefined) writer.tag(7, WireType.Bit32).float(message.fade_out_time);
		/* optional float scale = 8; */
		if (message.scale !== undefined) writer.tag(8, WireType.Bit32).float(message.scale);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_PostProcessingAnim
 */
export const CCitadelUserMsg_PostProcessingAnim = new CCitadelUserMsg_PostProcessingAnim$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_DeathReplayData$Type extends MessageType<CCitadelUserMsg_DeathReplayData> {
	constructor() {
		super("CCitadelUserMsg_DeathReplayData", [
			{
				no: 1,
				name: "killer_scorer",
				kind: "scalar",
				localName: "killer_scorer",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "killer_inflictor",
				kind: "scalar",
				localName: "killer_inflictor",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "damage_summary",
				kind: "message",
				localName: "damage_summary",
				T: () => CCitadelUserMsg_RecentDamageSummary,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_DeathReplayData>): CCitadelUserMsg_DeathReplayData {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_DeathReplayData>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_DeathReplayData,
	): CCitadelUserMsg_DeathReplayData {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 killer_scorer */ 1:
					message.killer_scorer = reader.int32();
					break;
				case /* optional int32 killer_inflictor */ 2:
					message.killer_inflictor = reader.int32();
					break;
				case /* optional CCitadelUserMsg_RecentDamageSummary damage_summary */ 3:
					message.damage_summary = CCitadelUserMsg_RecentDamageSummary.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.damage_summary,
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_DeathReplayData,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 killer_scorer = 1; */
		if (message.killer_scorer !== undefined) writer.tag(1, WireType.Varint).int32(message.killer_scorer);
		/* optional int32 killer_inflictor = 2; */
		if (message.killer_inflictor !== undefined) writer.tag(2, WireType.Varint).int32(message.killer_inflictor);
		/* optional CCitadelUserMsg_RecentDamageSummary damage_summary = 3; */
		if (message.damage_summary)
			CCitadelUserMsg_RecentDamageSummary.internalBinaryWrite(
				message.damage_summary,
				writer.tag(3, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_DeathReplayData
 */
export const CCitadelUserMsg_DeathReplayData = new CCitadelUserMsg_DeathReplayData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ForceShopClosed$Type extends MessageType<CCitadelUserMsg_ForceShopClosed> {
	constructor() {
		super("CCitadelUserMsg_ForceShopClosed", []);
	}
	create(value?: PartialMessage<CCitadelUserMsg_ForceShopClosed>): CCitadelUserMsg_ForceShopClosed {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_ForceShopClosed>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_ForceShopClosed,
	): CCitadelUserMsg_ForceShopClosed {
		return target ?? this.create();
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_ForceShopClosed,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ForceShopClosed
 */
export const CCitadelUserMsg_ForceShopClosed = new CCitadelUserMsg_ForceShopClosed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_PlayerLifetimeStatInfo$Type extends MessageType<CCitadelUserMsg_PlayerLifetimeStatInfo> {
	constructor() {
		super("CCitadelUserMsg_PlayerLifetimeStatInfo", [
			{
				no: 1,
				name: "stats",
				kind: "message",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CCitadelUserMsg_PlayerLifetimeStatInfo_Stat,
			},
			{
				no: 2,
				name: "match_id",
				kind: "scalar",
				localName: "match_id",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 3,
				name: "end_of_match",
				kind: "scalar",
				localName: "end_of_match",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 4,
				name: "is_official_match",
				kind: "scalar",
				localName: "is_official_match",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_PlayerLifetimeStatInfo>): CCitadelUserMsg_PlayerLifetimeStatInfo {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.stats = [];
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_PlayerLifetimeStatInfo>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_PlayerLifetimeStatInfo,
	): CCitadelUserMsg_PlayerLifetimeStatInfo {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated CCitadelUserMsg_PlayerLifetimeStatInfo.Stat stats */ 1:
					message.stats.push(
						CCitadelUserMsg_PlayerLifetimeStatInfo_Stat.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				case /* optional uint64 match_id */ 2:
					message.match_id = reader.uint64().toBigInt();
					break;
				case /* optional bool end_of_match */ 3:
					message.end_of_match = reader.bool();
					break;
				case /* optional bool is_official_match */ 4:
					message.is_official_match = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_PlayerLifetimeStatInfo,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated CCitadelUserMsg_PlayerLifetimeStatInfo.Stat stats = 1; */
		for (let i = 0; i < message.stats.length; i++)
			CCitadelUserMsg_PlayerLifetimeStatInfo_Stat.internalBinaryWrite(
				message.stats[i],
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional uint64 match_id = 2; */
		if (message.match_id !== undefined) writer.tag(2, WireType.Varint).uint64(message.match_id);
		/* optional bool end_of_match = 3; */
		if (message.end_of_match !== undefined) writer.tag(3, WireType.Varint).bool(message.end_of_match);
		/* optional bool is_official_match = 4; */
		if (message.is_official_match !== undefined) writer.tag(4, WireType.Varint).bool(message.is_official_match);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_PlayerLifetimeStatInfo
 */
export const CCitadelUserMsg_PlayerLifetimeStatInfo = new CCitadelUserMsg_PlayerLifetimeStatInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_PlayerLifetimeStatInfo_Stat$Type extends MessageType<CCitadelUserMsg_PlayerLifetimeStatInfo_Stat> {
	constructor() {
		super("CCitadelUserMsg_PlayerLifetimeStatInfo.Stat", [
			{
				no: 1,
				name: "stat_name",
				kind: "scalar",
				localName: "stat_name",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 2,
				name: "match_total",
				kind: "scalar",
				localName: "match_total",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "lifetime_value",
				kind: "scalar",
				localName: "lifetime_value",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 4,
				name: "priority",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 5,
				name: "prev_lifetime_max",
				kind: "scalar",
				localName: "prev_lifetime_max",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 6,
				name: "stat_type",
				kind: "scalar",
				localName: "stat_type",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 7,
				name: "stat_type_id",
				kind: "scalar",
				localName: "stat_type_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CCitadelUserMsg_PlayerLifetimeStatInfo_Stat>,
	): CCitadelUserMsg_PlayerLifetimeStatInfo_Stat {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_PlayerLifetimeStatInfo_Stat>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_PlayerLifetimeStatInfo_Stat,
	): CCitadelUserMsg_PlayerLifetimeStatInfo_Stat {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional string stat_name */ 1:
					message.stat_name = reader.string();
					break;
				case /* optional uint32 match_total */ 2:
					message.match_total = reader.uint32();
					break;
				case /* optional uint32 lifetime_value */ 3:
					message.lifetime_value = reader.uint32();
					break;
				case /* optional uint32 priority */ 4:
					message.priority = reader.uint32();
					break;
				case /* optional uint32 prev_lifetime_max */ 5:
					message.prev_lifetime_max = reader.uint32();
					break;
				case /* optional uint32 stat_type */ 6:
					message.stat_type = reader.uint32();
					break;
				case /* optional uint32 stat_type_id */ 7:
					message.stat_type_id = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_PlayerLifetimeStatInfo_Stat,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional string stat_name = 1; */
		if (message.stat_name !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.stat_name);
		/* optional uint32 match_total = 2; */
		if (message.match_total !== undefined) writer.tag(2, WireType.Varint).uint32(message.match_total);
		/* optional uint32 lifetime_value = 3; */
		if (message.lifetime_value !== undefined) writer.tag(3, WireType.Varint).uint32(message.lifetime_value);
		/* optional uint32 priority = 4; */
		if (message.priority !== undefined) writer.tag(4, WireType.Varint).uint32(message.priority);
		/* optional uint32 prev_lifetime_max = 5; */
		if (message.prev_lifetime_max !== undefined) writer.tag(5, WireType.Varint).uint32(message.prev_lifetime_max);
		/* optional uint32 stat_type = 6; */
		if (message.stat_type !== undefined) writer.tag(6, WireType.Varint).uint32(message.stat_type);
		/* optional uint32 stat_type_id = 7; */
		if (message.stat_type_id !== undefined) writer.tag(7, WireType.Varint).uint32(message.stat_type_id);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_PlayerLifetimeStatInfo.Stat
 */
export const CCitadelUserMsg_PlayerLifetimeStatInfo_Stat = new CCitadelUserMsg_PlayerLifetimeStatInfo_Stat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_StaminaDrained$Type extends MessageType<CCitadelUserMsg_StaminaDrained> {
	constructor() {
		super("CCitadelUserMsg_StaminaDrained", [
			{
				no: 1,
				name: "entindex_victim",
				kind: "scalar",
				localName: "entindex_victim",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "stamina_drained",
				kind: "scalar",
				localName: "stamina_drained",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_StaminaDrained>): CCitadelUserMsg_StaminaDrained {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_StaminaDrained>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_StaminaDrained,
	): CCitadelUserMsg_StaminaDrained {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 entindex_victim */ 1:
					message.entindex_victim = reader.int32();
					break;
				case /* optional int32 stamina_drained */ 2:
					message.stamina_drained = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_StaminaDrained,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 entindex_victim = 1; */
		if (message.entindex_victim !== undefined) writer.tag(1, WireType.Varint).int32(message.entindex_victim);
		/* optional int32 stamina_drained = 2; */
		if (message.stamina_drained !== undefined) writer.tag(2, WireType.Varint).int32(message.stamina_drained);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_StaminaDrained
 */
export const CCitadelUserMsg_StaminaDrained = new CCitadelUserMsg_StaminaDrained$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMessage_AbilityNotify$Type extends MessageType<CCitadelUserMessage_AbilityNotify> {
	constructor() {
		super("CCitadelUserMessage_AbilityNotify", [
			{
				no: 1,
				name: "entindex_victim",
				kind: "scalar",
				localName: "entindex_victim",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "entindex_attacker",
				kind: "scalar",
				localName: "entindex_attacker",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "ability_id",
				kind: "scalar",
				localName: "ability_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMessage_AbilityNotify>): CCitadelUserMessage_AbilityNotify {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMessage_AbilityNotify>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMessage_AbilityNotify,
	): CCitadelUserMessage_AbilityNotify {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 entindex_victim */ 1:
					message.entindex_victim = reader.int32();
					break;
				case /* optional int32 entindex_attacker */ 2:
					message.entindex_attacker = reader.int32();
					break;
				case /* optional uint32 ability_id */ 3:
					message.ability_id = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMessage_AbilityNotify,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 entindex_victim = 1; */
		if (message.entindex_victim !== undefined) writer.tag(1, WireType.Varint).int32(message.entindex_victim);
		/* optional int32 entindex_attacker = 2; */
		if (message.entindex_attacker !== undefined) writer.tag(2, WireType.Varint).int32(message.entindex_attacker);
		/* optional uint32 ability_id = 3; */
		if (message.ability_id !== undefined) writer.tag(3, WireType.Varint).uint32(message.ability_id);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMessage_AbilityNotify
 */
export const CCitadelUserMessage_AbilityNotify = new CCitadelUserMessage_AbilityNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMessage_CurrencyChanged$Type extends MessageType<CCitadelUserMessage_CurrencyChanged> {
	constructor() {
		super("CCitadelUserMessage_CurrencyChanged", [
			{
				no: 1,
				name: "entindex_hero_pawn",
				kind: "scalar",
				localName: "entindex_hero_pawn",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "currency_type",
				kind: "scalar",
				localName: "currency_type",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "currency_source",
				kind: "scalar",
				localName: "currency_source",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 4,
				name: "delta",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 5,
				name: "notification",
				kind: "scalar",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 6,
				name: "entindex_victim",
				kind: "scalar",
				localName: "entindex_victim",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 7,
				name: "victim_pos",
				kind: "message",
				localName: "victim_pos",
				T: () => CMsgVector,
			},
			{
				no: 8,
				name: "playsound",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 9,
				name: "ability_id",
				kind: "scalar",
				localName: "ability_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMessage_CurrencyChanged>): CCitadelUserMessage_CurrencyChanged {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMessage_CurrencyChanged>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMessage_CurrencyChanged,
	): CCitadelUserMessage_CurrencyChanged {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 entindex_hero_pawn */ 1:
					message.entindex_hero_pawn = reader.int32();
					break;
				case /* optional int32 currency_type */ 2:
					message.currency_type = reader.int32();
					break;
				case /* optional int32 currency_source */ 3:
					message.currency_source = reader.int32();
					break;
				case /* optional int32 delta */ 4:
					message.delta = reader.int32();
					break;
				case /* optional bool notification */ 5:
					message.notification = reader.bool();
					break;
				case /* optional int32 entindex_victim */ 6:
					message.entindex_victim = reader.int32();
					break;
				case /* optional CMsgVector victim_pos */ 7:
					message.victim_pos = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.victim_pos);
					break;
				case /* optional int32 playsound */ 8:
					message.playsound = reader.int32();
					break;
				case /* optional uint32 ability_id */ 9:
					message.ability_id = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMessage_CurrencyChanged,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 entindex_hero_pawn = 1; */
		if (message.entindex_hero_pawn !== undefined) writer.tag(1, WireType.Varint).int32(message.entindex_hero_pawn);
		/* optional int32 currency_type = 2; */
		if (message.currency_type !== undefined) writer.tag(2, WireType.Varint).int32(message.currency_type);
		/* optional int32 currency_source = 3; */
		if (message.currency_source !== undefined) writer.tag(3, WireType.Varint).int32(message.currency_source);
		/* optional int32 delta = 4; */
		if (message.delta !== undefined) writer.tag(4, WireType.Varint).int32(message.delta);
		/* optional bool notification = 5; */
		if (message.notification !== undefined) writer.tag(5, WireType.Varint).bool(message.notification);
		/* optional int32 entindex_victim = 6; */
		if (message.entindex_victim !== undefined) writer.tag(6, WireType.Varint).int32(message.entindex_victim);
		/* optional CMsgVector victim_pos = 7; */
		if (message.victim_pos)
			CMsgVector.internalBinaryWrite(
				message.victim_pos,
				writer.tag(7, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional int32 playsound = 8; */
		if (message.playsound !== undefined) writer.tag(8, WireType.Varint).int32(message.playsound);
		/* optional uint32 ability_id = 9; */
		if (message.ability_id !== undefined) writer.tag(9, WireType.Varint).uint32(message.ability_id);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMessage_CurrencyChanged
 */
export const CCitadelUserMessage_CurrencyChanged = new CCitadelUserMessage_CurrencyChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMessage_GameOver$Type extends MessageType<CCitadelUserMessage_GameOver> {
	constructor() {
		super("CCitadelUserMessage_GameOver", [
			{
				no: 1,
				name: "winning_team",
				kind: "scalar",
				localName: "winning_team",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "just_a_test",
				kind: "scalar",
				localName: "just_a_test",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMessage_GameOver>): CCitadelUserMessage_GameOver {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMessage_GameOver>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMessage_GameOver,
	): CCitadelUserMessage_GameOver {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 winning_team */ 1:
					message.winning_team = reader.int32();
					break;
				case /* optional bool just_a_test */ 2:
					message.just_a_test = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMessage_GameOver,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 winning_team = 1; */
		if (message.winning_team !== undefined) writer.tag(1, WireType.Varint).int32(message.winning_team);
		/* optional bool just_a_test = 2; */
		if (message.just_a_test !== undefined) writer.tag(2, WireType.Varint).bool(message.just_a_test);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMessage_GameOver
 */
export const CCitadelUserMessage_GameOver = new CCitadelUserMessage_GameOver$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_GetDamageStatsResponse$Type extends MessageType<CCitadelUserMsg_GetDamageStatsResponse> {
	constructor() {
		super("CCitadelUserMsg_GetDamageStatsResponse", [
			{
				no: 1,
				name: "player_slot",
				kind: "scalar",
				localName: "player_slot",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "ability_name",
				kind: "scalar",
				localName: "ability_name",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 3,
				name: "damage",
				kind: "message",
				T: () => CCitadelUserMsg_GetDamageStatsResponse_StatType,
			},
			{
				no: 4,
				name: "healing",
				kind: "message",
				T: () => CCitadelUserMsg_GetDamageStatsResponse_StatType,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_GetDamageStatsResponse>): CCitadelUserMsg_GetDamageStatsResponse {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_GetDamageStatsResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_GetDamageStatsResponse,
	): CCitadelUserMsg_GetDamageStatsResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 player_slot */ 1:
					message.player_slot = reader.uint32();
					break;
				case /* optional string ability_name */ 2:
					message.ability_name = reader.string();
					break;
				case /* optional CCitadelUserMsg_GetDamageStatsResponse.StatType damage */ 3:
					message.damage = CCitadelUserMsg_GetDamageStatsResponse_StatType.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.damage,
					);
					break;
				case /* optional CCitadelUserMsg_GetDamageStatsResponse.StatType healing */ 4:
					message.healing = CCitadelUserMsg_GetDamageStatsResponse_StatType.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.healing,
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_GetDamageStatsResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 player_slot = 1; */
		if (message.player_slot !== undefined) writer.tag(1, WireType.Varint).uint32(message.player_slot);
		/* optional string ability_name = 2; */
		if (message.ability_name !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.ability_name);
		/* optional CCitadelUserMsg_GetDamageStatsResponse.StatType damage = 3; */
		if (message.damage)
			CCitadelUserMsg_GetDamageStatsResponse_StatType.internalBinaryWrite(
				message.damage,
				writer.tag(3, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CCitadelUserMsg_GetDamageStatsResponse.StatType healing = 4; */
		if (message.healing)
			CCitadelUserMsg_GetDamageStatsResponse_StatType.internalBinaryWrite(
				message.healing,
				writer.tag(4, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_GetDamageStatsResponse
 */
export const CCitadelUserMsg_GetDamageStatsResponse = new CCitadelUserMsg_GetDamageStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_GetDamageStatsResponse_StatType$Type extends MessageType<CCitadelUserMsg_GetDamageStatsResponse_StatType> {
	constructor() {
		super("CCitadelUserMsg_GetDamageStatsResponse.StatType", [
			{
				no: 1,
				name: "target_player_slot",
				kind: "scalar",
				localName: "target_player_slot",
				repeat: 1 /*RepeatType.PACKED*/,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "value",
				kind: "scalar",
				repeat: 1 /*RepeatType.PACKED*/,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CCitadelUserMsg_GetDamageStatsResponse_StatType>,
	): CCitadelUserMsg_GetDamageStatsResponse_StatType {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.target_player_slot = [];
		message.value = [];
		if (value !== undefined)
			reflectionMergePartial<CCitadelUserMsg_GetDamageStatsResponse_StatType>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_GetDamageStatsResponse_StatType,
	): CCitadelUserMsg_GetDamageStatsResponse_StatType {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated uint32 target_player_slot = 1 [packed = true];*/ 1:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; )
							message.target_player_slot.push(reader.uint32());
					else message.target_player_slot.push(reader.uint32());
					break;
				case /* repeated uint32 value = 2 [packed = true];*/ 2:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.value.push(reader.uint32());
					else message.value.push(reader.uint32());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_GetDamageStatsResponse_StatType,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated uint32 target_player_slot = 1 [packed = true]; */
		if (message.target_player_slot.length) {
			writer.tag(1, WireType.LengthDelimited).fork();
			for (let i = 0; i < message.target_player_slot.length; i++) writer.uint32(message.target_player_slot[i]);
			writer.join();
		}
		/* repeated uint32 value = 2 [packed = true]; */
		if (message.value.length) {
			writer.tag(2, WireType.LengthDelimited).fork();
			for (let i = 0; i < message.value.length; i++) writer.uint32(message.value[i]);
			writer.join();
		}
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_GetDamageStatsResponse.StatType
 */
export const CCitadelUserMsg_GetDamageStatsResponse_StatType =
	new CCitadelUserMsg_GetDamageStatsResponse_StatType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ParticipantStartSoundEvent$Type extends MessageType<CCitadelUserMsg_ParticipantStartSoundEvent> {
	constructor() {
		super("CCitadelUserMsg_ParticipantStartSoundEvent", [
			{
				no: 1,
				name: "event",
				kind: "message",
				T: () => CMsgSosStartSoundEvent,
			},
			{
				no: 2,
				name: "player_slots",
				kind: "scalar",
				localName: "player_slots",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CCitadelUserMsg_ParticipantStartSoundEvent>,
	): CCitadelUserMsg_ParticipantStartSoundEvent {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.player_slots = [];
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_ParticipantStartSoundEvent>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_ParticipantStartSoundEvent,
	): CCitadelUserMsg_ParticipantStartSoundEvent {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* CMsgSosStartSoundEvent event */ 1:
					message.event = CMsgSosStartSoundEvent.internalBinaryRead(reader, reader.uint32(), options, message.event);
					break;
				case /* repeated int32 player_slots */ 2:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.player_slots.push(reader.int32());
					else message.player_slots.push(reader.int32());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_ParticipantStartSoundEvent,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* CMsgSosStartSoundEvent event = 1; */
		if (message.event)
			CMsgSosStartSoundEvent.internalBinaryWrite(
				message.event,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* repeated int32 player_slots = 2; */
		for (let i = 0; i < message.player_slots.length; i++) writer.tag(2, WireType.Varint).int32(message.player_slots[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ParticipantStartSoundEvent
 */
export const CCitadelUserMsg_ParticipantStartSoundEvent = new CCitadelUserMsg_ParticipantStartSoundEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ParticipantStopSoundEvent$Type extends MessageType<CCitadelUserMsg_ParticipantStopSoundEvent> {
	constructor() {
		super("CCitadelUserMsg_ParticipantStopSoundEvent", [
			{ no: 1, name: "event", kind: "message", T: () => CMsgSosStopSoundEvent },
			{
				no: 2,
				name: "player_slots",
				kind: "scalar",
				localName: "player_slots",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_ParticipantStopSoundEvent>): CCitadelUserMsg_ParticipantStopSoundEvent {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.player_slots = [];
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_ParticipantStopSoundEvent>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_ParticipantStopSoundEvent,
	): CCitadelUserMsg_ParticipantStopSoundEvent {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* CMsgSosStopSoundEvent event */ 1:
					message.event = CMsgSosStopSoundEvent.internalBinaryRead(reader, reader.uint32(), options, message.event);
					break;
				case /* repeated int32 player_slots */ 2:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.player_slots.push(reader.int32());
					else message.player_slots.push(reader.int32());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_ParticipantStopSoundEvent,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* CMsgSosStopSoundEvent event = 1; */
		if (message.event)
			CMsgSosStopSoundEvent.internalBinaryWrite(
				message.event,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* repeated int32 player_slots = 2; */
		for (let i = 0; i < message.player_slots.length; i++) writer.tag(2, WireType.Varint).int32(message.player_slots[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ParticipantStopSoundEvent
 */
export const CCitadelUserMsg_ParticipantStopSoundEvent = new CCitadelUserMsg_ParticipantStopSoundEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ParticipantStopSoundEventHash$Type extends MessageType<CCitadelUserMsg_ParticipantStopSoundEventHash> {
	constructor() {
		super("CCitadelUserMsg_ParticipantStopSoundEventHash", [
			{
				no: 1,
				name: "event",
				kind: "message",
				T: () => CMsgSosStopSoundEventHash,
			},
			{
				no: 2,
				name: "player_slots",
				kind: "scalar",
				localName: "player_slots",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CCitadelUserMsg_ParticipantStopSoundEventHash>,
	): CCitadelUserMsg_ParticipantStopSoundEventHash {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.player_slots = [];
		if (value !== undefined)
			reflectionMergePartial<CCitadelUserMsg_ParticipantStopSoundEventHash>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_ParticipantStopSoundEventHash,
	): CCitadelUserMsg_ParticipantStopSoundEventHash {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* CMsgSosStopSoundEventHash event */ 1:
					message.event = CMsgSosStopSoundEventHash.internalBinaryRead(reader, reader.uint32(), options, message.event);
					break;
				case /* repeated int32 player_slots */ 2:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.player_slots.push(reader.int32());
					else message.player_slots.push(reader.int32());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_ParticipantStopSoundEventHash,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* CMsgSosStopSoundEventHash event = 1; */
		if (message.event)
			CMsgSosStopSoundEventHash.internalBinaryWrite(
				message.event,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* repeated int32 player_slots = 2; */
		for (let i = 0; i < message.player_slots.length; i++) writer.tag(2, WireType.Varint).int32(message.player_slots[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ParticipantStopSoundEventHash
 */
export const CCitadelUserMsg_ParticipantStopSoundEventHash = new CCitadelUserMsg_ParticipantStopSoundEventHash$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ParticipantSetSoundEventParams$Type extends MessageType<CCitadelUserMsg_ParticipantSetSoundEventParams> {
	constructor() {
		super("CCitadelUserMsg_ParticipantSetSoundEventParams", [
			{
				no: 1,
				name: "event",
				kind: "message",
				T: () => CMsgSosSetSoundEventParams,
			},
			{
				no: 2,
				name: "player_slots",
				kind: "scalar",
				localName: "player_slots",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CCitadelUserMsg_ParticipantSetSoundEventParams>,
	): CCitadelUserMsg_ParticipantSetSoundEventParams {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.player_slots = [];
		if (value !== undefined)
			reflectionMergePartial<CCitadelUserMsg_ParticipantSetSoundEventParams>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_ParticipantSetSoundEventParams,
	): CCitadelUserMsg_ParticipantSetSoundEventParams {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* CMsgSosSetSoundEventParams event */ 1:
					message.event = CMsgSosSetSoundEventParams.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.event,
					);
					break;
				case /* repeated int32 player_slots */ 2:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.player_slots.push(reader.int32());
					else message.player_slots.push(reader.int32());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_ParticipantSetSoundEventParams,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* CMsgSosSetSoundEventParams event = 1; */
		if (message.event)
			CMsgSosSetSoundEventParams.internalBinaryWrite(
				message.event,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* repeated int32 player_slots = 2; */
		for (let i = 0; i < message.player_slots.length; i++) writer.tag(2, WireType.Varint).int32(message.player_slots[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ParticipantSetSoundEventParams
 */
export const CCitadelUserMsg_ParticipantSetSoundEventParams = new CCitadelUserMsg_ParticipantSetSoundEventParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ParticipantSetLibraryStackFields$Type extends MessageType<CCitadelUserMsg_ParticipantSetLibraryStackFields> {
	constructor() {
		super("CCitadelUserMsg_ParticipantSetLibraryStackFields", [
			{
				no: 1,
				name: "event",
				kind: "message",
				T: () => CMsgSosSetLibraryStackFields,
			},
			{
				no: 2,
				name: "player_slots",
				kind: "scalar",
				localName: "player_slots",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CCitadelUserMsg_ParticipantSetLibraryStackFields>,
	): CCitadelUserMsg_ParticipantSetLibraryStackFields {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.player_slots = [];
		if (value !== undefined)
			reflectionMergePartial<CCitadelUserMsg_ParticipantSetLibraryStackFields>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_ParticipantSetLibraryStackFields,
	): CCitadelUserMsg_ParticipantSetLibraryStackFields {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* CMsgSosSetLibraryStackFields event */ 1:
					message.event = CMsgSosSetLibraryStackFields.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.event,
					);
					break;
				case /* repeated int32 player_slots */ 2:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.player_slots.push(reader.int32());
					else message.player_slots.push(reader.int32());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_ParticipantSetLibraryStackFields,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* CMsgSosSetLibraryStackFields event = 1; */
		if (message.event)
			CMsgSosSetLibraryStackFields.internalBinaryWrite(
				message.event,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* repeated int32 player_slots = 2; */
		for (let i = 0; i < message.player_slots.length; i++) writer.tag(2, WireType.Varint).int32(message.player_slots[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ParticipantSetLibraryStackFields
 */
export const CCitadelUserMsg_ParticipantSetLibraryStackFields =
	new CCitadelUserMsg_ParticipantSetLibraryStackFields$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_BossKilled$Type extends MessageType<CCitadelUserMsg_BossKilled> {
	constructor() {
		super("CCitadelUserMsg_BossKilled", [
			{
				no: 1,
				name: "objective_team",
				kind: "scalar",
				localName: "objective_team",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "objective_mask_change",
				kind: "scalar",
				localName: "objective_mask_change",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "entity_killed",
				kind: "scalar",
				localName: "entity_killed",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 4,
				name: "entity_killed_class",
				kind: "scalar",
				localName: "entity_killed_class",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 5,
				name: "entity_killer",
				kind: "scalar",
				localName: "entity_killer",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 6,
				name: "gametime",
				kind: "scalar",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 7,
				name: "bosses_remaining",
				kind: "scalar",
				localName: "bosses_remaining",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 8,
				name: "entity_position",
				kind: "message",
				localName: "entity_position",
				T: () => CMsgVector,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_BossKilled>): CCitadelUserMsg_BossKilled {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_BossKilled>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_BossKilled,
	): CCitadelUserMsg_BossKilled {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 objective_team */ 1:
					message.objective_team = reader.int32();
					break;
				case /* optional int32 objective_mask_change */ 2:
					message.objective_mask_change = reader.int32();
					break;
				case /* optional uint32 entity_killed */ 3:
					message.entity_killed = reader.uint32();
					break;
				case /* optional int32 entity_killed_class */ 4:
					message.entity_killed_class = reader.int32();
					break;
				case /* optional uint32 entity_killer */ 5:
					message.entity_killer = reader.uint32();
					break;
				case /* optional float gametime */ 6:
					message.gametime = reader.float();
					break;
				case /* optional int32 bosses_remaining */ 7:
					message.bosses_remaining = reader.int32();
					break;
				case /* optional CMsgVector entity_position */ 8:
					message.entity_position = CMsgVector.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.entity_position,
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_BossKilled,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 objective_team = 1; */
		if (message.objective_team !== undefined) writer.tag(1, WireType.Varint).int32(message.objective_team);
		/* optional int32 objective_mask_change = 2; */
		if (message.objective_mask_change !== undefined)
			writer.tag(2, WireType.Varint).int32(message.objective_mask_change);
		/* optional uint32 entity_killed = 3; */
		if (message.entity_killed !== undefined) writer.tag(3, WireType.Varint).uint32(message.entity_killed);
		/* optional int32 entity_killed_class = 4; */
		if (message.entity_killed_class !== undefined) writer.tag(4, WireType.Varint).int32(message.entity_killed_class);
		/* optional uint32 entity_killer = 5; */
		if (message.entity_killer !== undefined) writer.tag(5, WireType.Varint).uint32(message.entity_killer);
		/* optional float gametime = 6; */
		if (message.gametime !== undefined) writer.tag(6, WireType.Bit32).float(message.gametime);
		/* optional int32 bosses_remaining = 7; */
		if (message.bosses_remaining !== undefined) writer.tag(7, WireType.Varint).int32(message.bosses_remaining);
		/* optional CMsgVector entity_position = 8; */
		if (message.entity_position)
			CMsgVector.internalBinaryWrite(
				message.entity_position,
				writer.tag(8, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_BossKilled
 */
export const CCitadelUserMsg_BossKilled = new CCitadelUserMsg_BossKilled$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_BossDamaged$Type extends MessageType<CCitadelUserMsg_BossDamaged> {
	constructor() {
		super("CCitadelUserMsg_BossDamaged", [
			{
				no: 1,
				name: "objective_team",
				kind: "scalar",
				localName: "objective_team",
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "objective_id",
				kind: "scalar",
				localName: "objective_id",
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "entity_damaged",
				kind: "scalar",
				localName: "entity_damaged",
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_BossDamaged>): CCitadelUserMsg_BossDamaged {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.objective_team = 0;
		message.objective_id = 0;
		message.entity_damaged = 0;
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_BossDamaged>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_BossDamaged,
	): CCitadelUserMsg_BossDamaged {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* int32 objective_team */ 1:
					message.objective_team = reader.int32();
					break;
				case /* int32 objective_id */ 2:
					message.objective_id = reader.int32();
					break;
				case /* uint32 entity_damaged */ 3:
					message.entity_damaged = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_BossDamaged,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* int32 objective_team = 1; */
		if (message.objective_team !== 0) writer.tag(1, WireType.Varint).int32(message.objective_team);
		/* int32 objective_id = 2; */
		if (message.objective_id !== 0) writer.tag(2, WireType.Varint).int32(message.objective_id);
		/* uint32 entity_damaged = 3; */
		if (message.entity_damaged !== 0) writer.tag(3, WireType.Varint).uint32(message.entity_damaged);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_BossDamaged
 */
export const CCitadelUserMsg_BossDamaged = new CCitadelUserMsg_BossDamaged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_MidBossSpawned$Type extends MessageType<CCitadelUserMsg_MidBossSpawned> {
	constructor() {
		super("CCitadelUserMsg_MidBossSpawned", []);
	}
	create(value?: PartialMessage<CCitadelUserMsg_MidBossSpawned>): CCitadelUserMsg_MidBossSpawned {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_MidBossSpawned>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_MidBossSpawned,
	): CCitadelUserMsg_MidBossSpawned {
		return target ?? this.create();
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_MidBossSpawned,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_MidBossSpawned
 */
export const CCitadelUserMsg_MidBossSpawned = new CCitadelUserMsg_MidBossSpawned$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_RejuvStatus$Type extends MessageType<CCitadelUserMsg_RejuvStatus> {
	constructor() {
		super("CCitadelUserMsg_RejuvStatus", [
			{
				no: 1,
				name: "killing_team",
				kind: "scalar",
				localName: "killing_team",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "player_pawn",
				kind: "scalar",
				localName: "player_pawn",
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "user_team",
				kind: "scalar",
				localName: "user_team",
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 4,
				name: "event_type",
				kind: "scalar",
				localName: "event_type",
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_RejuvStatus>): CCitadelUserMsg_RejuvStatus {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.player_pawn = 0;
		message.user_team = 0;
		message.event_type = 0;
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_RejuvStatus>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_RejuvStatus,
	): CCitadelUserMsg_RejuvStatus {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 killing_team */ 1:
					message.killing_team = reader.int32();
					break;
				case /* uint32 player_pawn */ 2:
					message.player_pawn = reader.uint32();
					break;
				case /* int32 user_team */ 3:
					message.user_team = reader.int32();
					break;
				case /* int32 event_type */ 4:
					message.event_type = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_RejuvStatus,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 killing_team = 1; */
		if (message.killing_team !== undefined) writer.tag(1, WireType.Varint).int32(message.killing_team);
		/* uint32 player_pawn = 2; */
		if (message.player_pawn !== 0) writer.tag(2, WireType.Varint).uint32(message.player_pawn);
		/* int32 user_team = 3; */
		if (message.user_team !== 0) writer.tag(3, WireType.Varint).int32(message.user_team);
		/* int32 event_type = 4; */
		if (message.event_type !== 0) writer.tag(4, WireType.Varint).int32(message.event_type);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_RejuvStatus
 */
export const CCitadelUserMsg_RejuvStatus = new CCitadelUserMsg_RejuvStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_KillStreak$Type extends MessageType<CCitadelUserMsg_KillStreak> {
	constructor() {
		super("CCitadelUserMsg_KillStreak", [
			{
				no: 1,
				name: "player_pawn",
				kind: "scalar",
				localName: "player_pawn",
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "num_kills",
				kind: "scalar",
				localName: "num_kills",
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "is_first_blood",
				kind: "scalar",
				localName: "is_first_blood",
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_KillStreak>): CCitadelUserMsg_KillStreak {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.player_pawn = 0;
		message.num_kills = 0;
		message.is_first_blood = false;
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_KillStreak>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_KillStreak,
	): CCitadelUserMsg_KillStreak {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* uint32 player_pawn */ 1:
					message.player_pawn = reader.uint32();
					break;
				case /* int32 num_kills */ 2:
					message.num_kills = reader.int32();
					break;
				case /* bool is_first_blood */ 3:
					message.is_first_blood = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_KillStreak,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* uint32 player_pawn = 1; */
		if (message.player_pawn !== 0) writer.tag(1, WireType.Varint).uint32(message.player_pawn);
		/* int32 num_kills = 2; */
		if (message.num_kills !== 0) writer.tag(2, WireType.Varint).int32(message.num_kills);
		/* bool is_first_blood = 3; */
		if (message.is_first_blood !== false) writer.tag(3, WireType.Varint).bool(message.is_first_blood);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_KillStreak
 */
export const CCitadelUserMsg_KillStreak = new CCitadelUserMsg_KillStreak$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_TeamMsg$Type extends MessageType<CCitadelUserMsg_TeamMsg> {
	constructor() {
		super("CCitadelUserMsg_TeamMsg", [
			{
				no: 1,
				name: "event_type",
				kind: "scalar",
				localName: "event_type",
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "team_number",
				kind: "scalar",
				localName: "team_number",
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "lane_color",
				kind: "scalar",
				localName: "lane_color",
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 4,
				name: "player_controller",
				kind: "scalar",
				localName: "player_controller",
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_TeamMsg>): CCitadelUserMsg_TeamMsg {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.event_type = 0;
		message.team_number = 0;
		message.lane_color = 0;
		message.player_controller = 0;
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_TeamMsg>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_TeamMsg,
	): CCitadelUserMsg_TeamMsg {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* int32 event_type */ 1:
					message.event_type = reader.int32();
					break;
				case /* int32 team_number */ 2:
					message.team_number = reader.int32();
					break;
				case /* int32 lane_color */ 3:
					message.lane_color = reader.int32();
					break;
				case /* uint32 player_controller */ 4:
					message.player_controller = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_TeamMsg,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* int32 event_type = 1; */
		if (message.event_type !== 0) writer.tag(1, WireType.Varint).int32(message.event_type);
		/* int32 team_number = 2; */
		if (message.team_number !== 0) writer.tag(2, WireType.Varint).int32(message.team_number);
		/* int32 lane_color = 3; */
		if (message.lane_color !== 0) writer.tag(3, WireType.Varint).int32(message.lane_color);
		/* uint32 player_controller = 4; */
		if (message.player_controller !== 0) writer.tag(4, WireType.Varint).uint32(message.player_controller);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_TeamMsg
 */
export const CCitadelUserMsg_TeamMsg = new CCitadelUserMsg_TeamMsg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_PlayerRespawned$Type extends MessageType<CCitadelUserMsg_PlayerRespawned> {
	constructor() {
		super("CCitadelUserMsg_PlayerRespawned", [
			{
				no: 1,
				name: "player_pawn",
				kind: "scalar",
				localName: "player_pawn",
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "facing_yaw",
				kind: "scalar",
				localName: "facing_yaw",
				T: 2 /*ScalarType.FLOAT*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_PlayerRespawned>): CCitadelUserMsg_PlayerRespawned {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.player_pawn = 0;
		message.facing_yaw = 0;
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_PlayerRespawned>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_PlayerRespawned,
	): CCitadelUserMsg_PlayerRespawned {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* uint32 player_pawn */ 1:
					message.player_pawn = reader.uint32();
					break;
				case /* float facing_yaw */ 2:
					message.facing_yaw = reader.float();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_PlayerRespawned,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* uint32 player_pawn = 1; */
		if (message.player_pawn !== 0) writer.tag(1, WireType.Varint).uint32(message.player_pawn);
		/* float facing_yaw = 2; */
		if (message.facing_yaw !== 0) writer.tag(2, WireType.Bit32).float(message.facing_yaw);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_PlayerRespawned
 */
export const CCitadelUserMsg_PlayerRespawned = new CCitadelUserMsg_PlayerRespawned$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_CallCheaterVote$Type extends MessageType<CCitadelUserMsg_CallCheaterVote> {
	constructor() {
		super("CCitadelUserMsg_CallCheaterVote", [
			{
				no: 1,
				name: "player_slot",
				kind: "scalar",
				localName: "player_slot",
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CCitadelUserMsg_CallCheaterVote>): CCitadelUserMsg_CallCheaterVote {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.player_slot = 0;
		if (value !== undefined) reflectionMergePartial<CCitadelUserMsg_CallCheaterVote>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CCitadelUserMsg_CallCheaterVote,
	): CCitadelUserMsg_CallCheaterVote {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* int32 player_slot */ 1:
					message.player_slot = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CCitadelUserMsg_CallCheaterVote,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* int32 player_slot = 1; */
		if (message.player_slot !== 0) writer.tag(1, WireType.Varint).int32(message.player_slot);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_CallCheaterVote
 */
export const CCitadelUserMsg_CallCheaterVote = new CCitadelUserMsg_CallCheaterVote$Type();

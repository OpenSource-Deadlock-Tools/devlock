// @generated by protobuf-ts 2.9.4 with parameter use_proto_field_name
// @generated from protobuf file "steammessages_int.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message CMsgWebAPIKey
 */
export interface CMsgWebAPIKey {
	/**
	 * @generated from protobuf field: optional uint32 status = 1;
	 */
	status?: number;
	/**
	 * @generated from protobuf field: optional uint32 account_id = 2;
	 */
	account_id?: number;
	/**
	 * @generated from protobuf field: optional uint32 publisher_group_id = 3;
	 */
	publisher_group_id?: number;
	/**
	 * @generated from protobuf field: optional uint32 key_id = 4;
	 */
	key_id?: number;
	/**
	 * @generated from protobuf field: optional string domain = 5;
	 */
	domain?: string;
}
/**
 * @generated from protobuf message CMsgHttpRequest
 */
export interface CMsgHttpRequest {
	/**
	 * @generated from protobuf field: optional uint32 request_method = 1;
	 */
	request_method?: number;
	/**
	 * @generated from protobuf field: optional string hostname = 2;
	 */
	hostname?: string;
	/**
	 * @generated from protobuf field: optional string url = 3;
	 */
	url?: string;
	/**
	 * @generated from protobuf field: repeated CMsgHttpRequest.RequestHeader headers = 4;
	 */
	headers: CMsgHttpRequest_RequestHeader[];
	/**
	 * @generated from protobuf field: repeated CMsgHttpRequest.QueryParam get_params = 5;
	 */
	get_params: CMsgHttpRequest_QueryParam[];
	/**
	 * @generated from protobuf field: repeated CMsgHttpRequest.QueryParam post_params = 6;
	 */
	post_params: CMsgHttpRequest_QueryParam[];
	/**
	 * @generated from protobuf field: optional bytes body = 7;
	 */
	body?: Uint8Array;
	/**
	 * @generated from protobuf field: optional uint32 absolute_timeout = 8;
	 */
	absolute_timeout?: number;
	/**
	 * @generated from protobuf field: optional bool use_https = 9;
	 */
	use_https?: boolean;
}
/**
 * @generated from protobuf message CMsgHttpRequest.RequestHeader
 */
export interface CMsgHttpRequest_RequestHeader {
	/**
	 * @generated from protobuf field: optional string name = 1;
	 */
	name?: string;
	/**
	 * @generated from protobuf field: optional string value = 2;
	 */
	value?: string;
}
/**
 * @generated from protobuf message CMsgHttpRequest.QueryParam
 */
export interface CMsgHttpRequest_QueryParam {
	/**
	 * @generated from protobuf field: optional string name = 1;
	 */
	name?: string;
	/**
	 * @generated from protobuf field: optional bytes value = 2;
	 */
	value?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgWebAPIRequest
 */
export interface CMsgWebAPIRequest {
	/**
	 * @generated from protobuf field: optional string interface_name = 2;
	 */
	interface_name?: string;
	/**
	 * @generated from protobuf field: optional string method_name = 3;
	 */
	method_name?: string;
	/**
	 * @generated from protobuf field: optional uint32 version = 4;
	 */
	version?: number;
	/**
	 * @generated from protobuf field: optional CMsgWebAPIKey api_key = 5;
	 */
	api_key?: CMsgWebAPIKey;
	/**
	 * @generated from protobuf field: optional CMsgHttpRequest request = 6;
	 */
	request?: CMsgHttpRequest;
	/**
	 * @generated from protobuf field: optional uint32 routing_app_id = 7;
	 */
	routing_app_id?: number;
}
/**
 * @generated from protobuf message CMsgHttpResponse
 */
export interface CMsgHttpResponse {
	/**
	 * @generated from protobuf field: optional uint32 status_code = 1;
	 */
	status_code?: number;
	/**
	 * @generated from protobuf field: repeated CMsgHttpResponse.ResponseHeader headers = 2;
	 */
	headers: CMsgHttpResponse_ResponseHeader[];
	/**
	 * @generated from protobuf field: optional bytes body = 3;
	 */
	body?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgHttpResponse.ResponseHeader
 */
export interface CMsgHttpResponse_ResponseHeader {
	/**
	 * @generated from protobuf field: optional string name = 1;
	 */
	name?: string;
	/**
	 * @generated from protobuf field: optional string value = 2;
	 */
	value?: string;
}
/**
 * @generated from protobuf message CMsgAMFindAccounts
 */
export interface CMsgAMFindAccounts {
	/**
	 * @generated from protobuf field: optional uint32 search_type = 1;
	 */
	search_type?: number;
	/**
	 * @generated from protobuf field: optional string search_string = 2;
	 */
	search_string?: string;
}
/**
 * @generated from protobuf message CMsgAMFindAccountsResponse
 */
export interface CMsgAMFindAccountsResponse {
	/**
	 * @generated from protobuf field: repeated fixed64 steam_id = 1;
	 */
	steam_id: bigint[];
}
/**
 * @generated from protobuf message CMsgNotifyWatchdog
 */
export interface CMsgNotifyWatchdog {
	/**
	 * @generated from protobuf field: optional uint32 source = 1;
	 */
	source?: number;
	/**
	 * @generated from protobuf field: optional uint32 alert_type = 2;
	 */
	alert_type?: number;
	/**
	 * @generated from protobuf field: optional bool critical = 4;
	 */
	critical?: boolean;
	/**
	 * @generated from protobuf field: optional uint32 time = 5;
	 */
	time?: number;
	/**
	 * @generated from protobuf field: optional uint32 appid = 6;
	 */
	appid?: number;
	/**
	 * @generated from protobuf field: optional string text = 7;
	 */
	text?: string;
	/**
	 * @generated from protobuf field: optional string recipient = 12;
	 */
	recipient?: string;
}
/**
 * @generated from protobuf message CMsgAMGetLicenses
 */
export interface CMsgAMGetLicenses {
	/**
	 * @generated from protobuf field: optional fixed64 steamid = 1;
	 */
	steamid?: bigint;
}
/**
 * @generated from protobuf message CMsgPackageLicense
 */
export interface CMsgPackageLicense {
	/**
	 * @generated from protobuf field: optional uint32 package_id = 1;
	 */
	package_id?: number;
	/**
	 * @generated from protobuf field: optional uint32 time_created = 2;
	 */
	time_created?: number;
	/**
	 * @generated from protobuf field: optional uint32 owner_id = 3;
	 */
	owner_id?: number;
}
/**
 * @generated from protobuf message CMsgAMGetLicensesResponse
 */
export interface CMsgAMGetLicensesResponse {
	/**
	 * @generated from protobuf field: repeated CMsgPackageLicense license = 1;
	 */
	license: CMsgPackageLicense[];
	/**
	 * @generated from protobuf field: optional uint32 result = 2;
	 */
	result?: number;
}
/**
 * @generated from protobuf message CMsgGCGetCommandList
 */
export interface CMsgGCGetCommandList {
	/**
	 * @generated from protobuf field: optional uint32 app_id = 1;
	 */
	app_id?: number;
	/**
	 * @generated from protobuf field: optional string command_prefix = 2;
	 */
	command_prefix?: string;
}
/**
 * @generated from protobuf message CMsgGCGetCommandListResponse
 */
export interface CMsgGCGetCommandListResponse {
	/**
	 * @generated from protobuf field: repeated string command_name = 1;
	 */
	command_name: string[];
}
/**
 * @generated from protobuf message CGCMsgMemCachedGet
 */
export interface CGCMsgMemCachedGet {
	/**
	 * @generated from protobuf field: repeated string keys = 1;
	 */
	keys: string[];
}
/**
 * @generated from protobuf message CGCMsgMemCachedGetResponse
 */
export interface CGCMsgMemCachedGetResponse {
	/**
	 * @generated from protobuf field: repeated CGCMsgMemCachedGetResponse.ValueTag values = 1;
	 */
	values: CGCMsgMemCachedGetResponse_ValueTag[];
}
/**
 * @generated from protobuf message CGCMsgMemCachedGetResponse.ValueTag
 */
export interface CGCMsgMemCachedGetResponse_ValueTag {
	/**
	 * @generated from protobuf field: optional bool found = 1;
	 */
	found?: boolean;
	/**
	 * @generated from protobuf field: optional bytes value = 2;
	 */
	value?: Uint8Array;
}
/**
 * @generated from protobuf message CGCMsgMemCachedSet
 */
export interface CGCMsgMemCachedSet {
	/**
	 * @generated from protobuf field: repeated CGCMsgMemCachedSet.KeyPair keys = 1;
	 */
	keys: CGCMsgMemCachedSet_KeyPair[];
}
/**
 * @generated from protobuf message CGCMsgMemCachedSet.KeyPair
 */
export interface CGCMsgMemCachedSet_KeyPair {
	/**
	 * @generated from protobuf field: optional string name = 1;
	 */
	name?: string;
	/**
	 * @generated from protobuf field: optional bytes value = 2;
	 */
	value?: Uint8Array;
}
/**
 * @generated from protobuf message CGCMsgMemCachedDelete
 */
export interface CGCMsgMemCachedDelete {
	/**
	 * @generated from protobuf field: repeated string keys = 1;
	 */
	keys: string[];
}
/**
 * @generated from protobuf message CGCMsgMemCachedStats
 */
export interface CGCMsgMemCachedStats {}
/**
 * @generated from protobuf message CGCMsgMemCachedStatsResponse
 */
export interface CGCMsgMemCachedStatsResponse {
	/**
	 * @generated from protobuf field: optional uint64 curr_connections = 1;
	 */
	curr_connections?: bigint;
	/**
	 * @generated from protobuf field: optional uint64 cmd_get = 2;
	 */
	cmd_get?: bigint;
	/**
	 * @generated from protobuf field: optional uint64 cmd_set = 3;
	 */
	cmd_set?: bigint;
	/**
	 * @generated from protobuf field: optional uint64 cmd_flush = 4;
	 */
	cmd_flush?: bigint;
	/**
	 * @generated from protobuf field: optional uint64 get_hits = 5;
	 */
	get_hits?: bigint;
	/**
	 * @generated from protobuf field: optional uint64 get_misses = 6;
	 */
	get_misses?: bigint;
	/**
	 * @generated from protobuf field: optional uint64 delete_hits = 7;
	 */
	delete_hits?: bigint;
	/**
	 * @generated from protobuf field: optional uint64 delete_misses = 8;
	 */
	delete_misses?: bigint;
	/**
	 * @generated from protobuf field: optional uint64 bytes_read = 9;
	 */
	bytes_read?: bigint;
	/**
	 * @generated from protobuf field: optional uint64 bytes_written = 10;
	 */
	bytes_written?: bigint;
	/**
	 * @generated from protobuf field: optional uint64 limit_maxbytes = 11;
	 */
	limit_maxbytes?: bigint;
	/**
	 * @generated from protobuf field: optional uint64 curr_items = 12;
	 */
	curr_items?: bigint;
	/**
	 * @generated from protobuf field: optional uint64 evictions = 13;
	 */
	evictions?: bigint;
	/**
	 * @generated from protobuf field: optional uint64 bytes = 14;
	 */
	bytes?: bigint;
}
/**
 * @generated from protobuf message CGCMsgSQLStats
 */
export interface CGCMsgSQLStats {
	/**
	 * @generated from protobuf field: optional uint32 schema_catalog = 1;
	 */
	schema_catalog?: number;
}
/**
 * @generated from protobuf message CGCMsgSQLStatsResponse
 */
export interface CGCMsgSQLStatsResponse {
	/**
	 * @generated from protobuf field: optional uint32 threads = 1;
	 */
	threads?: number;
	/**
	 * @generated from protobuf field: optional uint32 threads_connected = 2;
	 */
	threads_connected?: number;
	/**
	 * @generated from protobuf field: optional uint32 threads_active = 3;
	 */
	threads_active?: number;
	/**
	 * @generated from protobuf field: optional uint32 operations_submitted = 4;
	 */
	operations_submitted?: number;
	/**
	 * @generated from protobuf field: optional uint32 prepared_statements_executed = 5;
	 */
	prepared_statements_executed?: number;
	/**
	 * @generated from protobuf field: optional uint32 non_prepared_statements_executed = 6;
	 */
	non_prepared_statements_executed?: number;
	/**
	 * @generated from protobuf field: optional uint32 deadlock_retries = 7;
	 */
	deadlock_retries?: number;
	/**
	 * @generated from protobuf field: optional uint32 operations_timed_out_in_queue = 8;
	 */
	operations_timed_out_in_queue?: number;
	/**
	 * @generated from protobuf field: optional uint32 errors = 9;
	 */
	errors?: number;
}
/**
 * @generated from protobuf message CMsgAMAddFreeLicense
 */
export interface CMsgAMAddFreeLicense {
	/**
	 * @generated from protobuf field: optional fixed64 steamid = 1;
	 */
	steamid?: bigint;
	/**
	 * @generated from protobuf field: optional uint32 ip_public = 2;
	 */
	ip_public?: number;
	/**
	 * @generated from protobuf field: optional uint32 packageid = 3;
	 */
	packageid?: number;
	/**
	 * @generated from protobuf field: optional string store_country_code = 4;
	 */
	store_country_code?: string;
}
/**
 * @generated from protobuf message CMsgAMAddFreeLicenseResponse
 */
export interface CMsgAMAddFreeLicenseResponse {
	/**
	 * @generated from protobuf field: optional int32 eresult = 1;
	 */
	eresult?: number;
	/**
	 * @generated from protobuf field: optional int32 purchase_result_detail = 2;
	 */
	purchase_result_detail?: number;
	/**
	 * @generated from protobuf field: optional fixed64 transid = 3;
	 */
	transid?: bigint;
}
/**
 * @generated from protobuf message CGCMsgGetIPLocation
 */
export interface CGCMsgGetIPLocation {
	/**
	 * @generated from protobuf field: repeated fixed32 ips = 1;
	 */
	ips: number[];
}
/**
 * @generated from protobuf message CGCMsgGetIPASN
 */
export interface CGCMsgGetIPASN {
	/**
	 * @generated from protobuf field: repeated fixed32 ips = 1;
	 */
	ips: number[];
}
/**
 * @generated from protobuf message CIPASNInfo
 */
export interface CIPASNInfo {
	/**
	 * @generated from protobuf field: optional fixed32 ip = 1;
	 */
	ip?: number;
	/**
	 * @generated from protobuf field: optional uint32 asn = 2;
	 */
	asn?: number;
}
/**
 * @generated from protobuf message CGCMsgGetIPASNResponse
 */
export interface CGCMsgGetIPASNResponse {
	/**
	 * @generated from protobuf field: repeated CIPASNInfo infos = 1;
	 */
	infos: CIPASNInfo[];
}
/**
 * @generated from protobuf message CMsgAMSendEmail
 */
export interface CMsgAMSendEmail {
	/**
	 * @generated from protobuf field: optional fixed64 steamid = 1;
	 */
	steamid?: bigint;
	/**
	 * @generated from protobuf field: optional uint32 email_msg_type = 2;
	 */
	email_msg_type?: number;
	/**
	 * @generated from protobuf field: optional uint32 email_format = 3;
	 */
	email_format?: number;
	/**
	 * @generated from protobuf field: repeated CMsgAMSendEmail.PersonaNameReplacementToken persona_name_tokens = 5;
	 */
	persona_name_tokens: CMsgAMSendEmail_PersonaNameReplacementToken[];
	/**
	 * @generated from protobuf field: optional uint32 source_gc = 6;
	 */
	source_gc?: number;
	/**
	 * @generated from protobuf field: repeated CMsgAMSendEmail.ReplacementToken tokens = 7;
	 */
	tokens: CMsgAMSendEmail_ReplacementToken[];
}
/**
 * @generated from protobuf message CMsgAMSendEmail.ReplacementToken
 */
export interface CMsgAMSendEmail_ReplacementToken {
	/**
	 * @generated from protobuf field: optional string token_name = 1;
	 */
	token_name?: string;
	/**
	 * @generated from protobuf field: optional string token_value = 2;
	 */
	token_value?: string;
}
/**
 * @generated from protobuf message CMsgAMSendEmail.PersonaNameReplacementToken
 */
export interface CMsgAMSendEmail_PersonaNameReplacementToken {
	/**
	 * @generated from protobuf field: optional fixed64 steamid = 1;
	 */
	steamid?: bigint;
	/**
	 * @generated from protobuf field: optional string token_name = 2;
	 */
	token_name?: string;
}
/**
 * @generated from protobuf message CMsgAMSendEmailResponse
 */
export interface CMsgAMSendEmailResponse {
	/**
	 * @generated from protobuf field: optional uint32 eresult = 1;
	 */
	eresult?: number;
}
/**
 * @generated from protobuf message CMsgGCGetEmailTemplate
 */
export interface CMsgGCGetEmailTemplate {
	/**
	 * @generated from protobuf field: optional uint32 app_id = 1;
	 */
	app_id?: number;
	/**
	 * @generated from protobuf field: optional uint32 email_msg_type = 2;
	 */
	email_msg_type?: number;
	/**
	 * @generated from protobuf field: optional int32 email_lang = 3;
	 */
	email_lang?: number;
	/**
	 * @generated from protobuf field: optional int32 email_format = 4;
	 */
	email_format?: number;
}
/**
 * @generated from protobuf message CMsgGCGetEmailTemplateResponse
 */
export interface CMsgGCGetEmailTemplateResponse {
	/**
	 * @generated from protobuf field: optional uint32 eresult = 1;
	 */
	eresult?: number;
	/**
	 * @generated from protobuf field: optional bool template_exists = 2;
	 */
	template_exists?: boolean;
	/**
	 * @generated from protobuf field: optional string template = 3;
	 */
	template?: string;
}
/**
 * @generated from protobuf message CMsgAMGrantGuestPasses2
 */
export interface CMsgAMGrantGuestPasses2 {
	/**
	 * @generated from protobuf field: optional fixed64 steam_id = 1;
	 */
	steam_id?: bigint;
	/**
	 * @generated from protobuf field: optional uint32 package_id = 2;
	 */
	package_id?: number;
	/**
	 * @generated from protobuf field: optional int32 passes_to_grant = 3;
	 */
	passes_to_grant?: number;
	/**
	 * @generated from protobuf field: optional int32 days_to_expiration = 4;
	 */
	days_to_expiration?: number;
	/**
	 * @generated from protobuf field: optional int32 action = 5;
	 */
	action?: number;
}
/**
 * @generated from protobuf message CMsgAMGrantGuestPasses2Response
 */
export interface CMsgAMGrantGuestPasses2Response {
	/**
	 * @generated from protobuf field: optional int32 eresult = 1;
	 */
	eresult?: number;
	/**
	 * @generated from protobuf field: optional int32 passes_granted = 2;
	 */
	passes_granted?: number;
}
/**
 * @generated from protobuf message CMsgGCGetPersonaNames
 */
export interface CMsgGCGetPersonaNames {
	/**
	 * @generated from protobuf field: repeated fixed64 steamids = 1;
	 */
	steamids: bigint[];
}
/**
 * @generated from protobuf message CMsgGCGetPersonaNames_Response
 */
export interface CMsgGCGetPersonaNames_Response {
	/**
	 * @generated from protobuf field: repeated CMsgGCGetPersonaNames_Response.PersonaName succeeded_lookups = 1;
	 */
	succeeded_lookups: CMsgGCGetPersonaNames_Response_PersonaName[];
	/**
	 * @generated from protobuf field: repeated fixed64 failed_lookup_steamids = 2;
	 */
	failed_lookup_steamids: bigint[];
}
/**
 * @generated from protobuf message CMsgGCGetPersonaNames_Response.PersonaName
 */
export interface CMsgGCGetPersonaNames_Response_PersonaName {
	/**
	 * @generated from protobuf field: optional fixed64 steamid = 1;
	 */
	steamid?: bigint;
	/**
	 * @generated from protobuf field: optional string persona_name = 2;
	 */
	persona_name?: string;
}
/**
 * @generated from protobuf message CMsgGCCheckFriendship
 */
export interface CMsgGCCheckFriendship {
	/**
	 * @generated from protobuf field: optional fixed64 steamid_left = 1;
	 */
	steamid_left?: bigint;
	/**
	 * @generated from protobuf field: optional fixed64 steamid_right = 2;
	 */
	steamid_right?: bigint;
}
/**
 * @generated from protobuf message CMsgGCCheckFriendship_Response
 */
export interface CMsgGCCheckFriendship_Response {
	/**
	 * @generated from protobuf field: optional bool success = 1;
	 */
	success?: boolean;
	/**
	 * @generated from protobuf field: optional bool found_friendship = 2;
	 */
	found_friendship?: boolean;
}
/**
 * @generated from protobuf message CMsgGCGetAppFriendsList
 */
export interface CMsgGCGetAppFriendsList {
	/**
	 * @generated from protobuf field: optional fixed64 steamid = 1;
	 */
	steamid?: bigint;
	/**
	 * @generated from protobuf field: optional bool include_friendship_timestamps = 2;
	 */
	include_friendship_timestamps?: boolean;
	/**
	 * @generated from protobuf field: optional bool include_friends_with_no_play_time = 3;
	 */
	include_friends_with_no_play_time?: boolean;
}
/**
 * @generated from protobuf message CMsgGCGetAppFriendsList_Response
 */
export interface CMsgGCGetAppFriendsList_Response {
	/**
	 * @generated from protobuf field: optional bool success = 1;
	 */
	success?: boolean;
	/**
	 * @generated from protobuf field: repeated fixed64 steamids = 2;
	 */
	steamids: bigint[];
	/**
	 * @generated from protobuf field: repeated fixed32 friendship_timestamps = 3;
	 */
	friendship_timestamps: number[];
	/**
	 * @generated from protobuf field: repeated fixed32 last_playtimes = 4;
	 */
	last_playtimes: number[];
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetDirectory
 */
export interface CMsgGCMsgMasterSetDirectory {
	/**
	 * @generated from protobuf field: optional int32 master_dir_index = 1;
	 */
	master_dir_index?: number;
	/**
	 * @generated from protobuf field: repeated CMsgGCMsgMasterSetDirectory.SubGC dir = 2;
	 */
	dir: CMsgGCMsgMasterSetDirectory_SubGC[];
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetDirectory.SubGC
 */
export interface CMsgGCMsgMasterSetDirectory_SubGC {
	/**
	 * @generated from protobuf field: optional int32 dir_index = 1;
	 */
	dir_index?: number;
	/**
	 * @generated from protobuf field: optional string name = 2;
	 */
	name?: string;
	/**
	 * @generated from protobuf field: optional string box = 3;
	 */
	box?: string;
	/**
	 * @generated from protobuf field: optional string command_line = 4;
	 */
	command_line?: string;
	/**
	 * @generated from protobuf field: optional string gc_binary = 5;
	 */
	gc_binary?: string;
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetDirectory_Response
 */
export interface CMsgGCMsgMasterSetDirectory_Response {
	/**
	 * @generated from protobuf field: optional int32 eresult = 1;
	 */
	eresult?: number;
	/**
	 * @generated from protobuf field: optional string message = 2;
	 */
	message?: string;
}
/**
 * @generated from protobuf message CMsgGCMsgWebAPIJobRequestForwardResponse
 */
export interface CMsgGCMsgWebAPIJobRequestForwardResponse {
	/**
	 * @generated from protobuf field: optional int32 dir_index = 1;
	 */
	dir_index?: number;
}
/**
 * @generated from protobuf message CGCSystemMsg_GetPurchaseTrust_Request
 */
export interface CGCSystemMsg_GetPurchaseTrust_Request {
	/**
	 * @generated from protobuf field: optional fixed64 steamid = 1;
	 */
	steamid?: bigint;
}
/**
 * @generated from protobuf message CGCSystemMsg_GetPurchaseTrust_Response
 */
export interface CGCSystemMsg_GetPurchaseTrust_Response {
	/**
	 * @generated from protobuf field: optional bool has_prior_purchase_history = 1;
	 */
	has_prior_purchase_history?: boolean;
	/**
	 * @generated from protobuf field: optional bool has_no_recent_password_resets = 2;
	 */
	has_no_recent_password_resets?: boolean;
	/**
	 * @generated from protobuf field: optional bool is_wallet_cash_trusted = 3;
	 */
	is_wallet_cash_trusted?: boolean;
	/**
	 * @generated from protobuf field: optional uint32 time_all_trusted = 4;
	 */
	time_all_trusted?: number;
}
/**
 * @generated from protobuf message CMsgGCHAccountVacStatusChange
 */
export interface CMsgGCHAccountVacStatusChange {
	/**
	 * @generated from protobuf field: optional fixed64 steam_id = 1;
	 */
	steam_id?: bigint;
	/**
	 * @generated from protobuf field: optional uint32 app_id = 2;
	 */
	app_id?: number;
	/**
	 * @generated from protobuf field: optional uint32 rtime_vacban_starts = 3;
	 */
	rtime_vacban_starts?: number;
	/**
	 * @generated from protobuf field: optional bool is_banned_now = 4;
	 */
	is_banned_now?: boolean;
	/**
	 * @generated from protobuf field: optional bool is_banned_future = 5;
	 */
	is_banned_future?: boolean;
}
/**
 * @generated from protobuf message CMsgGCRoutingInfo
 */
export interface CMsgGCRoutingInfo {
	/**
	 * @generated from protobuf field: repeated int32 dir_index = 1;
	 */
	dir_index: number[];
	/**
	 * @generated from protobuf field: optional CMsgGCRoutingInfo.RoutingMethod method = 2;
	 */
	method?: CMsgGCRoutingInfo_RoutingMethod;
	/**
	 * @generated from protobuf field: optional CMsgGCRoutingInfo.RoutingMethod fallback = 3;
	 */
	fallback?: CMsgGCRoutingInfo_RoutingMethod;
	/**
	 * @generated from protobuf field: optional uint32 protobuf_field = 4;
	 */
	protobuf_field?: number;
	/**
	 * @generated from protobuf field: optional string webapi_param = 5;
	 */
	webapi_param?: string;
}
/**
 * @generated from protobuf enum CMsgGCRoutingInfo.RoutingMethod
 */
export enum CMsgGCRoutingInfo_RoutingMethod {
	/**
	 * @generated from protobuf enum value: RANDOM = 0;
	 */
	RANDOM = 0,
	/**
	 * @generated from protobuf enum value: DISCARD = 1;
	 */
	DISCARD = 1,
	/**
	 * @generated from protobuf enum value: CLIENT_STEAMID = 2;
	 */
	CLIENT_STEAMID = 2,
	/**
	 * @generated from protobuf enum value: PROTOBUF_FIELD_UINT64 = 3;
	 */
	PROTOBUF_FIELD_UINT64 = 3,
	/**
	 * @generated from protobuf enum value: WEBAPI_PARAM = 4;
	 */
	WEBAPI_PARAM = 4,
	/**
	 * @generated from protobuf enum value: WEBAPI_PARAM_STEAMID_ACCOUNTID = 5;
	 */
	WEBAPI_PARAM_STEAMID_ACCOUNTID = 5,
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetWebAPIRouting
 */
export interface CMsgGCMsgMasterSetWebAPIRouting {
	/**
	 * @generated from protobuf field: repeated CMsgGCMsgMasterSetWebAPIRouting.Entry entries = 1;
	 */
	entries: CMsgGCMsgMasterSetWebAPIRouting_Entry[];
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetWebAPIRouting.Entry
 */
export interface CMsgGCMsgMasterSetWebAPIRouting_Entry {
	/**
	 * @generated from protobuf field: optional string interface_name = 1;
	 */
	interface_name?: string;
	/**
	 * @generated from protobuf field: optional string method_name = 2;
	 */
	method_name?: string;
	/**
	 * @generated from protobuf field: optional CMsgGCRoutingInfo routing = 3;
	 */
	routing?: CMsgGCRoutingInfo;
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetClientMsgRouting
 */
export interface CMsgGCMsgMasterSetClientMsgRouting {
	/**
	 * @generated from protobuf field: repeated CMsgGCMsgMasterSetClientMsgRouting.Entry entries = 1;
	 */
	entries: CMsgGCMsgMasterSetClientMsgRouting_Entry[];
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetClientMsgRouting.Entry
 */
export interface CMsgGCMsgMasterSetClientMsgRouting_Entry {
	/**
	 * @generated from protobuf field: optional uint32 msg_type = 1;
	 */
	msg_type?: number;
	/**
	 * @generated from protobuf field: optional CMsgGCRoutingInfo routing = 2;
	 */
	routing?: CMsgGCRoutingInfo;
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetWebAPIRouting_Response
 */
export interface CMsgGCMsgMasterSetWebAPIRouting_Response {
	/**
	 * @generated from protobuf field: optional int32 eresult = 1;
	 */
	eresult?: number;
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetClientMsgRouting_Response
 */
export interface CMsgGCMsgMasterSetClientMsgRouting_Response {
	/**
	 * @generated from protobuf field: optional int32 eresult = 1;
	 */
	eresult?: number;
}
/**
 * @generated from protobuf message CMsgGCMsgSetOptions
 */
export interface CMsgGCMsgSetOptions {
	/**
	 * @generated from protobuf field: repeated CMsgGCMsgSetOptions.Option options = 1;
	 */
	options: CMsgGCMsgSetOptions_Option[];
	/**
	 * @generated from protobuf field: repeated CMsgGCMsgSetOptions.MessageRange client_msg_ranges = 2;
	 */
	client_msg_ranges: CMsgGCMsgSetOptions_MessageRange[];
	/**
	 * @generated from protobuf field: optional CMsgGCMsgSetOptions.GCSQLVersion gcsql_version = 3;
	 */
	gcsql_version?: CMsgGCMsgSetOptions_GCSQLVersion;
}
/**
 * @generated from protobuf message CMsgGCMsgSetOptions.MessageRange
 */
export interface CMsgGCMsgSetOptions_MessageRange {
	/**
	 * @generated from protobuf field: uint32 low = 1;
	 */
	low: number;
	/**
	 * @generated from protobuf field: uint32 high = 2;
	 */
	high: number;
}
/**
 * @generated from protobuf enum CMsgGCMsgSetOptions.Option
 */
export enum CMsgGCMsgSetOptions_Option {
	/**
	 * @generated from protobuf enum value: NOTIFY_USER_SESSIONS = 0;
	 */
	NOTIFY_USER_SESSIONS = 0,
	/**
	 * @generated from protobuf enum value: NOTIFY_SERVER_SESSIONS = 1;
	 */
	NOTIFY_SERVER_SESSIONS = 1,
	/**
	 * @generated from protobuf enum value: NOTIFY_ACHIEVEMENTS = 2;
	 */
	NOTIFY_ACHIEVEMENTS = 2,
	/**
	 * @generated from protobuf enum value: NOTIFY_VAC_ACTION = 3;
	 */
	NOTIFY_VAC_ACTION = 3,
}
/**
 * @generated from protobuf enum CMsgGCMsgSetOptions.GCSQLVersion
 */
export enum CMsgGCMsgSetOptions_GCSQLVersion {
	/**
	 * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
	 */
	UNSPECIFIED$ = 0,
	/**
	 * @generated from protobuf enum value: GCSQL_VERSION_BASELINE = 1;
	 */
	GCSQL_VERSION_BASELINE = 1,
	/**
	 * @generated from protobuf enum value: GCSQL_VERSION_BOOLTYPE = 2;
	 */
	GCSQL_VERSION_BOOLTYPE = 2,
}
/**
 * @generated from protobuf message CMsgGCHUpdateSession
 */
export interface CMsgGCHUpdateSession {
	/**
	 * @generated from protobuf field: optional fixed64 steam_id = 1;
	 */
	steam_id?: bigint;
	/**
	 * @generated from protobuf field: optional uint32 app_id = 2;
	 */
	app_id?: number;
	/**
	 * @generated from protobuf field: optional bool online = 3;
	 */
	online?: boolean;
	/**
	 * @generated from protobuf field: optional fixed64 server_steam_id = 4;
	 */
	server_steam_id?: bigint;
	/**
	 * @generated from protobuf field: optional uint32 server_addr = 5;
	 */
	server_addr?: number;
	/**
	 * @generated from protobuf field: optional uint32 server_port = 6;
	 */
	server_port?: number;
	/**
	 * @generated from protobuf field: optional uint32 os_type = 7;
	 */
	os_type?: number;
	/**
	 * @generated from protobuf field: optional uint32 client_addr = 8;
	 */
	client_addr?: number;
	/**
	 * @generated from protobuf field: repeated CMsgGCHUpdateSession.ExtraField extra_fields = 9;
	 */
	extra_fields: CMsgGCHUpdateSession_ExtraField[];
}
/**
 * @generated from protobuf message CMsgGCHUpdateSession.ExtraField
 */
export interface CMsgGCHUpdateSession_ExtraField {
	/**
	 * @generated from protobuf field: optional string name = 1;
	 */
	name?: string;
	/**
	 * @generated from protobuf field: optional string value = 2;
	 */
	value?: string;
}
/**
 * @generated from protobuf message CMsgNotificationOfSuspiciousActivity
 */
export interface CMsgNotificationOfSuspiciousActivity {
	/**
	 * @generated from protobuf field: optional fixed64 steamid = 1;
	 */
	steamid?: bigint;
	/**
	 * @generated from protobuf field: optional uint32 appid = 2;
	 */
	appid?: number;
	/**
	 * @generated from protobuf field: optional CMsgNotificationOfSuspiciousActivity.MultipleGameInstances multiple_instances = 3;
	 */
	multiple_instances?: CMsgNotificationOfSuspiciousActivity_MultipleGameInstances;
}
/**
 * @generated from protobuf message CMsgNotificationOfSuspiciousActivity.MultipleGameInstances
 */
export interface CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
	/**
	 * @generated from protobuf field: optional uint32 app_instance_count = 1;
	 */
	app_instance_count?: number;
	/**
	 * @generated from protobuf field: repeated fixed64 other_steamids = 2;
	 */
	other_steamids: bigint[];
}
/**
 * @generated from protobuf message CMsgGCHVacVerificationChange
 */
export interface CMsgGCHVacVerificationChange {
	/**
	 * @generated from protobuf field: optional fixed64 steamid = 1;
	 */
	steamid?: bigint;
	/**
	 * @generated from protobuf field: optional uint32 appid = 2;
	 */
	appid?: number;
	/**
	 * @generated from protobuf field: optional bool is_verified = 3;
	 */
	is_verified?: boolean;
}
/**
 * @generated from protobuf message CMsgGCCheckClanMembership
 */
export interface CMsgGCCheckClanMembership {
	/**
	 * @generated from protobuf field: optional fixed64 steamid = 1;
	 */
	steamid?: bigint;
	/**
	 * @generated from protobuf field: optional uint32 clanid = 2;
	 */
	clanid?: number;
}
/**
 * @generated from protobuf message CMsgGCCheckClanMembership_Response
 */
export interface CMsgGCCheckClanMembership_Response {
	/**
	 * @generated from protobuf field: optional bool ismember = 1;
	 */
	ismember?: boolean;
}
/**
 * @generated from protobuf message CMsgGCHAppCheersReceived
 */
export interface CMsgGCHAppCheersReceived {
	/**
	 * @generated from protobuf field: optional uint32 appid = 1;
	 */
	appid?: number;
	/**
	 * @generated from protobuf field: repeated CMsgGCHAppCheersReceived.CheerTarget cheer_targets = 2;
	 */
	cheer_targets: CMsgGCHAppCheersReceived_CheerTarget[];
}
/**
 * @generated from protobuf message CMsgGCHAppCheersReceived.CheerTypeAmount
 */
export interface CMsgGCHAppCheersReceived_CheerTypeAmount {
	/**
	 * @generated from protobuf field: optional uint32 cheer_type = 1;
	 */
	cheer_type?: number;
	/**
	 * @generated from protobuf field: optional uint32 cheer_amount = 2;
	 */
	cheer_amount?: number;
}
/**
 * @generated from protobuf message CMsgGCHAppCheersReceived.CheerTarget
 */
export interface CMsgGCHAppCheersReceived_CheerTarget {
	/**
	 * @generated from protobuf field: optional uint64 cheer_target = 1;
	 */
	cheer_target?: bigint;
	/**
	 * @generated from protobuf field: repeated CMsgGCHAppCheersReceived.CheerTypeAmount cheer_types = 2;
	 */
	cheer_types: CMsgGCHAppCheersReceived_CheerTypeAmount[];
}
/**
 * @generated from protobuf message CMsgGCHAppCheersGetAllowedTypes
 */
export interface CMsgGCHAppCheersGetAllowedTypes {
	/**
	 * @generated from protobuf field: optional uint32 appid = 1;
	 */
	appid?: number;
	/**
	 * @generated from protobuf field: optional uint64 cheer_target = 2;
	 */
	cheer_target?: bigint;
}
/**
 * @generated from protobuf message CMsgGCHAppCheersGetAllowedTypesResponse
 */
export interface CMsgGCHAppCheersGetAllowedTypesResponse {
	/**
	 * @generated from protobuf field: repeated uint32 cheer_types_valid_all_users = 1;
	 */
	cheer_types_valid_all_users: number[];
	/**
	 * @generated from protobuf field: repeated CMsgGCHAppCheersGetAllowedTypesResponse.CheerRemaps cheer_remaps = 2;
	 */
	cheer_remaps: CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps[];
	/**
	 * @generated from protobuf field: optional uint32 cache_duration = 3;
	 */
	cache_duration?: number;
}
/**
 * @generated from protobuf message CMsgGCHAppCheersGetAllowedTypesResponse.CheerRemaps
 */
export interface CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps {
	/**
	 * @generated from protobuf field: optional uint32 original_cheer_type = 1;
	 */
	original_cheer_type?: number;
	/**
	 * @generated from protobuf field: optional uint32 remapped_cheer_type = 2;
	 */
	remapped_cheer_type?: number;
	/**
	 * @generated from protobuf field: repeated uint32 account_ids = 3;
	 */
	account_ids: number[];
}
/**
 * @generated from protobuf message CWorkshop_AddSpecialPayment_Request
 */
export interface CWorkshop_AddSpecialPayment_Request {
	/**
	 * @generated from protobuf field: optional uint32 appid = 1;
	 */
	appid?: number;
	/**
	 * @generated from protobuf field: optional uint32 gameitemid = 2;
	 */
	gameitemid?: number;
	/**
	 * @generated from protobuf field: optional string date = 3;
	 */
	date?: string;
	/**
	 * @generated from protobuf field: optional uint64 payment_us_usd = 4;
	 */
	payment_us_usd?: bigint;
	/**
	 * @generated from protobuf field: optional uint64 payment_row_usd = 5;
	 */
	payment_row_usd?: bigint;
}
/**
 * @generated from protobuf message CWorkshop_AddSpecialPayment_Response
 */
export interface CWorkshop_AddSpecialPayment_Response {}
/**
 * @generated from protobuf message CWorkshop_GetSpecialPayments_Request
 */
export interface CWorkshop_GetSpecialPayments_Request {
	/**
	 * @generated from protobuf field: optional uint32 appid = 1;
	 */
	appid?: number;
	/**
	 * @generated from protobuf field: optional uint32 gameitemid = 2;
	 */
	gameitemid?: number;
	/**
	 * @generated from protobuf field: optional string date = 3;
	 */
	date?: string;
}
/**
 * @generated from protobuf message CWorkshop_GetSpecialPayments_Response
 */
export interface CWorkshop_GetSpecialPayments_Response {
	/**
	 * @generated from protobuf field: repeated CWorkshop_GetSpecialPayments_Response.SpecialPayment special_payments = 1;
	 */
	special_payments: CWorkshop_GetSpecialPayments_Response_SpecialPayment[];
}
/**
 * @generated from protobuf message CWorkshop_GetSpecialPayments_Response.SpecialPayment
 */
export interface CWorkshop_GetSpecialPayments_Response_SpecialPayment {
	/**
	 * @generated from protobuf field: optional uint32 appid = 1;
	 */
	appid?: number;
	/**
	 * @generated from protobuf field: optional uint32 gameitemid = 2;
	 */
	gameitemid?: number;
	/**
	 * @generated from protobuf field: optional string date = 3;
	 */
	date?: string;
	/**
	 * @generated from protobuf field: optional uint64 net_payment_us_usd = 4;
	 */
	net_payment_us_usd?: bigint;
	/**
	 * @generated from protobuf field: optional uint64 net_payment_row_usd = 5;
	 */
	net_payment_row_usd?: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class CMsgWebAPIKey$Type extends MessageType<CMsgWebAPIKey> {
	constructor() {
		super("CMsgWebAPIKey", [
			{
				no: 1,
				name: "status",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "account_id",
				kind: "scalar",
				localName: "account_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "publisher_group_id",
				kind: "scalar",
				localName: "publisher_group_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 4,
				name: "key_id",
				kind: "scalar",
				localName: "key_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 5,
				name: "domain",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgWebAPIKey>): CMsgWebAPIKey {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgWebAPIKey>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgWebAPIKey,
	): CMsgWebAPIKey {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 status */ 1:
					message.status = reader.uint32();
					break;
				case /* optional uint32 account_id */ 2:
					message.account_id = reader.uint32();
					break;
				case /* optional uint32 publisher_group_id */ 3:
					message.publisher_group_id = reader.uint32();
					break;
				case /* optional uint32 key_id */ 4:
					message.key_id = reader.uint32();
					break;
				case /* optional string domain */ 5:
					message.domain = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CMsgWebAPIKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional uint32 status = 1; */
		if (message.status !== undefined) writer.tag(1, WireType.Varint).uint32(message.status);
		/* optional uint32 account_id = 2; */
		if (message.account_id !== undefined) writer.tag(2, WireType.Varint).uint32(message.account_id);
		/* optional uint32 publisher_group_id = 3; */
		if (message.publisher_group_id !== undefined) writer.tag(3, WireType.Varint).uint32(message.publisher_group_id);
		/* optional uint32 key_id = 4; */
		if (message.key_id !== undefined) writer.tag(4, WireType.Varint).uint32(message.key_id);
		/* optional string domain = 5; */
		if (message.domain !== undefined) writer.tag(5, WireType.LengthDelimited).string(message.domain);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgWebAPIKey
 */
export const CMsgWebAPIKey = new CMsgWebAPIKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHttpRequest$Type extends MessageType<CMsgHttpRequest> {
	constructor() {
		super("CMsgHttpRequest", [
			{
				no: 1,
				name: "request_method",
				kind: "scalar",
				localName: "request_method",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "hostname",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 3,
				name: "url",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 4,
				name: "headers",
				kind: "message",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgHttpRequest_RequestHeader,
			},
			{
				no: 5,
				name: "get_params",
				kind: "message",
				localName: "get_params",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgHttpRequest_QueryParam,
			},
			{
				no: 6,
				name: "post_params",
				kind: "message",
				localName: "post_params",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgHttpRequest_QueryParam,
			},
			{
				no: 7,
				name: "body",
				kind: "scalar",
				opt: true,
				T: 12 /*ScalarType.BYTES*/,
			},
			{
				no: 8,
				name: "absolute_timeout",
				kind: "scalar",
				localName: "absolute_timeout",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 9,
				name: "use_https",
				kind: "scalar",
				localName: "use_https",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgHttpRequest>): CMsgHttpRequest {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.headers = [];
		message.get_params = [];
		message.post_params = [];
		if (value !== undefined) reflectionMergePartial<CMsgHttpRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgHttpRequest,
	): CMsgHttpRequest {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 request_method */ 1:
					message.request_method = reader.uint32();
					break;
				case /* optional string hostname */ 2:
					message.hostname = reader.string();
					break;
				case /* optional string url */ 3:
					message.url = reader.string();
					break;
				case /* repeated CMsgHttpRequest.RequestHeader headers */ 4:
					message.headers.push(CMsgHttpRequest_RequestHeader.internalBinaryRead(reader, reader.uint32(), options));
					break;
				case /* repeated CMsgHttpRequest.QueryParam get_params */ 5:
					message.get_params.push(CMsgHttpRequest_QueryParam.internalBinaryRead(reader, reader.uint32(), options));
					break;
				case /* repeated CMsgHttpRequest.QueryParam post_params */ 6:
					message.post_params.push(CMsgHttpRequest_QueryParam.internalBinaryRead(reader, reader.uint32(), options));
					break;
				case /* optional bytes body */ 7:
					message.body = reader.bytes();
					break;
				case /* optional uint32 absolute_timeout */ 8:
					message.absolute_timeout = reader.uint32();
					break;
				case /* optional bool use_https */ 9:
					message.use_https = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CMsgHttpRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional uint32 request_method = 1; */
		if (message.request_method !== undefined) writer.tag(1, WireType.Varint).uint32(message.request_method);
		/* optional string hostname = 2; */
		if (message.hostname !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.hostname);
		/* optional string url = 3; */
		if (message.url !== undefined) writer.tag(3, WireType.LengthDelimited).string(message.url);
		/* repeated CMsgHttpRequest.RequestHeader headers = 4; */
		for (let i = 0; i < message.headers.length; i++)
			CMsgHttpRequest_RequestHeader.internalBinaryWrite(
				message.headers[i],
				writer.tag(4, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* repeated CMsgHttpRequest.QueryParam get_params = 5; */
		for (let i = 0; i < message.get_params.length; i++)
			CMsgHttpRequest_QueryParam.internalBinaryWrite(
				message.get_params[i],
				writer.tag(5, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* repeated CMsgHttpRequest.QueryParam post_params = 6; */
		for (let i = 0; i < message.post_params.length; i++)
			CMsgHttpRequest_QueryParam.internalBinaryWrite(
				message.post_params[i],
				writer.tag(6, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional bytes body = 7; */
		if (message.body !== undefined) writer.tag(7, WireType.LengthDelimited).bytes(message.body);
		/* optional uint32 absolute_timeout = 8; */
		if (message.absolute_timeout !== undefined) writer.tag(8, WireType.Varint).uint32(message.absolute_timeout);
		/* optional bool use_https = 9; */
		if (message.use_https !== undefined) writer.tag(9, WireType.Varint).bool(message.use_https);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgHttpRequest
 */
export const CMsgHttpRequest = new CMsgHttpRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHttpRequest_RequestHeader$Type extends MessageType<CMsgHttpRequest_RequestHeader> {
	constructor() {
		super("CMsgHttpRequest.RequestHeader", [
			{
				no: 1,
				name: "name",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 2,
				name: "value",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgHttpRequest_RequestHeader>): CMsgHttpRequest_RequestHeader {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgHttpRequest_RequestHeader>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgHttpRequest_RequestHeader,
	): CMsgHttpRequest_RequestHeader {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional string name */ 1:
					message.name = reader.string();
					break;
				case /* optional string value */ 2:
					message.value = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgHttpRequest_RequestHeader,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional string name = 1; */
		if (message.name !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.name);
		/* optional string value = 2; */
		if (message.value !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.value);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgHttpRequest.RequestHeader
 */
export const CMsgHttpRequest_RequestHeader = new CMsgHttpRequest_RequestHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHttpRequest_QueryParam$Type extends MessageType<CMsgHttpRequest_QueryParam> {
	constructor() {
		super("CMsgHttpRequest.QueryParam", [
			{
				no: 1,
				name: "name",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 2,
				name: "value",
				kind: "scalar",
				opt: true,
				T: 12 /*ScalarType.BYTES*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgHttpRequest_QueryParam>): CMsgHttpRequest_QueryParam {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgHttpRequest_QueryParam>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgHttpRequest_QueryParam,
	): CMsgHttpRequest_QueryParam {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional string name */ 1:
					message.name = reader.string();
					break;
				case /* optional bytes value */ 2:
					message.value = reader.bytes();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgHttpRequest_QueryParam,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional string name = 1; */
		if (message.name !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.name);
		/* optional bytes value = 2; */
		if (message.value !== undefined) writer.tag(2, WireType.LengthDelimited).bytes(message.value);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgHttpRequest.QueryParam
 */
export const CMsgHttpRequest_QueryParam = new CMsgHttpRequest_QueryParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgWebAPIRequest$Type extends MessageType<CMsgWebAPIRequest> {
	constructor() {
		super("CMsgWebAPIRequest", [
			{
				no: 2,
				name: "interface_name",
				kind: "scalar",
				localName: "interface_name",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 3,
				name: "method_name",
				kind: "scalar",
				localName: "method_name",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 4,
				name: "version",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 5,
				name: "api_key",
				kind: "message",
				localName: "api_key",
				T: () => CMsgWebAPIKey,
			},
			{ no: 6, name: "request", kind: "message", T: () => CMsgHttpRequest },
			{
				no: 7,
				name: "routing_app_id",
				kind: "scalar",
				localName: "routing_app_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgWebAPIRequest>): CMsgWebAPIRequest {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgWebAPIRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgWebAPIRequest,
	): CMsgWebAPIRequest {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional string interface_name */ 2:
					message.interface_name = reader.string();
					break;
				case /* optional string method_name */ 3:
					message.method_name = reader.string();
					break;
				case /* optional uint32 version */ 4:
					message.version = reader.uint32();
					break;
				case /* optional CMsgWebAPIKey api_key */ 5:
					message.api_key = CMsgWebAPIKey.internalBinaryRead(reader, reader.uint32(), options, message.api_key);
					break;
				case /* optional CMsgHttpRequest request */ 6:
					message.request = CMsgHttpRequest.internalBinaryRead(reader, reader.uint32(), options, message.request);
					break;
				case /* optional uint32 routing_app_id */ 7:
					message.routing_app_id = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CMsgWebAPIRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional string interface_name = 2; */
		if (message.interface_name !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.interface_name);
		/* optional string method_name = 3; */
		if (message.method_name !== undefined) writer.tag(3, WireType.LengthDelimited).string(message.method_name);
		/* optional uint32 version = 4; */
		if (message.version !== undefined) writer.tag(4, WireType.Varint).uint32(message.version);
		/* optional CMsgWebAPIKey api_key = 5; */
		if (message.api_key)
			CMsgWebAPIKey.internalBinaryWrite(
				message.api_key,
				writer.tag(5, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgHttpRequest request = 6; */
		if (message.request)
			CMsgHttpRequest.internalBinaryWrite(
				message.request,
				writer.tag(6, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional uint32 routing_app_id = 7; */
		if (message.routing_app_id !== undefined) writer.tag(7, WireType.Varint).uint32(message.routing_app_id);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgWebAPIRequest
 */
export const CMsgWebAPIRequest = new CMsgWebAPIRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHttpResponse$Type extends MessageType<CMsgHttpResponse> {
	constructor() {
		super("CMsgHttpResponse", [
			{
				no: 1,
				name: "status_code",
				kind: "scalar",
				localName: "status_code",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "headers",
				kind: "message",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgHttpResponse_ResponseHeader,
			},
			{
				no: 3,
				name: "body",
				kind: "scalar",
				opt: true,
				T: 12 /*ScalarType.BYTES*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgHttpResponse>): CMsgHttpResponse {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.headers = [];
		if (value !== undefined) reflectionMergePartial<CMsgHttpResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgHttpResponse,
	): CMsgHttpResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 status_code */ 1:
					message.status_code = reader.uint32();
					break;
				case /* repeated CMsgHttpResponse.ResponseHeader headers */ 2:
					message.headers.push(CMsgHttpResponse_ResponseHeader.internalBinaryRead(reader, reader.uint32(), options));
					break;
				case /* optional bytes body */ 3:
					message.body = reader.bytes();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CMsgHttpResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional uint32 status_code = 1; */
		if (message.status_code !== undefined) writer.tag(1, WireType.Varint).uint32(message.status_code);
		/* repeated CMsgHttpResponse.ResponseHeader headers = 2; */
		for (let i = 0; i < message.headers.length; i++)
			CMsgHttpResponse_ResponseHeader.internalBinaryWrite(
				message.headers[i],
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional bytes body = 3; */
		if (message.body !== undefined) writer.tag(3, WireType.LengthDelimited).bytes(message.body);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgHttpResponse
 */
export const CMsgHttpResponse = new CMsgHttpResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHttpResponse_ResponseHeader$Type extends MessageType<CMsgHttpResponse_ResponseHeader> {
	constructor() {
		super("CMsgHttpResponse.ResponseHeader", [
			{
				no: 1,
				name: "name",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 2,
				name: "value",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgHttpResponse_ResponseHeader>): CMsgHttpResponse_ResponseHeader {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgHttpResponse_ResponseHeader>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgHttpResponse_ResponseHeader,
	): CMsgHttpResponse_ResponseHeader {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional string name */ 1:
					message.name = reader.string();
					break;
				case /* optional string value */ 2:
					message.value = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgHttpResponse_ResponseHeader,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional string name = 1; */
		if (message.name !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.name);
		/* optional string value = 2; */
		if (message.value !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.value);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgHttpResponse.ResponseHeader
 */
export const CMsgHttpResponse_ResponseHeader = new CMsgHttpResponse_ResponseHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMFindAccounts$Type extends MessageType<CMsgAMFindAccounts> {
	constructor() {
		super("CMsgAMFindAccounts", [
			{
				no: 1,
				name: "search_type",
				kind: "scalar",
				localName: "search_type",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "search_string",
				kind: "scalar",
				localName: "search_string",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgAMFindAccounts>): CMsgAMFindAccounts {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgAMFindAccounts>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgAMFindAccounts,
	): CMsgAMFindAccounts {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 search_type */ 1:
					message.search_type = reader.uint32();
					break;
				case /* optional string search_string */ 2:
					message.search_string = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CMsgAMFindAccounts, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional uint32 search_type = 1; */
		if (message.search_type !== undefined) writer.tag(1, WireType.Varint).uint32(message.search_type);
		/* optional string search_string = 2; */
		if (message.search_string !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.search_string);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgAMFindAccounts
 */
export const CMsgAMFindAccounts = new CMsgAMFindAccounts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMFindAccountsResponse$Type extends MessageType<CMsgAMFindAccountsResponse> {
	constructor() {
		super("CMsgAMFindAccountsResponse", [
			{
				no: 1,
				name: "steam_id",
				kind: "scalar",
				localName: "steam_id",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgAMFindAccountsResponse>): CMsgAMFindAccountsResponse {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.steam_id = [];
		if (value !== undefined) reflectionMergePartial<CMsgAMFindAccountsResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgAMFindAccountsResponse,
	): CMsgAMFindAccountsResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated fixed64 steam_id */ 1:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; )
							message.steam_id.push(reader.fixed64().toBigInt());
					else message.steam_id.push(reader.fixed64().toBigInt());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgAMFindAccountsResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated fixed64 steam_id = 1; */
		for (let i = 0; i < message.steam_id.length; i++) writer.tag(1, WireType.Bit64).fixed64(message.steam_id[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgAMFindAccountsResponse
 */
export const CMsgAMFindAccountsResponse = new CMsgAMFindAccountsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNotifyWatchdog$Type extends MessageType<CMsgNotifyWatchdog> {
	constructor() {
		super("CMsgNotifyWatchdog", [
			{
				no: 1,
				name: "source",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "alert_type",
				kind: "scalar",
				localName: "alert_type",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 4,
				name: "critical",
				kind: "scalar",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 5,
				name: "time",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 6,
				name: "appid",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 7,
				name: "text",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 12,
				name: "recipient",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgNotifyWatchdog>): CMsgNotifyWatchdog {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgNotifyWatchdog>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgNotifyWatchdog,
	): CMsgNotifyWatchdog {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 source */ 1:
					message.source = reader.uint32();
					break;
				case /* optional uint32 alert_type */ 2:
					message.alert_type = reader.uint32();
					break;
				case /* optional bool critical */ 4:
					message.critical = reader.bool();
					break;
				case /* optional uint32 time */ 5:
					message.time = reader.uint32();
					break;
				case /* optional uint32 appid */ 6:
					message.appid = reader.uint32();
					break;
				case /* optional string text */ 7:
					message.text = reader.string();
					break;
				case /* optional string recipient */ 12:
					message.recipient = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CMsgNotifyWatchdog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional uint32 source = 1; */
		if (message.source !== undefined) writer.tag(1, WireType.Varint).uint32(message.source);
		/* optional uint32 alert_type = 2; */
		if (message.alert_type !== undefined) writer.tag(2, WireType.Varint).uint32(message.alert_type);
		/* optional bool critical = 4; */
		if (message.critical !== undefined) writer.tag(4, WireType.Varint).bool(message.critical);
		/* optional uint32 time = 5; */
		if (message.time !== undefined) writer.tag(5, WireType.Varint).uint32(message.time);
		/* optional uint32 appid = 6; */
		if (message.appid !== undefined) writer.tag(6, WireType.Varint).uint32(message.appid);
		/* optional string text = 7; */
		if (message.text !== undefined) writer.tag(7, WireType.LengthDelimited).string(message.text);
		/* optional string recipient = 12; */
		if (message.recipient !== undefined) writer.tag(12, WireType.LengthDelimited).string(message.recipient);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgNotifyWatchdog
 */
export const CMsgNotifyWatchdog = new CMsgNotifyWatchdog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMGetLicenses$Type extends MessageType<CMsgAMGetLicenses> {
	constructor() {
		super("CMsgAMGetLicenses", [
			{
				no: 1,
				name: "steamid",
				kind: "scalar",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgAMGetLicenses>): CMsgAMGetLicenses {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgAMGetLicenses>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgAMGetLicenses,
	): CMsgAMGetLicenses {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed64 steamid */ 1:
					message.steamid = reader.fixed64().toBigInt();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CMsgAMGetLicenses, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional fixed64 steamid = 1; */
		if (message.steamid !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steamid);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgAMGetLicenses
 */
export const CMsgAMGetLicenses = new CMsgAMGetLicenses$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgPackageLicense$Type extends MessageType<CMsgPackageLicense> {
	constructor() {
		super("CMsgPackageLicense", [
			{
				no: 1,
				name: "package_id",
				kind: "scalar",
				localName: "package_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "time_created",
				kind: "scalar",
				localName: "time_created",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "owner_id",
				kind: "scalar",
				localName: "owner_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgPackageLicense>): CMsgPackageLicense {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgPackageLicense>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgPackageLicense,
	): CMsgPackageLicense {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 package_id */ 1:
					message.package_id = reader.uint32();
					break;
				case /* optional uint32 time_created */ 2:
					message.time_created = reader.uint32();
					break;
				case /* optional uint32 owner_id */ 3:
					message.owner_id = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CMsgPackageLicense, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional uint32 package_id = 1; */
		if (message.package_id !== undefined) writer.tag(1, WireType.Varint).uint32(message.package_id);
		/* optional uint32 time_created = 2; */
		if (message.time_created !== undefined) writer.tag(2, WireType.Varint).uint32(message.time_created);
		/* optional uint32 owner_id = 3; */
		if (message.owner_id !== undefined) writer.tag(3, WireType.Varint).uint32(message.owner_id);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgPackageLicense
 */
export const CMsgPackageLicense = new CMsgPackageLicense$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMGetLicensesResponse$Type extends MessageType<CMsgAMGetLicensesResponse> {
	constructor() {
		super("CMsgAMGetLicensesResponse", [
			{
				no: 1,
				name: "license",
				kind: "message",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgPackageLicense,
			},
			{
				no: 2,
				name: "result",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgAMGetLicensesResponse>): CMsgAMGetLicensesResponse {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.license = [];
		if (value !== undefined) reflectionMergePartial<CMsgAMGetLicensesResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgAMGetLicensesResponse,
	): CMsgAMGetLicensesResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated CMsgPackageLicense license */ 1:
					message.license.push(CMsgPackageLicense.internalBinaryRead(reader, reader.uint32(), options));
					break;
				case /* optional uint32 result */ 2:
					message.result = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgAMGetLicensesResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated CMsgPackageLicense license = 1; */
		for (let i = 0; i < message.license.length; i++)
			CMsgPackageLicense.internalBinaryWrite(
				message.license[i],
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional uint32 result = 2; */
		if (message.result !== undefined) writer.tag(2, WireType.Varint).uint32(message.result);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgAMGetLicensesResponse
 */
export const CMsgAMGetLicensesResponse = new CMsgAMGetLicensesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetCommandList$Type extends MessageType<CMsgGCGetCommandList> {
	constructor() {
		super("CMsgGCGetCommandList", [
			{
				no: 1,
				name: "app_id",
				kind: "scalar",
				localName: "app_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "command_prefix",
				kind: "scalar",
				localName: "command_prefix",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCGetCommandList>): CMsgGCGetCommandList {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCGetCommandList>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCGetCommandList,
	): CMsgGCGetCommandList {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 app_id */ 1:
					message.app_id = reader.uint32();
					break;
				case /* optional string command_prefix */ 2:
					message.command_prefix = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCGetCommandList,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 app_id = 1; */
		if (message.app_id !== undefined) writer.tag(1, WireType.Varint).uint32(message.app_id);
		/* optional string command_prefix = 2; */
		if (message.command_prefix !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.command_prefix);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCGetCommandList
 */
export const CMsgGCGetCommandList = new CMsgGCGetCommandList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetCommandListResponse$Type extends MessageType<CMsgGCGetCommandListResponse> {
	constructor() {
		super("CMsgGCGetCommandListResponse", [
			{
				no: 1,
				name: "command_name",
				kind: "scalar",
				localName: "command_name",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCGetCommandListResponse>): CMsgGCGetCommandListResponse {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.command_name = [];
		if (value !== undefined) reflectionMergePartial<CMsgGCGetCommandListResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCGetCommandListResponse,
	): CMsgGCGetCommandListResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated string command_name */ 1:
					message.command_name.push(reader.string());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCGetCommandListResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated string command_name = 1; */
		for (let i = 0; i < message.command_name.length; i++)
			writer.tag(1, WireType.LengthDelimited).string(message.command_name[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCGetCommandListResponse
 */
export const CMsgGCGetCommandListResponse = new CMsgGCGetCommandListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedGet$Type extends MessageType<CGCMsgMemCachedGet> {
	constructor() {
		super("CGCMsgMemCachedGet", [
			{
				no: 1,
				name: "keys",
				kind: "scalar",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CGCMsgMemCachedGet>): CGCMsgMemCachedGet {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.keys = [];
		if (value !== undefined) reflectionMergePartial<CGCMsgMemCachedGet>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CGCMsgMemCachedGet,
	): CGCMsgMemCachedGet {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated string keys */ 1:
					message.keys.push(reader.string());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CGCMsgMemCachedGet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* repeated string keys = 1; */
		for (let i = 0; i < message.keys.length; i++) writer.tag(1, WireType.LengthDelimited).string(message.keys[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedGet
 */
export const CGCMsgMemCachedGet = new CGCMsgMemCachedGet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedGetResponse$Type extends MessageType<CGCMsgMemCachedGetResponse> {
	constructor() {
		super("CGCMsgMemCachedGetResponse", [
			{
				no: 1,
				name: "values",
				kind: "message",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CGCMsgMemCachedGetResponse_ValueTag,
			},
		]);
	}
	create(value?: PartialMessage<CGCMsgMemCachedGetResponse>): CGCMsgMemCachedGetResponse {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.values = [];
		if (value !== undefined) reflectionMergePartial<CGCMsgMemCachedGetResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CGCMsgMemCachedGetResponse,
	): CGCMsgMemCachedGetResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated CGCMsgMemCachedGetResponse.ValueTag values */ 1:
					message.values.push(CGCMsgMemCachedGetResponse_ValueTag.internalBinaryRead(reader, reader.uint32(), options));
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CGCMsgMemCachedGetResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated CGCMsgMemCachedGetResponse.ValueTag values = 1; */
		for (let i = 0; i < message.values.length; i++)
			CGCMsgMemCachedGetResponse_ValueTag.internalBinaryWrite(
				message.values[i],
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedGetResponse
 */
export const CGCMsgMemCachedGetResponse = new CGCMsgMemCachedGetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedGetResponse_ValueTag$Type extends MessageType<CGCMsgMemCachedGetResponse_ValueTag> {
	constructor() {
		super("CGCMsgMemCachedGetResponse.ValueTag", [
			{
				no: 1,
				name: "found",
				kind: "scalar",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 2,
				name: "value",
				kind: "scalar",
				opt: true,
				T: 12 /*ScalarType.BYTES*/,
			},
		]);
	}
	create(value?: PartialMessage<CGCMsgMemCachedGetResponse_ValueTag>): CGCMsgMemCachedGetResponse_ValueTag {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CGCMsgMemCachedGetResponse_ValueTag>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CGCMsgMemCachedGetResponse_ValueTag,
	): CGCMsgMemCachedGetResponse_ValueTag {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional bool found */ 1:
					message.found = reader.bool();
					break;
				case /* optional bytes value */ 2:
					message.value = reader.bytes();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CGCMsgMemCachedGetResponse_ValueTag,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional bool found = 1; */
		if (message.found !== undefined) writer.tag(1, WireType.Varint).bool(message.found);
		/* optional bytes value = 2; */
		if (message.value !== undefined) writer.tag(2, WireType.LengthDelimited).bytes(message.value);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedGetResponse.ValueTag
 */
export const CGCMsgMemCachedGetResponse_ValueTag = new CGCMsgMemCachedGetResponse_ValueTag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedSet$Type extends MessageType<CGCMsgMemCachedSet> {
	constructor() {
		super("CGCMsgMemCachedSet", [
			{
				no: 1,
				name: "keys",
				kind: "message",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CGCMsgMemCachedSet_KeyPair,
			},
		]);
	}
	create(value?: PartialMessage<CGCMsgMemCachedSet>): CGCMsgMemCachedSet {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.keys = [];
		if (value !== undefined) reflectionMergePartial<CGCMsgMemCachedSet>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CGCMsgMemCachedSet,
	): CGCMsgMemCachedSet {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated CGCMsgMemCachedSet.KeyPair keys */ 1:
					message.keys.push(CGCMsgMemCachedSet_KeyPair.internalBinaryRead(reader, reader.uint32(), options));
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CGCMsgMemCachedSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* repeated CGCMsgMemCachedSet.KeyPair keys = 1; */
		for (let i = 0; i < message.keys.length; i++)
			CGCMsgMemCachedSet_KeyPair.internalBinaryWrite(
				message.keys[i],
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedSet
 */
export const CGCMsgMemCachedSet = new CGCMsgMemCachedSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedSet_KeyPair$Type extends MessageType<CGCMsgMemCachedSet_KeyPair> {
	constructor() {
		super("CGCMsgMemCachedSet.KeyPair", [
			{
				no: 1,
				name: "name",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 2,
				name: "value",
				kind: "scalar",
				opt: true,
				T: 12 /*ScalarType.BYTES*/,
			},
		]);
	}
	create(value?: PartialMessage<CGCMsgMemCachedSet_KeyPair>): CGCMsgMemCachedSet_KeyPair {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CGCMsgMemCachedSet_KeyPair>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CGCMsgMemCachedSet_KeyPair,
	): CGCMsgMemCachedSet_KeyPair {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional string name */ 1:
					message.name = reader.string();
					break;
				case /* optional bytes value */ 2:
					message.value = reader.bytes();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CGCMsgMemCachedSet_KeyPair,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional string name = 1; */
		if (message.name !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.name);
		/* optional bytes value = 2; */
		if (message.value !== undefined) writer.tag(2, WireType.LengthDelimited).bytes(message.value);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedSet.KeyPair
 */
export const CGCMsgMemCachedSet_KeyPair = new CGCMsgMemCachedSet_KeyPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedDelete$Type extends MessageType<CGCMsgMemCachedDelete> {
	constructor() {
		super("CGCMsgMemCachedDelete", [
			{
				no: 1,
				name: "keys",
				kind: "scalar",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CGCMsgMemCachedDelete>): CGCMsgMemCachedDelete {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.keys = [];
		if (value !== undefined) reflectionMergePartial<CGCMsgMemCachedDelete>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CGCMsgMemCachedDelete,
	): CGCMsgMemCachedDelete {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated string keys */ 1:
					message.keys.push(reader.string());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CGCMsgMemCachedDelete,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated string keys = 1; */
		for (let i = 0; i < message.keys.length; i++) writer.tag(1, WireType.LengthDelimited).string(message.keys[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedDelete
 */
export const CGCMsgMemCachedDelete = new CGCMsgMemCachedDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedStats$Type extends MessageType<CGCMsgMemCachedStats> {
	constructor() {
		super("CGCMsgMemCachedStats", []);
	}
	create(value?: PartialMessage<CGCMsgMemCachedStats>): CGCMsgMemCachedStats {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CGCMsgMemCachedStats>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CGCMsgMemCachedStats,
	): CGCMsgMemCachedStats {
		return target ?? this.create();
	}
	internalBinaryWrite(
		message: CGCMsgMemCachedStats,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedStats
 */
export const CGCMsgMemCachedStats = new CGCMsgMemCachedStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedStatsResponse$Type extends MessageType<CGCMsgMemCachedStatsResponse> {
	constructor() {
		super("CGCMsgMemCachedStatsResponse", [
			{
				no: 1,
				name: "curr_connections",
				kind: "scalar",
				localName: "curr_connections",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "cmd_get",
				kind: "scalar",
				localName: "cmd_get",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 3,
				name: "cmd_set",
				kind: "scalar",
				localName: "cmd_set",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 4,
				name: "cmd_flush",
				kind: "scalar",
				localName: "cmd_flush",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 5,
				name: "get_hits",
				kind: "scalar",
				localName: "get_hits",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 6,
				name: "get_misses",
				kind: "scalar",
				localName: "get_misses",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 7,
				name: "delete_hits",
				kind: "scalar",
				localName: "delete_hits",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 8,
				name: "delete_misses",
				kind: "scalar",
				localName: "delete_misses",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 9,
				name: "bytes_read",
				kind: "scalar",
				localName: "bytes_read",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 10,
				name: "bytes_written",
				kind: "scalar",
				localName: "bytes_written",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 11,
				name: "limit_maxbytes",
				kind: "scalar",
				localName: "limit_maxbytes",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 12,
				name: "curr_items",
				kind: "scalar",
				localName: "curr_items",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 13,
				name: "evictions",
				kind: "scalar",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 14,
				name: "bytes",
				kind: "scalar",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		]);
	}
	create(value?: PartialMessage<CGCMsgMemCachedStatsResponse>): CGCMsgMemCachedStatsResponse {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CGCMsgMemCachedStatsResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CGCMsgMemCachedStatsResponse,
	): CGCMsgMemCachedStatsResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint64 curr_connections */ 1:
					message.curr_connections = reader.uint64().toBigInt();
					break;
				case /* optional uint64 cmd_get */ 2:
					message.cmd_get = reader.uint64().toBigInt();
					break;
				case /* optional uint64 cmd_set */ 3:
					message.cmd_set = reader.uint64().toBigInt();
					break;
				case /* optional uint64 cmd_flush */ 4:
					message.cmd_flush = reader.uint64().toBigInt();
					break;
				case /* optional uint64 get_hits */ 5:
					message.get_hits = reader.uint64().toBigInt();
					break;
				case /* optional uint64 get_misses */ 6:
					message.get_misses = reader.uint64().toBigInt();
					break;
				case /* optional uint64 delete_hits */ 7:
					message.delete_hits = reader.uint64().toBigInt();
					break;
				case /* optional uint64 delete_misses */ 8:
					message.delete_misses = reader.uint64().toBigInt();
					break;
				case /* optional uint64 bytes_read */ 9:
					message.bytes_read = reader.uint64().toBigInt();
					break;
				case /* optional uint64 bytes_written */ 10:
					message.bytes_written = reader.uint64().toBigInt();
					break;
				case /* optional uint64 limit_maxbytes */ 11:
					message.limit_maxbytes = reader.uint64().toBigInt();
					break;
				case /* optional uint64 curr_items */ 12:
					message.curr_items = reader.uint64().toBigInt();
					break;
				case /* optional uint64 evictions */ 13:
					message.evictions = reader.uint64().toBigInt();
					break;
				case /* optional uint64 bytes */ 14:
					message.bytes = reader.uint64().toBigInt();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CGCMsgMemCachedStatsResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint64 curr_connections = 1; */
		if (message.curr_connections !== undefined) writer.tag(1, WireType.Varint).uint64(message.curr_connections);
		/* optional uint64 cmd_get = 2; */
		if (message.cmd_get !== undefined) writer.tag(2, WireType.Varint).uint64(message.cmd_get);
		/* optional uint64 cmd_set = 3; */
		if (message.cmd_set !== undefined) writer.tag(3, WireType.Varint).uint64(message.cmd_set);
		/* optional uint64 cmd_flush = 4; */
		if (message.cmd_flush !== undefined) writer.tag(4, WireType.Varint).uint64(message.cmd_flush);
		/* optional uint64 get_hits = 5; */
		if (message.get_hits !== undefined) writer.tag(5, WireType.Varint).uint64(message.get_hits);
		/* optional uint64 get_misses = 6; */
		if (message.get_misses !== undefined) writer.tag(6, WireType.Varint).uint64(message.get_misses);
		/* optional uint64 delete_hits = 7; */
		if (message.delete_hits !== undefined) writer.tag(7, WireType.Varint).uint64(message.delete_hits);
		/* optional uint64 delete_misses = 8; */
		if (message.delete_misses !== undefined) writer.tag(8, WireType.Varint).uint64(message.delete_misses);
		/* optional uint64 bytes_read = 9; */
		if (message.bytes_read !== undefined) writer.tag(9, WireType.Varint).uint64(message.bytes_read);
		/* optional uint64 bytes_written = 10; */
		if (message.bytes_written !== undefined) writer.tag(10, WireType.Varint).uint64(message.bytes_written);
		/* optional uint64 limit_maxbytes = 11; */
		if (message.limit_maxbytes !== undefined) writer.tag(11, WireType.Varint).uint64(message.limit_maxbytes);
		/* optional uint64 curr_items = 12; */
		if (message.curr_items !== undefined) writer.tag(12, WireType.Varint).uint64(message.curr_items);
		/* optional uint64 evictions = 13; */
		if (message.evictions !== undefined) writer.tag(13, WireType.Varint).uint64(message.evictions);
		/* optional uint64 bytes = 14; */
		if (message.bytes !== undefined) writer.tag(14, WireType.Varint).uint64(message.bytes);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedStatsResponse
 */
export const CGCMsgMemCachedStatsResponse = new CGCMsgMemCachedStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgSQLStats$Type extends MessageType<CGCMsgSQLStats> {
	constructor() {
		super("CGCMsgSQLStats", [
			{
				no: 1,
				name: "schema_catalog",
				kind: "scalar",
				localName: "schema_catalog",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CGCMsgSQLStats>): CGCMsgSQLStats {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CGCMsgSQLStats>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CGCMsgSQLStats,
	): CGCMsgSQLStats {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 schema_catalog */ 1:
					message.schema_catalog = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CGCMsgSQLStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional uint32 schema_catalog = 1; */
		if (message.schema_catalog !== undefined) writer.tag(1, WireType.Varint).uint32(message.schema_catalog);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CGCMsgSQLStats
 */
export const CGCMsgSQLStats = new CGCMsgSQLStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgSQLStatsResponse$Type extends MessageType<CGCMsgSQLStatsResponse> {
	constructor() {
		super("CGCMsgSQLStatsResponse", [
			{
				no: 1,
				name: "threads",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "threads_connected",
				kind: "scalar",
				localName: "threads_connected",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "threads_active",
				kind: "scalar",
				localName: "threads_active",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 4,
				name: "operations_submitted",
				kind: "scalar",
				localName: "operations_submitted",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 5,
				name: "prepared_statements_executed",
				kind: "scalar",
				localName: "prepared_statements_executed",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 6,
				name: "non_prepared_statements_executed",
				kind: "scalar",
				localName: "non_prepared_statements_executed",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 7,
				name: "deadlock_retries",
				kind: "scalar",
				localName: "deadlock_retries",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 8,
				name: "operations_timed_out_in_queue",
				kind: "scalar",
				localName: "operations_timed_out_in_queue",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 9,
				name: "errors",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CGCMsgSQLStatsResponse>): CGCMsgSQLStatsResponse {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CGCMsgSQLStatsResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CGCMsgSQLStatsResponse,
	): CGCMsgSQLStatsResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 threads */ 1:
					message.threads = reader.uint32();
					break;
				case /* optional uint32 threads_connected */ 2:
					message.threads_connected = reader.uint32();
					break;
				case /* optional uint32 threads_active */ 3:
					message.threads_active = reader.uint32();
					break;
				case /* optional uint32 operations_submitted */ 4:
					message.operations_submitted = reader.uint32();
					break;
				case /* optional uint32 prepared_statements_executed */ 5:
					message.prepared_statements_executed = reader.uint32();
					break;
				case /* optional uint32 non_prepared_statements_executed */ 6:
					message.non_prepared_statements_executed = reader.uint32();
					break;
				case /* optional uint32 deadlock_retries */ 7:
					message.deadlock_retries = reader.uint32();
					break;
				case /* optional uint32 operations_timed_out_in_queue */ 8:
					message.operations_timed_out_in_queue = reader.uint32();
					break;
				case /* optional uint32 errors */ 9:
					message.errors = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CGCMsgSQLStatsResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 threads = 1; */
		if (message.threads !== undefined) writer.tag(1, WireType.Varint).uint32(message.threads);
		/* optional uint32 threads_connected = 2; */
		if (message.threads_connected !== undefined) writer.tag(2, WireType.Varint).uint32(message.threads_connected);
		/* optional uint32 threads_active = 3; */
		if (message.threads_active !== undefined) writer.tag(3, WireType.Varint).uint32(message.threads_active);
		/* optional uint32 operations_submitted = 4; */
		if (message.operations_submitted !== undefined) writer.tag(4, WireType.Varint).uint32(message.operations_submitted);
		/* optional uint32 prepared_statements_executed = 5; */
		if (message.prepared_statements_executed !== undefined)
			writer.tag(5, WireType.Varint).uint32(message.prepared_statements_executed);
		/* optional uint32 non_prepared_statements_executed = 6; */
		if (message.non_prepared_statements_executed !== undefined)
			writer.tag(6, WireType.Varint).uint32(message.non_prepared_statements_executed);
		/* optional uint32 deadlock_retries = 7; */
		if (message.deadlock_retries !== undefined) writer.tag(7, WireType.Varint).uint32(message.deadlock_retries);
		/* optional uint32 operations_timed_out_in_queue = 8; */
		if (message.operations_timed_out_in_queue !== undefined)
			writer.tag(8, WireType.Varint).uint32(message.operations_timed_out_in_queue);
		/* optional uint32 errors = 9; */
		if (message.errors !== undefined) writer.tag(9, WireType.Varint).uint32(message.errors);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CGCMsgSQLStatsResponse
 */
export const CGCMsgSQLStatsResponse = new CGCMsgSQLStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMAddFreeLicense$Type extends MessageType<CMsgAMAddFreeLicense> {
	constructor() {
		super("CMsgAMAddFreeLicense", [
			{
				no: 1,
				name: "steamid",
				kind: "scalar",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "ip_public",
				kind: "scalar",
				localName: "ip_public",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "packageid",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 4,
				name: "store_country_code",
				kind: "scalar",
				localName: "store_country_code",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgAMAddFreeLicense>): CMsgAMAddFreeLicense {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgAMAddFreeLicense>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgAMAddFreeLicense,
	): CMsgAMAddFreeLicense {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed64 steamid */ 1:
					message.steamid = reader.fixed64().toBigInt();
					break;
				case /* optional uint32 ip_public */ 2:
					message.ip_public = reader.uint32();
					break;
				case /* optional uint32 packageid */ 3:
					message.packageid = reader.uint32();
					break;
				case /* optional string store_country_code */ 4:
					message.store_country_code = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgAMAddFreeLicense,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional fixed64 steamid = 1; */
		if (message.steamid !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steamid);
		/* optional uint32 ip_public = 2; */
		if (message.ip_public !== undefined) writer.tag(2, WireType.Varint).uint32(message.ip_public);
		/* optional uint32 packageid = 3; */
		if (message.packageid !== undefined) writer.tag(3, WireType.Varint).uint32(message.packageid);
		/* optional string store_country_code = 4; */
		if (message.store_country_code !== undefined)
			writer.tag(4, WireType.LengthDelimited).string(message.store_country_code);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgAMAddFreeLicense
 */
export const CMsgAMAddFreeLicense = new CMsgAMAddFreeLicense$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMAddFreeLicenseResponse$Type extends MessageType<CMsgAMAddFreeLicenseResponse> {
	constructor() {
		super("CMsgAMAddFreeLicenseResponse", [
			{
				no: 1,
				name: "eresult",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "purchase_result_detail",
				kind: "scalar",
				localName: "purchase_result_detail",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "transid",
				kind: "scalar",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgAMAddFreeLicenseResponse>): CMsgAMAddFreeLicenseResponse {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgAMAddFreeLicenseResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgAMAddFreeLicenseResponse,
	): CMsgAMAddFreeLicenseResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 eresult */ 1:
					message.eresult = reader.int32();
					break;
				case /* optional int32 purchase_result_detail */ 2:
					message.purchase_result_detail = reader.int32();
					break;
				case /* optional fixed64 transid */ 3:
					message.transid = reader.fixed64().toBigInt();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgAMAddFreeLicenseResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 eresult = 1; */
		if (message.eresult !== undefined) writer.tag(1, WireType.Varint).int32(message.eresult);
		/* optional int32 purchase_result_detail = 2; */
		if (message.purchase_result_detail !== undefined)
			writer.tag(2, WireType.Varint).int32(message.purchase_result_detail);
		/* optional fixed64 transid = 3; */
		if (message.transid !== undefined) writer.tag(3, WireType.Bit64).fixed64(message.transid);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgAMAddFreeLicenseResponse
 */
export const CMsgAMAddFreeLicenseResponse = new CMsgAMAddFreeLicenseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgGetIPLocation$Type extends MessageType<CGCMsgGetIPLocation> {
	constructor() {
		super("CGCMsgGetIPLocation", [
			{
				no: 1,
				name: "ips",
				kind: "scalar",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 7 /*ScalarType.FIXED32*/,
			},
		]);
	}
	create(value?: PartialMessage<CGCMsgGetIPLocation>): CGCMsgGetIPLocation {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.ips = [];
		if (value !== undefined) reflectionMergePartial<CGCMsgGetIPLocation>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CGCMsgGetIPLocation,
	): CGCMsgGetIPLocation {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated fixed32 ips */ 1:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.ips.push(reader.fixed32());
					else message.ips.push(reader.fixed32());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CGCMsgGetIPLocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* repeated fixed32 ips = 1; */
		for (let i = 0; i < message.ips.length; i++) writer.tag(1, WireType.Bit32).fixed32(message.ips[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CGCMsgGetIPLocation
 */
export const CGCMsgGetIPLocation = new CGCMsgGetIPLocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgGetIPASN$Type extends MessageType<CGCMsgGetIPASN> {
	constructor() {
		super("CGCMsgGetIPASN", [
			{
				no: 1,
				name: "ips",
				kind: "scalar",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 7 /*ScalarType.FIXED32*/,
			},
		]);
	}
	create(value?: PartialMessage<CGCMsgGetIPASN>): CGCMsgGetIPASN {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.ips = [];
		if (value !== undefined) reflectionMergePartial<CGCMsgGetIPASN>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CGCMsgGetIPASN,
	): CGCMsgGetIPASN {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated fixed32 ips */ 1:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.ips.push(reader.fixed32());
					else message.ips.push(reader.fixed32());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CGCMsgGetIPASN, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* repeated fixed32 ips = 1; */
		for (let i = 0; i < message.ips.length; i++) writer.tag(1, WireType.Bit32).fixed32(message.ips[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CGCMsgGetIPASN
 */
export const CGCMsgGetIPASN = new CGCMsgGetIPASN$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CIPASNInfo$Type extends MessageType<CIPASNInfo> {
	constructor() {
		super("CIPASNInfo", [
			{
				no: 1,
				name: "ip",
				kind: "scalar",
				opt: true,
				T: 7 /*ScalarType.FIXED32*/,
			},
			{
				no: 2,
				name: "asn",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CIPASNInfo>): CIPASNInfo {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CIPASNInfo>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CIPASNInfo,
	): CIPASNInfo {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed32 ip */ 1:
					message.ip = reader.fixed32();
					break;
				case /* optional uint32 asn */ 2:
					message.asn = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CIPASNInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional fixed32 ip = 1; */
		if (message.ip !== undefined) writer.tag(1, WireType.Bit32).fixed32(message.ip);
		/* optional uint32 asn = 2; */
		if (message.asn !== undefined) writer.tag(2, WireType.Varint).uint32(message.asn);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CIPASNInfo
 */
export const CIPASNInfo = new CIPASNInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgGetIPASNResponse$Type extends MessageType<CGCMsgGetIPASNResponse> {
	constructor() {
		super("CGCMsgGetIPASNResponse", [
			{
				no: 1,
				name: "infos",
				kind: "message",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CIPASNInfo,
			},
		]);
	}
	create(value?: PartialMessage<CGCMsgGetIPASNResponse>): CGCMsgGetIPASNResponse {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.infos = [];
		if (value !== undefined) reflectionMergePartial<CGCMsgGetIPASNResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CGCMsgGetIPASNResponse,
	): CGCMsgGetIPASNResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated CIPASNInfo infos */ 1:
					message.infos.push(CIPASNInfo.internalBinaryRead(reader, reader.uint32(), options));
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CGCMsgGetIPASNResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated CIPASNInfo infos = 1; */
		for (let i = 0; i < message.infos.length; i++)
			CIPASNInfo.internalBinaryWrite(message.infos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CGCMsgGetIPASNResponse
 */
export const CGCMsgGetIPASNResponse = new CGCMsgGetIPASNResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMSendEmail$Type extends MessageType<CMsgAMSendEmail> {
	constructor() {
		super("CMsgAMSendEmail", [
			{
				no: 1,
				name: "steamid",
				kind: "scalar",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "email_msg_type",
				kind: "scalar",
				localName: "email_msg_type",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "email_format",
				kind: "scalar",
				localName: "email_format",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 5,
				name: "persona_name_tokens",
				kind: "message",
				localName: "persona_name_tokens",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgAMSendEmail_PersonaNameReplacementToken,
			},
			{
				no: 6,
				name: "source_gc",
				kind: "scalar",
				localName: "source_gc",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 7,
				name: "tokens",
				kind: "message",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgAMSendEmail_ReplacementToken,
			},
		]);
	}
	create(value?: PartialMessage<CMsgAMSendEmail>): CMsgAMSendEmail {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.persona_name_tokens = [];
		message.tokens = [];
		if (value !== undefined) reflectionMergePartial<CMsgAMSendEmail>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgAMSendEmail,
	): CMsgAMSendEmail {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed64 steamid */ 1:
					message.steamid = reader.fixed64().toBigInt();
					break;
				case /* optional uint32 email_msg_type */ 2:
					message.email_msg_type = reader.uint32();
					break;
				case /* optional uint32 email_format */ 3:
					message.email_format = reader.uint32();
					break;
				case /* repeated CMsgAMSendEmail.PersonaNameReplacementToken persona_name_tokens */ 5:
					message.persona_name_tokens.push(
						CMsgAMSendEmail_PersonaNameReplacementToken.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				case /* optional uint32 source_gc */ 6:
					message.source_gc = reader.uint32();
					break;
				case /* repeated CMsgAMSendEmail.ReplacementToken tokens */ 7:
					message.tokens.push(CMsgAMSendEmail_ReplacementToken.internalBinaryRead(reader, reader.uint32(), options));
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CMsgAMSendEmail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional fixed64 steamid = 1; */
		if (message.steamid !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steamid);
		/* optional uint32 email_msg_type = 2; */
		if (message.email_msg_type !== undefined) writer.tag(2, WireType.Varint).uint32(message.email_msg_type);
		/* optional uint32 email_format = 3; */
		if (message.email_format !== undefined) writer.tag(3, WireType.Varint).uint32(message.email_format);
		/* repeated CMsgAMSendEmail.PersonaNameReplacementToken persona_name_tokens = 5; */
		for (let i = 0; i < message.persona_name_tokens.length; i++)
			CMsgAMSendEmail_PersonaNameReplacementToken.internalBinaryWrite(
				message.persona_name_tokens[i],
				writer.tag(5, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional uint32 source_gc = 6; */
		if (message.source_gc !== undefined) writer.tag(6, WireType.Varint).uint32(message.source_gc);
		/* repeated CMsgAMSendEmail.ReplacementToken tokens = 7; */
		for (let i = 0; i < message.tokens.length; i++)
			CMsgAMSendEmail_ReplacementToken.internalBinaryWrite(
				message.tokens[i],
				writer.tag(7, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgAMSendEmail
 */
export const CMsgAMSendEmail = new CMsgAMSendEmail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMSendEmail_ReplacementToken$Type extends MessageType<CMsgAMSendEmail_ReplacementToken> {
	constructor() {
		super("CMsgAMSendEmail.ReplacementToken", [
			{
				no: 1,
				name: "token_name",
				kind: "scalar",
				localName: "token_name",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 2,
				name: "token_value",
				kind: "scalar",
				localName: "token_value",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgAMSendEmail_ReplacementToken>): CMsgAMSendEmail_ReplacementToken {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgAMSendEmail_ReplacementToken>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgAMSendEmail_ReplacementToken,
	): CMsgAMSendEmail_ReplacementToken {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional string token_name */ 1:
					message.token_name = reader.string();
					break;
				case /* optional string token_value */ 2:
					message.token_value = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgAMSendEmail_ReplacementToken,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional string token_name = 1; */
		if (message.token_name !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.token_name);
		/* optional string token_value = 2; */
		if (message.token_value !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.token_value);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgAMSendEmail.ReplacementToken
 */
export const CMsgAMSendEmail_ReplacementToken = new CMsgAMSendEmail_ReplacementToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMSendEmail_PersonaNameReplacementToken$Type extends MessageType<CMsgAMSendEmail_PersonaNameReplacementToken> {
	constructor() {
		super("CMsgAMSendEmail.PersonaNameReplacementToken", [
			{
				no: 1,
				name: "steamid",
				kind: "scalar",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "token_name",
				kind: "scalar",
				localName: "token_name",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CMsgAMSendEmail_PersonaNameReplacementToken>,
	): CMsgAMSendEmail_PersonaNameReplacementToken {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgAMSendEmail_PersonaNameReplacementToken>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgAMSendEmail_PersonaNameReplacementToken,
	): CMsgAMSendEmail_PersonaNameReplacementToken {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed64 steamid */ 1:
					message.steamid = reader.fixed64().toBigInt();
					break;
				case /* optional string token_name */ 2:
					message.token_name = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgAMSendEmail_PersonaNameReplacementToken,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional fixed64 steamid = 1; */
		if (message.steamid !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steamid);
		/* optional string token_name = 2; */
		if (message.token_name !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.token_name);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgAMSendEmail.PersonaNameReplacementToken
 */
export const CMsgAMSendEmail_PersonaNameReplacementToken = new CMsgAMSendEmail_PersonaNameReplacementToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMSendEmailResponse$Type extends MessageType<CMsgAMSendEmailResponse> {
	constructor() {
		super("CMsgAMSendEmailResponse", [
			{
				no: 1,
				name: "eresult",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgAMSendEmailResponse>): CMsgAMSendEmailResponse {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgAMSendEmailResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgAMSendEmailResponse,
	): CMsgAMSendEmailResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 eresult */ 1:
					message.eresult = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgAMSendEmailResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 eresult = 1; */
		if (message.eresult !== undefined) writer.tag(1, WireType.Varint).uint32(message.eresult);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgAMSendEmailResponse
 */
export const CMsgAMSendEmailResponse = new CMsgAMSendEmailResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetEmailTemplate$Type extends MessageType<CMsgGCGetEmailTemplate> {
	constructor() {
		super("CMsgGCGetEmailTemplate", [
			{
				no: 1,
				name: "app_id",
				kind: "scalar",
				localName: "app_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "email_msg_type",
				kind: "scalar",
				localName: "email_msg_type",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "email_lang",
				kind: "scalar",
				localName: "email_lang",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 4,
				name: "email_format",
				kind: "scalar",
				localName: "email_format",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCGetEmailTemplate>): CMsgGCGetEmailTemplate {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCGetEmailTemplate>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCGetEmailTemplate,
	): CMsgGCGetEmailTemplate {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 app_id */ 1:
					message.app_id = reader.uint32();
					break;
				case /* optional uint32 email_msg_type */ 2:
					message.email_msg_type = reader.uint32();
					break;
				case /* optional int32 email_lang */ 3:
					message.email_lang = reader.int32();
					break;
				case /* optional int32 email_format */ 4:
					message.email_format = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCGetEmailTemplate,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 app_id = 1; */
		if (message.app_id !== undefined) writer.tag(1, WireType.Varint).uint32(message.app_id);
		/* optional uint32 email_msg_type = 2; */
		if (message.email_msg_type !== undefined) writer.tag(2, WireType.Varint).uint32(message.email_msg_type);
		/* optional int32 email_lang = 3; */
		if (message.email_lang !== undefined) writer.tag(3, WireType.Varint).int32(message.email_lang);
		/* optional int32 email_format = 4; */
		if (message.email_format !== undefined) writer.tag(4, WireType.Varint).int32(message.email_format);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCGetEmailTemplate
 */
export const CMsgGCGetEmailTemplate = new CMsgGCGetEmailTemplate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetEmailTemplateResponse$Type extends MessageType<CMsgGCGetEmailTemplateResponse> {
	constructor() {
		super("CMsgGCGetEmailTemplateResponse", [
			{
				no: 1,
				name: "eresult",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "template_exists",
				kind: "scalar",
				localName: "template_exists",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 3,
				name: "template",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCGetEmailTemplateResponse>): CMsgGCGetEmailTemplateResponse {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCGetEmailTemplateResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCGetEmailTemplateResponse,
	): CMsgGCGetEmailTemplateResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 eresult */ 1:
					message.eresult = reader.uint32();
					break;
				case /* optional bool template_exists */ 2:
					message.template_exists = reader.bool();
					break;
				case /* optional string template */ 3:
					message.template = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCGetEmailTemplateResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 eresult = 1; */
		if (message.eresult !== undefined) writer.tag(1, WireType.Varint).uint32(message.eresult);
		/* optional bool template_exists = 2; */
		if (message.template_exists !== undefined) writer.tag(2, WireType.Varint).bool(message.template_exists);
		/* optional string template = 3; */
		if (message.template !== undefined) writer.tag(3, WireType.LengthDelimited).string(message.template);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCGetEmailTemplateResponse
 */
export const CMsgGCGetEmailTemplateResponse = new CMsgGCGetEmailTemplateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMGrantGuestPasses2$Type extends MessageType<CMsgAMGrantGuestPasses2> {
	constructor() {
		super("CMsgAMGrantGuestPasses2", [
			{
				no: 1,
				name: "steam_id",
				kind: "scalar",
				localName: "steam_id",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "package_id",
				kind: "scalar",
				localName: "package_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "passes_to_grant",
				kind: "scalar",
				localName: "passes_to_grant",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 4,
				name: "days_to_expiration",
				kind: "scalar",
				localName: "days_to_expiration",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 5,
				name: "action",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgAMGrantGuestPasses2>): CMsgAMGrantGuestPasses2 {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgAMGrantGuestPasses2>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgAMGrantGuestPasses2,
	): CMsgAMGrantGuestPasses2 {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed64 steam_id */ 1:
					message.steam_id = reader.fixed64().toBigInt();
					break;
				case /* optional uint32 package_id */ 2:
					message.package_id = reader.uint32();
					break;
				case /* optional int32 passes_to_grant */ 3:
					message.passes_to_grant = reader.int32();
					break;
				case /* optional int32 days_to_expiration */ 4:
					message.days_to_expiration = reader.int32();
					break;
				case /* optional int32 action */ 5:
					message.action = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgAMGrantGuestPasses2,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional fixed64 steam_id = 1; */
		if (message.steam_id !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steam_id);
		/* optional uint32 package_id = 2; */
		if (message.package_id !== undefined) writer.tag(2, WireType.Varint).uint32(message.package_id);
		/* optional int32 passes_to_grant = 3; */
		if (message.passes_to_grant !== undefined) writer.tag(3, WireType.Varint).int32(message.passes_to_grant);
		/* optional int32 days_to_expiration = 4; */
		if (message.days_to_expiration !== undefined) writer.tag(4, WireType.Varint).int32(message.days_to_expiration);
		/* optional int32 action = 5; */
		if (message.action !== undefined) writer.tag(5, WireType.Varint).int32(message.action);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgAMGrantGuestPasses2
 */
export const CMsgAMGrantGuestPasses2 = new CMsgAMGrantGuestPasses2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMGrantGuestPasses2Response$Type extends MessageType<CMsgAMGrantGuestPasses2Response> {
	constructor() {
		super("CMsgAMGrantGuestPasses2Response", [
			{
				no: 1,
				name: "eresult",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "passes_granted",
				kind: "scalar",
				localName: "passes_granted",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgAMGrantGuestPasses2Response>): CMsgAMGrantGuestPasses2Response {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgAMGrantGuestPasses2Response>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgAMGrantGuestPasses2Response,
	): CMsgAMGrantGuestPasses2Response {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 eresult */ 1:
					message.eresult = reader.int32();
					break;
				case /* optional int32 passes_granted */ 2:
					message.passes_granted = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgAMGrantGuestPasses2Response,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 eresult = 1; */
		if (message.eresult !== undefined) writer.tag(1, WireType.Varint).int32(message.eresult);
		/* optional int32 passes_granted = 2; */
		if (message.passes_granted !== undefined) writer.tag(2, WireType.Varint).int32(message.passes_granted);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgAMGrantGuestPasses2Response
 */
export const CMsgAMGrantGuestPasses2Response = new CMsgAMGrantGuestPasses2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetPersonaNames$Type extends MessageType<CMsgGCGetPersonaNames> {
	constructor() {
		super("CMsgGCGetPersonaNames", [
			{
				no: 1,
				name: "steamids",
				kind: "scalar",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCGetPersonaNames>): CMsgGCGetPersonaNames {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.steamids = [];
		if (value !== undefined) reflectionMergePartial<CMsgGCGetPersonaNames>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCGetPersonaNames,
	): CMsgGCGetPersonaNames {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated fixed64 steamids */ 1:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; )
							message.steamids.push(reader.fixed64().toBigInt());
					else message.steamids.push(reader.fixed64().toBigInt());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCGetPersonaNames,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated fixed64 steamids = 1; */
		for (let i = 0; i < message.steamids.length; i++) writer.tag(1, WireType.Bit64).fixed64(message.steamids[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCGetPersonaNames
 */
export const CMsgGCGetPersonaNames = new CMsgGCGetPersonaNames$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetPersonaNames_Response$Type extends MessageType<CMsgGCGetPersonaNames_Response> {
	constructor() {
		super("CMsgGCGetPersonaNames_Response", [
			{
				no: 1,
				name: "succeeded_lookups",
				kind: "message",
				localName: "succeeded_lookups",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgGCGetPersonaNames_Response_PersonaName,
			},
			{
				no: 2,
				name: "failed_lookup_steamids",
				kind: "scalar",
				localName: "failed_lookup_steamids",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCGetPersonaNames_Response>): CMsgGCGetPersonaNames_Response {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.succeeded_lookups = [];
		message.failed_lookup_steamids = [];
		if (value !== undefined) reflectionMergePartial<CMsgGCGetPersonaNames_Response>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCGetPersonaNames_Response,
	): CMsgGCGetPersonaNames_Response {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated CMsgGCGetPersonaNames_Response.PersonaName succeeded_lookups */ 1:
					message.succeeded_lookups.push(
						CMsgGCGetPersonaNames_Response_PersonaName.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				case /* repeated fixed64 failed_lookup_steamids */ 2:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; )
							message.failed_lookup_steamids.push(reader.fixed64().toBigInt());
					else message.failed_lookup_steamids.push(reader.fixed64().toBigInt());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCGetPersonaNames_Response,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated CMsgGCGetPersonaNames_Response.PersonaName succeeded_lookups = 1; */
		for (let i = 0; i < message.succeeded_lookups.length; i++)
			CMsgGCGetPersonaNames_Response_PersonaName.internalBinaryWrite(
				message.succeeded_lookups[i],
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* repeated fixed64 failed_lookup_steamids = 2; */
		for (let i = 0; i < message.failed_lookup_steamids.length; i++)
			writer.tag(2, WireType.Bit64).fixed64(message.failed_lookup_steamids[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCGetPersonaNames_Response
 */
export const CMsgGCGetPersonaNames_Response = new CMsgGCGetPersonaNames_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetPersonaNames_Response_PersonaName$Type extends MessageType<CMsgGCGetPersonaNames_Response_PersonaName> {
	constructor() {
		super("CMsgGCGetPersonaNames_Response.PersonaName", [
			{
				no: 1,
				name: "steamid",
				kind: "scalar",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "persona_name",
				kind: "scalar",
				localName: "persona_name",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CMsgGCGetPersonaNames_Response_PersonaName>,
	): CMsgGCGetPersonaNames_Response_PersonaName {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCGetPersonaNames_Response_PersonaName>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCGetPersonaNames_Response_PersonaName,
	): CMsgGCGetPersonaNames_Response_PersonaName {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed64 steamid */ 1:
					message.steamid = reader.fixed64().toBigInt();
					break;
				case /* optional string persona_name */ 2:
					message.persona_name = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCGetPersonaNames_Response_PersonaName,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional fixed64 steamid = 1; */
		if (message.steamid !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steamid);
		/* optional string persona_name = 2; */
		if (message.persona_name !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.persona_name);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCGetPersonaNames_Response.PersonaName
 */
export const CMsgGCGetPersonaNames_Response_PersonaName = new CMsgGCGetPersonaNames_Response_PersonaName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCCheckFriendship$Type extends MessageType<CMsgGCCheckFriendship> {
	constructor() {
		super("CMsgGCCheckFriendship", [
			{
				no: 1,
				name: "steamid_left",
				kind: "scalar",
				localName: "steamid_left",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "steamid_right",
				kind: "scalar",
				localName: "steamid_right",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCCheckFriendship>): CMsgGCCheckFriendship {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCCheckFriendship>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCCheckFriendship,
	): CMsgGCCheckFriendship {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed64 steamid_left */ 1:
					message.steamid_left = reader.fixed64().toBigInt();
					break;
				case /* optional fixed64 steamid_right */ 2:
					message.steamid_right = reader.fixed64().toBigInt();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCCheckFriendship,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional fixed64 steamid_left = 1; */
		if (message.steamid_left !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steamid_left);
		/* optional fixed64 steamid_right = 2; */
		if (message.steamid_right !== undefined) writer.tag(2, WireType.Bit64).fixed64(message.steamid_right);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCCheckFriendship
 */
export const CMsgGCCheckFriendship = new CMsgGCCheckFriendship$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCCheckFriendship_Response$Type extends MessageType<CMsgGCCheckFriendship_Response> {
	constructor() {
		super("CMsgGCCheckFriendship_Response", [
			{
				no: 1,
				name: "success",
				kind: "scalar",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 2,
				name: "found_friendship",
				kind: "scalar",
				localName: "found_friendship",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCCheckFriendship_Response>): CMsgGCCheckFriendship_Response {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCCheckFriendship_Response>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCCheckFriendship_Response,
	): CMsgGCCheckFriendship_Response {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional bool success */ 1:
					message.success = reader.bool();
					break;
				case /* optional bool found_friendship */ 2:
					message.found_friendship = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCCheckFriendship_Response,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional bool success = 1; */
		if (message.success !== undefined) writer.tag(1, WireType.Varint).bool(message.success);
		/* optional bool found_friendship = 2; */
		if (message.found_friendship !== undefined) writer.tag(2, WireType.Varint).bool(message.found_friendship);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCCheckFriendship_Response
 */
export const CMsgGCCheckFriendship_Response = new CMsgGCCheckFriendship_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetAppFriendsList$Type extends MessageType<CMsgGCGetAppFriendsList> {
	constructor() {
		super("CMsgGCGetAppFriendsList", [
			{
				no: 1,
				name: "steamid",
				kind: "scalar",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "include_friendship_timestamps",
				kind: "scalar",
				localName: "include_friendship_timestamps",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 3,
				name: "include_friends_with_no_play_time",
				kind: "scalar",
				localName: "include_friends_with_no_play_time",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCGetAppFriendsList>): CMsgGCGetAppFriendsList {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCGetAppFriendsList>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCGetAppFriendsList,
	): CMsgGCGetAppFriendsList {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed64 steamid */ 1:
					message.steamid = reader.fixed64().toBigInt();
					break;
				case /* optional bool include_friendship_timestamps */ 2:
					message.include_friendship_timestamps = reader.bool();
					break;
				case /* optional bool include_friends_with_no_play_time */ 3:
					message.include_friends_with_no_play_time = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCGetAppFriendsList,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional fixed64 steamid = 1; */
		if (message.steamid !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steamid);
		/* optional bool include_friendship_timestamps = 2; */
		if (message.include_friendship_timestamps !== undefined)
			writer.tag(2, WireType.Varint).bool(message.include_friendship_timestamps);
		/* optional bool include_friends_with_no_play_time = 3; */
		if (message.include_friends_with_no_play_time !== undefined)
			writer.tag(3, WireType.Varint).bool(message.include_friends_with_no_play_time);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCGetAppFriendsList
 */
export const CMsgGCGetAppFriendsList = new CMsgGCGetAppFriendsList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetAppFriendsList_Response$Type extends MessageType<CMsgGCGetAppFriendsList_Response> {
	constructor() {
		super("CMsgGCGetAppFriendsList_Response", [
			{
				no: 1,
				name: "success",
				kind: "scalar",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 2,
				name: "steamids",
				kind: "scalar",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 3,
				name: "friendship_timestamps",
				kind: "scalar",
				localName: "friendship_timestamps",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 7 /*ScalarType.FIXED32*/,
			},
			{
				no: 4,
				name: "last_playtimes",
				kind: "scalar",
				localName: "last_playtimes",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 7 /*ScalarType.FIXED32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCGetAppFriendsList_Response>): CMsgGCGetAppFriendsList_Response {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.steamids = [];
		message.friendship_timestamps = [];
		message.last_playtimes = [];
		if (value !== undefined) reflectionMergePartial<CMsgGCGetAppFriendsList_Response>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCGetAppFriendsList_Response,
	): CMsgGCGetAppFriendsList_Response {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional bool success */ 1:
					message.success = reader.bool();
					break;
				case /* repeated fixed64 steamids */ 2:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; )
							message.steamids.push(reader.fixed64().toBigInt());
					else message.steamids.push(reader.fixed64().toBigInt());
					break;
				case /* repeated fixed32 friendship_timestamps */ 3:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; )
							message.friendship_timestamps.push(reader.fixed32());
					else message.friendship_timestamps.push(reader.fixed32());
					break;
				case /* repeated fixed32 last_playtimes */ 4:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.last_playtimes.push(reader.fixed32());
					else message.last_playtimes.push(reader.fixed32());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCGetAppFriendsList_Response,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional bool success = 1; */
		if (message.success !== undefined) writer.tag(1, WireType.Varint).bool(message.success);
		/* repeated fixed64 steamids = 2; */
		for (let i = 0; i < message.steamids.length; i++) writer.tag(2, WireType.Bit64).fixed64(message.steamids[i]);
		/* repeated fixed32 friendship_timestamps = 3; */
		for (let i = 0; i < message.friendship_timestamps.length; i++)
			writer.tag(3, WireType.Bit32).fixed32(message.friendship_timestamps[i]);
		/* repeated fixed32 last_playtimes = 4; */
		for (let i = 0; i < message.last_playtimes.length; i++)
			writer.tag(4, WireType.Bit32).fixed32(message.last_playtimes[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCGetAppFriendsList_Response
 */
export const CMsgGCGetAppFriendsList_Response = new CMsgGCGetAppFriendsList_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetDirectory$Type extends MessageType<CMsgGCMsgMasterSetDirectory> {
	constructor() {
		super("CMsgGCMsgMasterSetDirectory", [
			{
				no: 1,
				name: "master_dir_index",
				kind: "scalar",
				localName: "master_dir_index",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "dir",
				kind: "message",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgGCMsgMasterSetDirectory_SubGC,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCMsgMasterSetDirectory>): CMsgGCMsgMasterSetDirectory {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.dir = [];
		if (value !== undefined) reflectionMergePartial<CMsgGCMsgMasterSetDirectory>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCMsgMasterSetDirectory,
	): CMsgGCMsgMasterSetDirectory {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 master_dir_index */ 1:
					message.master_dir_index = reader.int32();
					break;
				case /* repeated CMsgGCMsgMasterSetDirectory.SubGC dir */ 2:
					message.dir.push(CMsgGCMsgMasterSetDirectory_SubGC.internalBinaryRead(reader, reader.uint32(), options));
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCMsgMasterSetDirectory,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 master_dir_index = 1; */
		if (message.master_dir_index !== undefined) writer.tag(1, WireType.Varint).int32(message.master_dir_index);
		/* repeated CMsgGCMsgMasterSetDirectory.SubGC dir = 2; */
		for (let i = 0; i < message.dir.length; i++)
			CMsgGCMsgMasterSetDirectory_SubGC.internalBinaryWrite(
				message.dir[i],
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetDirectory
 */
export const CMsgGCMsgMasterSetDirectory = new CMsgGCMsgMasterSetDirectory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetDirectory_SubGC$Type extends MessageType<CMsgGCMsgMasterSetDirectory_SubGC> {
	constructor() {
		super("CMsgGCMsgMasterSetDirectory.SubGC", [
			{
				no: 1,
				name: "dir_index",
				kind: "scalar",
				localName: "dir_index",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "name",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 3,
				name: "box",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 4,
				name: "command_line",
				kind: "scalar",
				localName: "command_line",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 5,
				name: "gc_binary",
				kind: "scalar",
				localName: "gc_binary",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCMsgMasterSetDirectory_SubGC>): CMsgGCMsgMasterSetDirectory_SubGC {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCMsgMasterSetDirectory_SubGC>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCMsgMasterSetDirectory_SubGC,
	): CMsgGCMsgMasterSetDirectory_SubGC {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 dir_index */ 1:
					message.dir_index = reader.int32();
					break;
				case /* optional string name */ 2:
					message.name = reader.string();
					break;
				case /* optional string box */ 3:
					message.box = reader.string();
					break;
				case /* optional string command_line */ 4:
					message.command_line = reader.string();
					break;
				case /* optional string gc_binary */ 5:
					message.gc_binary = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCMsgMasterSetDirectory_SubGC,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 dir_index = 1; */
		if (message.dir_index !== undefined) writer.tag(1, WireType.Varint).int32(message.dir_index);
		/* optional string name = 2; */
		if (message.name !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.name);
		/* optional string box = 3; */
		if (message.box !== undefined) writer.tag(3, WireType.LengthDelimited).string(message.box);
		/* optional string command_line = 4; */
		if (message.command_line !== undefined) writer.tag(4, WireType.LengthDelimited).string(message.command_line);
		/* optional string gc_binary = 5; */
		if (message.gc_binary !== undefined) writer.tag(5, WireType.LengthDelimited).string(message.gc_binary);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetDirectory.SubGC
 */
export const CMsgGCMsgMasterSetDirectory_SubGC = new CMsgGCMsgMasterSetDirectory_SubGC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetDirectory_Response$Type extends MessageType<CMsgGCMsgMasterSetDirectory_Response> {
	constructor() {
		super("CMsgGCMsgMasterSetDirectory_Response", [
			{
				no: 1,
				name: "eresult",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "message",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCMsgMasterSetDirectory_Response>): CMsgGCMsgMasterSetDirectory_Response {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCMsgMasterSetDirectory_Response>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCMsgMasterSetDirectory_Response,
	): CMsgGCMsgMasterSetDirectory_Response {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 eresult */ 1:
					message.eresult = reader.int32();
					break;
				case /* optional string message */ 2:
					message.message = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCMsgMasterSetDirectory_Response,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 eresult = 1; */
		if (message.eresult !== undefined) writer.tag(1, WireType.Varint).int32(message.eresult);
		/* optional string message = 2; */
		if (message.message !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.message);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetDirectory_Response
 */
export const CMsgGCMsgMasterSetDirectory_Response = new CMsgGCMsgMasterSetDirectory_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgWebAPIJobRequestForwardResponse$Type extends MessageType<CMsgGCMsgWebAPIJobRequestForwardResponse> {
	constructor() {
		super("CMsgGCMsgWebAPIJobRequestForwardResponse", [
			{
				no: 1,
				name: "dir_index",
				kind: "scalar",
				localName: "dir_index",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCMsgWebAPIJobRequestForwardResponse>): CMsgGCMsgWebAPIJobRequestForwardResponse {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCMsgWebAPIJobRequestForwardResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCMsgWebAPIJobRequestForwardResponse,
	): CMsgGCMsgWebAPIJobRequestForwardResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 dir_index */ 1:
					message.dir_index = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCMsgWebAPIJobRequestForwardResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 dir_index = 1; */
		if (message.dir_index !== undefined) writer.tag(1, WireType.Varint).int32(message.dir_index);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgWebAPIJobRequestForwardResponse
 */
export const CMsgGCMsgWebAPIJobRequestForwardResponse = new CMsgGCMsgWebAPIJobRequestForwardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCSystemMsg_GetPurchaseTrust_Request$Type extends MessageType<CGCSystemMsg_GetPurchaseTrust_Request> {
	constructor() {
		super("CGCSystemMsg_GetPurchaseTrust_Request", [
			{
				no: 1,
				name: "steamid",
				kind: "scalar",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		]);
	}
	create(value?: PartialMessage<CGCSystemMsg_GetPurchaseTrust_Request>): CGCSystemMsg_GetPurchaseTrust_Request {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CGCSystemMsg_GetPurchaseTrust_Request>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CGCSystemMsg_GetPurchaseTrust_Request,
	): CGCSystemMsg_GetPurchaseTrust_Request {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed64 steamid */ 1:
					message.steamid = reader.fixed64().toBigInt();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CGCSystemMsg_GetPurchaseTrust_Request,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional fixed64 steamid = 1; */
		if (message.steamid !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steamid);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CGCSystemMsg_GetPurchaseTrust_Request
 */
export const CGCSystemMsg_GetPurchaseTrust_Request = new CGCSystemMsg_GetPurchaseTrust_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCSystemMsg_GetPurchaseTrust_Response$Type extends MessageType<CGCSystemMsg_GetPurchaseTrust_Response> {
	constructor() {
		super("CGCSystemMsg_GetPurchaseTrust_Response", [
			{
				no: 1,
				name: "has_prior_purchase_history",
				kind: "scalar",
				localName: "has_prior_purchase_history",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 2,
				name: "has_no_recent_password_resets",
				kind: "scalar",
				localName: "has_no_recent_password_resets",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 3,
				name: "is_wallet_cash_trusted",
				kind: "scalar",
				localName: "is_wallet_cash_trusted",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 4,
				name: "time_all_trusted",
				kind: "scalar",
				localName: "time_all_trusted",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CGCSystemMsg_GetPurchaseTrust_Response>): CGCSystemMsg_GetPurchaseTrust_Response {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CGCSystemMsg_GetPurchaseTrust_Response>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CGCSystemMsg_GetPurchaseTrust_Response,
	): CGCSystemMsg_GetPurchaseTrust_Response {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional bool has_prior_purchase_history */ 1:
					message.has_prior_purchase_history = reader.bool();
					break;
				case /* optional bool has_no_recent_password_resets */ 2:
					message.has_no_recent_password_resets = reader.bool();
					break;
				case /* optional bool is_wallet_cash_trusted */ 3:
					message.is_wallet_cash_trusted = reader.bool();
					break;
				case /* optional uint32 time_all_trusted */ 4:
					message.time_all_trusted = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CGCSystemMsg_GetPurchaseTrust_Response,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional bool has_prior_purchase_history = 1; */
		if (message.has_prior_purchase_history !== undefined)
			writer.tag(1, WireType.Varint).bool(message.has_prior_purchase_history);
		/* optional bool has_no_recent_password_resets = 2; */
		if (message.has_no_recent_password_resets !== undefined)
			writer.tag(2, WireType.Varint).bool(message.has_no_recent_password_resets);
		/* optional bool is_wallet_cash_trusted = 3; */
		if (message.is_wallet_cash_trusted !== undefined)
			writer.tag(3, WireType.Varint).bool(message.is_wallet_cash_trusted);
		/* optional uint32 time_all_trusted = 4; */
		if (message.time_all_trusted !== undefined) writer.tag(4, WireType.Varint).uint32(message.time_all_trusted);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CGCSystemMsg_GetPurchaseTrust_Response
 */
export const CGCSystemMsg_GetPurchaseTrust_Response = new CGCSystemMsg_GetPurchaseTrust_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHAccountVacStatusChange$Type extends MessageType<CMsgGCHAccountVacStatusChange> {
	constructor() {
		super("CMsgGCHAccountVacStatusChange", [
			{
				no: 1,
				name: "steam_id",
				kind: "scalar",
				localName: "steam_id",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "app_id",
				kind: "scalar",
				localName: "app_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "rtime_vacban_starts",
				kind: "scalar",
				localName: "rtime_vacban_starts",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 4,
				name: "is_banned_now",
				kind: "scalar",
				localName: "is_banned_now",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 5,
				name: "is_banned_future",
				kind: "scalar",
				localName: "is_banned_future",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCHAccountVacStatusChange>): CMsgGCHAccountVacStatusChange {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCHAccountVacStatusChange>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCHAccountVacStatusChange,
	): CMsgGCHAccountVacStatusChange {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed64 steam_id */ 1:
					message.steam_id = reader.fixed64().toBigInt();
					break;
				case /* optional uint32 app_id */ 2:
					message.app_id = reader.uint32();
					break;
				case /* optional uint32 rtime_vacban_starts */ 3:
					message.rtime_vacban_starts = reader.uint32();
					break;
				case /* optional bool is_banned_now */ 4:
					message.is_banned_now = reader.bool();
					break;
				case /* optional bool is_banned_future */ 5:
					message.is_banned_future = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCHAccountVacStatusChange,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional fixed64 steam_id = 1; */
		if (message.steam_id !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steam_id);
		/* optional uint32 app_id = 2; */
		if (message.app_id !== undefined) writer.tag(2, WireType.Varint).uint32(message.app_id);
		/* optional uint32 rtime_vacban_starts = 3; */
		if (message.rtime_vacban_starts !== undefined) writer.tag(3, WireType.Varint).uint32(message.rtime_vacban_starts);
		/* optional bool is_banned_now = 4; */
		if (message.is_banned_now !== undefined) writer.tag(4, WireType.Varint).bool(message.is_banned_now);
		/* optional bool is_banned_future = 5; */
		if (message.is_banned_future !== undefined) writer.tag(5, WireType.Varint).bool(message.is_banned_future);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCHAccountVacStatusChange
 */
export const CMsgGCHAccountVacStatusChange = new CMsgGCHAccountVacStatusChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCRoutingInfo$Type extends MessageType<CMsgGCRoutingInfo> {
	constructor() {
		super("CMsgGCRoutingInfo", [
			{
				no: 1,
				name: "dir_index",
				kind: "scalar",
				localName: "dir_index",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "method",
				kind: "enum",
				opt: true,
				T: () => ["CMsgGCRoutingInfo.RoutingMethod", CMsgGCRoutingInfo_RoutingMethod],
			},
			{
				no: 3,
				name: "fallback",
				kind: "enum",
				opt: true,
				T: () => ["CMsgGCRoutingInfo.RoutingMethod", CMsgGCRoutingInfo_RoutingMethod],
			},
			{
				no: 4,
				name: "protobuf_field",
				kind: "scalar",
				localName: "protobuf_field",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 5,
				name: "webapi_param",
				kind: "scalar",
				localName: "webapi_param",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCRoutingInfo>): CMsgGCRoutingInfo {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.dir_index = [];
		if (value !== undefined) reflectionMergePartial<CMsgGCRoutingInfo>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCRoutingInfo,
	): CMsgGCRoutingInfo {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated int32 dir_index */ 1:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.dir_index.push(reader.int32());
					else message.dir_index.push(reader.int32());
					break;
				case /* optional CMsgGCRoutingInfo.RoutingMethod method */ 2:
					message.method = reader.int32();
					break;
				case /* optional CMsgGCRoutingInfo.RoutingMethod fallback */ 3:
					message.fallback = reader.int32();
					break;
				case /* optional uint32 protobuf_field */ 4:
					message.protobuf_field = reader.uint32();
					break;
				case /* optional string webapi_param */ 5:
					message.webapi_param = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CMsgGCRoutingInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* repeated int32 dir_index = 1; */
		for (let i = 0; i < message.dir_index.length; i++) writer.tag(1, WireType.Varint).int32(message.dir_index[i]);
		/* optional CMsgGCRoutingInfo.RoutingMethod method = 2; */
		if (message.method !== undefined) writer.tag(2, WireType.Varint).int32(message.method);
		/* optional CMsgGCRoutingInfo.RoutingMethod fallback = 3; */
		if (message.fallback !== undefined) writer.tag(3, WireType.Varint).int32(message.fallback);
		/* optional uint32 protobuf_field = 4; */
		if (message.protobuf_field !== undefined) writer.tag(4, WireType.Varint).uint32(message.protobuf_field);
		/* optional string webapi_param = 5; */
		if (message.webapi_param !== undefined) writer.tag(5, WireType.LengthDelimited).string(message.webapi_param);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCRoutingInfo
 */
export const CMsgGCRoutingInfo = new CMsgGCRoutingInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetWebAPIRouting$Type extends MessageType<CMsgGCMsgMasterSetWebAPIRouting> {
	constructor() {
		super("CMsgGCMsgMasterSetWebAPIRouting", [
			{
				no: 1,
				name: "entries",
				kind: "message",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgGCMsgMasterSetWebAPIRouting_Entry,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCMsgMasterSetWebAPIRouting>): CMsgGCMsgMasterSetWebAPIRouting {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.entries = [];
		if (value !== undefined) reflectionMergePartial<CMsgGCMsgMasterSetWebAPIRouting>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCMsgMasterSetWebAPIRouting,
	): CMsgGCMsgMasterSetWebAPIRouting {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated CMsgGCMsgMasterSetWebAPIRouting.Entry entries */ 1:
					message.entries.push(
						CMsgGCMsgMasterSetWebAPIRouting_Entry.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCMsgMasterSetWebAPIRouting,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated CMsgGCMsgMasterSetWebAPIRouting.Entry entries = 1; */
		for (let i = 0; i < message.entries.length; i++)
			CMsgGCMsgMasterSetWebAPIRouting_Entry.internalBinaryWrite(
				message.entries[i],
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetWebAPIRouting
 */
export const CMsgGCMsgMasterSetWebAPIRouting = new CMsgGCMsgMasterSetWebAPIRouting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetWebAPIRouting_Entry$Type extends MessageType<CMsgGCMsgMasterSetWebAPIRouting_Entry> {
	constructor() {
		super("CMsgGCMsgMasterSetWebAPIRouting.Entry", [
			{
				no: 1,
				name: "interface_name",
				kind: "scalar",
				localName: "interface_name",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 2,
				name: "method_name",
				kind: "scalar",
				localName: "method_name",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{ no: 3, name: "routing", kind: "message", T: () => CMsgGCRoutingInfo },
		]);
	}
	create(value?: PartialMessage<CMsgGCMsgMasterSetWebAPIRouting_Entry>): CMsgGCMsgMasterSetWebAPIRouting_Entry {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCMsgMasterSetWebAPIRouting_Entry>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCMsgMasterSetWebAPIRouting_Entry,
	): CMsgGCMsgMasterSetWebAPIRouting_Entry {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional string interface_name */ 1:
					message.interface_name = reader.string();
					break;
				case /* optional string method_name */ 2:
					message.method_name = reader.string();
					break;
				case /* optional CMsgGCRoutingInfo routing */ 3:
					message.routing = CMsgGCRoutingInfo.internalBinaryRead(reader, reader.uint32(), options, message.routing);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCMsgMasterSetWebAPIRouting_Entry,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional string interface_name = 1; */
		if (message.interface_name !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.interface_name);
		/* optional string method_name = 2; */
		if (message.method_name !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.method_name);
		/* optional CMsgGCRoutingInfo routing = 3; */
		if (message.routing)
			CMsgGCRoutingInfo.internalBinaryWrite(
				message.routing,
				writer.tag(3, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetWebAPIRouting.Entry
 */
export const CMsgGCMsgMasterSetWebAPIRouting_Entry = new CMsgGCMsgMasterSetWebAPIRouting_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetClientMsgRouting$Type extends MessageType<CMsgGCMsgMasterSetClientMsgRouting> {
	constructor() {
		super("CMsgGCMsgMasterSetClientMsgRouting", [
			{
				no: 1,
				name: "entries",
				kind: "message",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgGCMsgMasterSetClientMsgRouting_Entry,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCMsgMasterSetClientMsgRouting>): CMsgGCMsgMasterSetClientMsgRouting {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.entries = [];
		if (value !== undefined) reflectionMergePartial<CMsgGCMsgMasterSetClientMsgRouting>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCMsgMasterSetClientMsgRouting,
	): CMsgGCMsgMasterSetClientMsgRouting {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated CMsgGCMsgMasterSetClientMsgRouting.Entry entries */ 1:
					message.entries.push(
						CMsgGCMsgMasterSetClientMsgRouting_Entry.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCMsgMasterSetClientMsgRouting,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated CMsgGCMsgMasterSetClientMsgRouting.Entry entries = 1; */
		for (let i = 0; i < message.entries.length; i++)
			CMsgGCMsgMasterSetClientMsgRouting_Entry.internalBinaryWrite(
				message.entries[i],
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetClientMsgRouting
 */
export const CMsgGCMsgMasterSetClientMsgRouting = new CMsgGCMsgMasterSetClientMsgRouting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetClientMsgRouting_Entry$Type extends MessageType<CMsgGCMsgMasterSetClientMsgRouting_Entry> {
	constructor() {
		super("CMsgGCMsgMasterSetClientMsgRouting.Entry", [
			{
				no: 1,
				name: "msg_type",
				kind: "scalar",
				localName: "msg_type",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{ no: 2, name: "routing", kind: "message", T: () => CMsgGCRoutingInfo },
		]);
	}
	create(value?: PartialMessage<CMsgGCMsgMasterSetClientMsgRouting_Entry>): CMsgGCMsgMasterSetClientMsgRouting_Entry {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCMsgMasterSetClientMsgRouting_Entry>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCMsgMasterSetClientMsgRouting_Entry,
	): CMsgGCMsgMasterSetClientMsgRouting_Entry {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 msg_type */ 1:
					message.msg_type = reader.uint32();
					break;
				case /* optional CMsgGCRoutingInfo routing */ 2:
					message.routing = CMsgGCRoutingInfo.internalBinaryRead(reader, reader.uint32(), options, message.routing);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCMsgMasterSetClientMsgRouting_Entry,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 msg_type = 1; */
		if (message.msg_type !== undefined) writer.tag(1, WireType.Varint).uint32(message.msg_type);
		/* optional CMsgGCRoutingInfo routing = 2; */
		if (message.routing)
			CMsgGCRoutingInfo.internalBinaryWrite(
				message.routing,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetClientMsgRouting.Entry
 */
export const CMsgGCMsgMasterSetClientMsgRouting_Entry = new CMsgGCMsgMasterSetClientMsgRouting_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetWebAPIRouting_Response$Type extends MessageType<CMsgGCMsgMasterSetWebAPIRouting_Response> {
	constructor() {
		super("CMsgGCMsgMasterSetWebAPIRouting_Response", [
			{
				no: 1,
				name: "eresult",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCMsgMasterSetWebAPIRouting_Response>): CMsgGCMsgMasterSetWebAPIRouting_Response {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCMsgMasterSetWebAPIRouting_Response>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCMsgMasterSetWebAPIRouting_Response,
	): CMsgGCMsgMasterSetWebAPIRouting_Response {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 eresult */ 1:
					message.eresult = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCMsgMasterSetWebAPIRouting_Response,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 eresult = 1; */
		if (message.eresult !== undefined) writer.tag(1, WireType.Varint).int32(message.eresult);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetWebAPIRouting_Response
 */
export const CMsgGCMsgMasterSetWebAPIRouting_Response = new CMsgGCMsgMasterSetWebAPIRouting_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetClientMsgRouting_Response$Type extends MessageType<CMsgGCMsgMasterSetClientMsgRouting_Response> {
	constructor() {
		super("CMsgGCMsgMasterSetClientMsgRouting_Response", [
			{
				no: 1,
				name: "eresult",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CMsgGCMsgMasterSetClientMsgRouting_Response>,
	): CMsgGCMsgMasterSetClientMsgRouting_Response {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCMsgMasterSetClientMsgRouting_Response>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCMsgMasterSetClientMsgRouting_Response,
	): CMsgGCMsgMasterSetClientMsgRouting_Response {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 eresult */ 1:
					message.eresult = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCMsgMasterSetClientMsgRouting_Response,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 eresult = 1; */
		if (message.eresult !== undefined) writer.tag(1, WireType.Varint).int32(message.eresult);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetClientMsgRouting_Response
 */
export const CMsgGCMsgMasterSetClientMsgRouting_Response = new CMsgGCMsgMasterSetClientMsgRouting_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgSetOptions$Type extends MessageType<CMsgGCMsgSetOptions> {
	constructor() {
		super("CMsgGCMsgSetOptions", [
			{
				no: 1,
				name: "options",
				kind: "enum",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => ["CMsgGCMsgSetOptions.Option", CMsgGCMsgSetOptions_Option],
			},
			{
				no: 2,
				name: "client_msg_ranges",
				kind: "message",
				localName: "client_msg_ranges",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgGCMsgSetOptions_MessageRange,
			},
			{
				no: 3,
				name: "gcsql_version",
				kind: "enum",
				localName: "gcsql_version",
				opt: true,
				T: () => ["CMsgGCMsgSetOptions.GCSQLVersion", CMsgGCMsgSetOptions_GCSQLVersion],
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCMsgSetOptions>): CMsgGCMsgSetOptions {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.options = [];
		message.client_msg_ranges = [];
		if (value !== undefined) reflectionMergePartial<CMsgGCMsgSetOptions>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCMsgSetOptions,
	): CMsgGCMsgSetOptions {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated CMsgGCMsgSetOptions.Option options */ 1:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.options.push(reader.int32());
					else message.options.push(reader.int32());
					break;
				case /* repeated CMsgGCMsgSetOptions.MessageRange client_msg_ranges */ 2:
					message.client_msg_ranges.push(
						CMsgGCMsgSetOptions_MessageRange.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				case /* optional CMsgGCMsgSetOptions.GCSQLVersion gcsql_version */ 3:
					message.gcsql_version = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CMsgGCMsgSetOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* repeated CMsgGCMsgSetOptions.Option options = 1; */
		for (let i = 0; i < message.options.length; i++) writer.tag(1, WireType.Varint).int32(message.options[i]);
		/* repeated CMsgGCMsgSetOptions.MessageRange client_msg_ranges = 2; */
		for (let i = 0; i < message.client_msg_ranges.length; i++)
			CMsgGCMsgSetOptions_MessageRange.internalBinaryWrite(
				message.client_msg_ranges[i],
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgGCMsgSetOptions.GCSQLVersion gcsql_version = 3; */
		if (message.gcsql_version !== undefined) writer.tag(3, WireType.Varint).int32(message.gcsql_version);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgSetOptions
 */
export const CMsgGCMsgSetOptions = new CMsgGCMsgSetOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgSetOptions_MessageRange$Type extends MessageType<CMsgGCMsgSetOptions_MessageRange> {
	constructor() {
		super("CMsgGCMsgSetOptions.MessageRange", [
			{ no: 1, name: "low", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
			{ no: 2, name: "high", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
		]);
	}
	create(value?: PartialMessage<CMsgGCMsgSetOptions_MessageRange>): CMsgGCMsgSetOptions_MessageRange {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.low = 0;
		message.high = 0;
		if (value !== undefined) reflectionMergePartial<CMsgGCMsgSetOptions_MessageRange>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCMsgSetOptions_MessageRange,
	): CMsgGCMsgSetOptions_MessageRange {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* uint32 low */ 1:
					message.low = reader.uint32();
					break;
				case /* uint32 high */ 2:
					message.high = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCMsgSetOptions_MessageRange,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* uint32 low = 1; */
		if (message.low !== 0) writer.tag(1, WireType.Varint).uint32(message.low);
		/* uint32 high = 2; */
		if (message.high !== 0) writer.tag(2, WireType.Varint).uint32(message.high);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgSetOptions.MessageRange
 */
export const CMsgGCMsgSetOptions_MessageRange = new CMsgGCMsgSetOptions_MessageRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHUpdateSession$Type extends MessageType<CMsgGCHUpdateSession> {
	constructor() {
		super("CMsgGCHUpdateSession", [
			{
				no: 1,
				name: "steam_id",
				kind: "scalar",
				localName: "steam_id",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "app_id",
				kind: "scalar",
				localName: "app_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "online",
				kind: "scalar",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 4,
				name: "server_steam_id",
				kind: "scalar",
				localName: "server_steam_id",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 5,
				name: "server_addr",
				kind: "scalar",
				localName: "server_addr",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 6,
				name: "server_port",
				kind: "scalar",
				localName: "server_port",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 7,
				name: "os_type",
				kind: "scalar",
				localName: "os_type",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 8,
				name: "client_addr",
				kind: "scalar",
				localName: "client_addr",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 9,
				name: "extra_fields",
				kind: "message",
				localName: "extra_fields",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgGCHUpdateSession_ExtraField,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCHUpdateSession>): CMsgGCHUpdateSession {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.extra_fields = [];
		if (value !== undefined) reflectionMergePartial<CMsgGCHUpdateSession>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCHUpdateSession,
	): CMsgGCHUpdateSession {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed64 steam_id */ 1:
					message.steam_id = reader.fixed64().toBigInt();
					break;
				case /* optional uint32 app_id */ 2:
					message.app_id = reader.uint32();
					break;
				case /* optional bool online */ 3:
					message.online = reader.bool();
					break;
				case /* optional fixed64 server_steam_id */ 4:
					message.server_steam_id = reader.fixed64().toBigInt();
					break;
				case /* optional uint32 server_addr */ 5:
					message.server_addr = reader.uint32();
					break;
				case /* optional uint32 server_port */ 6:
					message.server_port = reader.uint32();
					break;
				case /* optional uint32 os_type */ 7:
					message.os_type = reader.uint32();
					break;
				case /* optional uint32 client_addr */ 8:
					message.client_addr = reader.uint32();
					break;
				case /* repeated CMsgGCHUpdateSession.ExtraField extra_fields */ 9:
					message.extra_fields.push(
						CMsgGCHUpdateSession_ExtraField.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCHUpdateSession,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional fixed64 steam_id = 1; */
		if (message.steam_id !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steam_id);
		/* optional uint32 app_id = 2; */
		if (message.app_id !== undefined) writer.tag(2, WireType.Varint).uint32(message.app_id);
		/* optional bool online = 3; */
		if (message.online !== undefined) writer.tag(3, WireType.Varint).bool(message.online);
		/* optional fixed64 server_steam_id = 4; */
		if (message.server_steam_id !== undefined) writer.tag(4, WireType.Bit64).fixed64(message.server_steam_id);
		/* optional uint32 server_addr = 5; */
		if (message.server_addr !== undefined) writer.tag(5, WireType.Varint).uint32(message.server_addr);
		/* optional uint32 server_port = 6; */
		if (message.server_port !== undefined) writer.tag(6, WireType.Varint).uint32(message.server_port);
		/* optional uint32 os_type = 7; */
		if (message.os_type !== undefined) writer.tag(7, WireType.Varint).uint32(message.os_type);
		/* optional uint32 client_addr = 8; */
		if (message.client_addr !== undefined) writer.tag(8, WireType.Varint).uint32(message.client_addr);
		/* repeated CMsgGCHUpdateSession.ExtraField extra_fields = 9; */
		for (let i = 0; i < message.extra_fields.length; i++)
			CMsgGCHUpdateSession_ExtraField.internalBinaryWrite(
				message.extra_fields[i],
				writer.tag(9, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCHUpdateSession
 */
export const CMsgGCHUpdateSession = new CMsgGCHUpdateSession$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHUpdateSession_ExtraField$Type extends MessageType<CMsgGCHUpdateSession_ExtraField> {
	constructor() {
		super("CMsgGCHUpdateSession.ExtraField", [
			{
				no: 1,
				name: "name",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 2,
				name: "value",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCHUpdateSession_ExtraField>): CMsgGCHUpdateSession_ExtraField {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCHUpdateSession_ExtraField>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCHUpdateSession_ExtraField,
	): CMsgGCHUpdateSession_ExtraField {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional string name */ 1:
					message.name = reader.string();
					break;
				case /* optional string value */ 2:
					message.value = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCHUpdateSession_ExtraField,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional string name = 1; */
		if (message.name !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.name);
		/* optional string value = 2; */
		if (message.value !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.value);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCHUpdateSession.ExtraField
 */
export const CMsgGCHUpdateSession_ExtraField = new CMsgGCHUpdateSession_ExtraField$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNotificationOfSuspiciousActivity$Type extends MessageType<CMsgNotificationOfSuspiciousActivity> {
	constructor() {
		super("CMsgNotificationOfSuspiciousActivity", [
			{
				no: 1,
				name: "steamid",
				kind: "scalar",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "appid",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "multiple_instances",
				kind: "message",
				localName: "multiple_instances",
				T: () => CMsgNotificationOfSuspiciousActivity_MultipleGameInstances,
			},
		]);
	}
	create(value?: PartialMessage<CMsgNotificationOfSuspiciousActivity>): CMsgNotificationOfSuspiciousActivity {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgNotificationOfSuspiciousActivity>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgNotificationOfSuspiciousActivity,
	): CMsgNotificationOfSuspiciousActivity {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed64 steamid */ 1:
					message.steamid = reader.fixed64().toBigInt();
					break;
				case /* optional uint32 appid */ 2:
					message.appid = reader.uint32();
					break;
				case /* optional CMsgNotificationOfSuspiciousActivity.MultipleGameInstances multiple_instances */ 3:
					message.multiple_instances = CMsgNotificationOfSuspiciousActivity_MultipleGameInstances.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.multiple_instances,
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgNotificationOfSuspiciousActivity,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional fixed64 steamid = 1; */
		if (message.steamid !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steamid);
		/* optional uint32 appid = 2; */
		if (message.appid !== undefined) writer.tag(2, WireType.Varint).uint32(message.appid);
		/* optional CMsgNotificationOfSuspiciousActivity.MultipleGameInstances multiple_instances = 3; */
		if (message.multiple_instances)
			CMsgNotificationOfSuspiciousActivity_MultipleGameInstances.internalBinaryWrite(
				message.multiple_instances,
				writer.tag(3, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgNotificationOfSuspiciousActivity
 */
export const CMsgNotificationOfSuspiciousActivity = new CMsgNotificationOfSuspiciousActivity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNotificationOfSuspiciousActivity_MultipleGameInstances$Type extends MessageType<CMsgNotificationOfSuspiciousActivity_MultipleGameInstances> {
	constructor() {
		super("CMsgNotificationOfSuspiciousActivity.MultipleGameInstances", [
			{
				no: 1,
				name: "app_instance_count",
				kind: "scalar",
				localName: "app_instance_count",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "other_steamids",
				kind: "scalar",
				localName: "other_steamids",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CMsgNotificationOfSuspiciousActivity_MultipleGameInstances>,
	): CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.other_steamids = [];
		if (value !== undefined)
			reflectionMergePartial<CMsgNotificationOfSuspiciousActivity_MultipleGameInstances>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgNotificationOfSuspiciousActivity_MultipleGameInstances,
	): CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 app_instance_count */ 1:
					message.app_instance_count = reader.uint32();
					break;
				case /* repeated fixed64 other_steamids */ 2:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; )
							message.other_steamids.push(reader.fixed64().toBigInt());
					else message.other_steamids.push(reader.fixed64().toBigInt());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgNotificationOfSuspiciousActivity_MultipleGameInstances,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 app_instance_count = 1; */
		if (message.app_instance_count !== undefined) writer.tag(1, WireType.Varint).uint32(message.app_instance_count);
		/* repeated fixed64 other_steamids = 2; */
		for (let i = 0; i < message.other_steamids.length; i++)
			writer.tag(2, WireType.Bit64).fixed64(message.other_steamids[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgNotificationOfSuspiciousActivity.MultipleGameInstances
 */
export const CMsgNotificationOfSuspiciousActivity_MultipleGameInstances =
	new CMsgNotificationOfSuspiciousActivity_MultipleGameInstances$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHVacVerificationChange$Type extends MessageType<CMsgGCHVacVerificationChange> {
	constructor() {
		super("CMsgGCHVacVerificationChange", [
			{
				no: 1,
				name: "steamid",
				kind: "scalar",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "appid",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "is_verified",
				kind: "scalar",
				localName: "is_verified",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCHVacVerificationChange>): CMsgGCHVacVerificationChange {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCHVacVerificationChange>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCHVacVerificationChange,
	): CMsgGCHVacVerificationChange {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed64 steamid */ 1:
					message.steamid = reader.fixed64().toBigInt();
					break;
				case /* optional uint32 appid */ 2:
					message.appid = reader.uint32();
					break;
				case /* optional bool is_verified */ 3:
					message.is_verified = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCHVacVerificationChange,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional fixed64 steamid = 1; */
		if (message.steamid !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steamid);
		/* optional uint32 appid = 2; */
		if (message.appid !== undefined) writer.tag(2, WireType.Varint).uint32(message.appid);
		/* optional bool is_verified = 3; */
		if (message.is_verified !== undefined) writer.tag(3, WireType.Varint).bool(message.is_verified);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCHVacVerificationChange
 */
export const CMsgGCHVacVerificationChange = new CMsgGCHVacVerificationChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCCheckClanMembership$Type extends MessageType<CMsgGCCheckClanMembership> {
	constructor() {
		super("CMsgGCCheckClanMembership", [
			{
				no: 1,
				name: "steamid",
				kind: "scalar",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "clanid",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCCheckClanMembership>): CMsgGCCheckClanMembership {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCCheckClanMembership>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCCheckClanMembership,
	): CMsgGCCheckClanMembership {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed64 steamid */ 1:
					message.steamid = reader.fixed64().toBigInt();
					break;
				case /* optional uint32 clanid */ 2:
					message.clanid = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCCheckClanMembership,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional fixed64 steamid = 1; */
		if (message.steamid !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.steamid);
		/* optional uint32 clanid = 2; */
		if (message.clanid !== undefined) writer.tag(2, WireType.Varint).uint32(message.clanid);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCCheckClanMembership
 */
export const CMsgGCCheckClanMembership = new CMsgGCCheckClanMembership$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCCheckClanMembership_Response$Type extends MessageType<CMsgGCCheckClanMembership_Response> {
	constructor() {
		super("CMsgGCCheckClanMembership_Response", [
			{
				no: 1,
				name: "ismember",
				kind: "scalar",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCCheckClanMembership_Response>): CMsgGCCheckClanMembership_Response {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCCheckClanMembership_Response>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCCheckClanMembership_Response,
	): CMsgGCCheckClanMembership_Response {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional bool ismember */ 1:
					message.ismember = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCCheckClanMembership_Response,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional bool ismember = 1; */
		if (message.ismember !== undefined) writer.tag(1, WireType.Varint).bool(message.ismember);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCCheckClanMembership_Response
 */
export const CMsgGCCheckClanMembership_Response = new CMsgGCCheckClanMembership_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHAppCheersReceived$Type extends MessageType<CMsgGCHAppCheersReceived> {
	constructor() {
		super("CMsgGCHAppCheersReceived", [
			{
				no: 1,
				name: "appid",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "cheer_targets",
				kind: "message",
				localName: "cheer_targets",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgGCHAppCheersReceived_CheerTarget,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCHAppCheersReceived>): CMsgGCHAppCheersReceived {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.cheer_targets = [];
		if (value !== undefined) reflectionMergePartial<CMsgGCHAppCheersReceived>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCHAppCheersReceived,
	): CMsgGCHAppCheersReceived {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 appid */ 1:
					message.appid = reader.uint32();
					break;
				case /* repeated CMsgGCHAppCheersReceived.CheerTarget cheer_targets */ 2:
					message.cheer_targets.push(
						CMsgGCHAppCheersReceived_CheerTarget.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCHAppCheersReceived,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 appid = 1; */
		if (message.appid !== undefined) writer.tag(1, WireType.Varint).uint32(message.appid);
		/* repeated CMsgGCHAppCheersReceived.CheerTarget cheer_targets = 2; */
		for (let i = 0; i < message.cheer_targets.length; i++)
			CMsgGCHAppCheersReceived_CheerTarget.internalBinaryWrite(
				message.cheer_targets[i],
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCHAppCheersReceived
 */
export const CMsgGCHAppCheersReceived = new CMsgGCHAppCheersReceived$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHAppCheersReceived_CheerTypeAmount$Type extends MessageType<CMsgGCHAppCheersReceived_CheerTypeAmount> {
	constructor() {
		super("CMsgGCHAppCheersReceived.CheerTypeAmount", [
			{
				no: 1,
				name: "cheer_type",
				kind: "scalar",
				localName: "cheer_type",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "cheer_amount",
				kind: "scalar",
				localName: "cheer_amount",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCHAppCheersReceived_CheerTypeAmount>): CMsgGCHAppCheersReceived_CheerTypeAmount {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCHAppCheersReceived_CheerTypeAmount>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCHAppCheersReceived_CheerTypeAmount,
	): CMsgGCHAppCheersReceived_CheerTypeAmount {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 cheer_type */ 1:
					message.cheer_type = reader.uint32();
					break;
				case /* optional uint32 cheer_amount */ 2:
					message.cheer_amount = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCHAppCheersReceived_CheerTypeAmount,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 cheer_type = 1; */
		if (message.cheer_type !== undefined) writer.tag(1, WireType.Varint).uint32(message.cheer_type);
		/* optional uint32 cheer_amount = 2; */
		if (message.cheer_amount !== undefined) writer.tag(2, WireType.Varint).uint32(message.cheer_amount);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCHAppCheersReceived.CheerTypeAmount
 */
export const CMsgGCHAppCheersReceived_CheerTypeAmount = new CMsgGCHAppCheersReceived_CheerTypeAmount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHAppCheersReceived_CheerTarget$Type extends MessageType<CMsgGCHAppCheersReceived_CheerTarget> {
	constructor() {
		super("CMsgGCHAppCheersReceived.CheerTarget", [
			{
				no: 1,
				name: "cheer_target",
				kind: "scalar",
				localName: "cheer_target",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "cheer_types",
				kind: "message",
				localName: "cheer_types",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgGCHAppCheersReceived_CheerTypeAmount,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCHAppCheersReceived_CheerTarget>): CMsgGCHAppCheersReceived_CheerTarget {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.cheer_types = [];
		if (value !== undefined) reflectionMergePartial<CMsgGCHAppCheersReceived_CheerTarget>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCHAppCheersReceived_CheerTarget,
	): CMsgGCHAppCheersReceived_CheerTarget {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint64 cheer_target */ 1:
					message.cheer_target = reader.uint64().toBigInt();
					break;
				case /* repeated CMsgGCHAppCheersReceived.CheerTypeAmount cheer_types */ 2:
					message.cheer_types.push(
						CMsgGCHAppCheersReceived_CheerTypeAmount.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCHAppCheersReceived_CheerTarget,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint64 cheer_target = 1; */
		if (message.cheer_target !== undefined) writer.tag(1, WireType.Varint).uint64(message.cheer_target);
		/* repeated CMsgGCHAppCheersReceived.CheerTypeAmount cheer_types = 2; */
		for (let i = 0; i < message.cheer_types.length; i++)
			CMsgGCHAppCheersReceived_CheerTypeAmount.internalBinaryWrite(
				message.cheer_types[i],
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCHAppCheersReceived.CheerTarget
 */
export const CMsgGCHAppCheersReceived_CheerTarget = new CMsgGCHAppCheersReceived_CheerTarget$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHAppCheersGetAllowedTypes$Type extends MessageType<CMsgGCHAppCheersGetAllowedTypes> {
	constructor() {
		super("CMsgGCHAppCheersGetAllowedTypes", [
			{
				no: 1,
				name: "appid",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "cheer_target",
				kind: "scalar",
				localName: "cheer_target",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCHAppCheersGetAllowedTypes>): CMsgGCHAppCheersGetAllowedTypes {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgGCHAppCheersGetAllowedTypes>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCHAppCheersGetAllowedTypes,
	): CMsgGCHAppCheersGetAllowedTypes {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 appid */ 1:
					message.appid = reader.uint32();
					break;
				case /* optional uint64 cheer_target */ 2:
					message.cheer_target = reader.uint64().toBigInt();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCHAppCheersGetAllowedTypes,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 appid = 1; */
		if (message.appid !== undefined) writer.tag(1, WireType.Varint).uint32(message.appid);
		/* optional uint64 cheer_target = 2; */
		if (message.cheer_target !== undefined) writer.tag(2, WireType.Varint).uint64(message.cheer_target);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCHAppCheersGetAllowedTypes
 */
export const CMsgGCHAppCheersGetAllowedTypes = new CMsgGCHAppCheersGetAllowedTypes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHAppCheersGetAllowedTypesResponse$Type extends MessageType<CMsgGCHAppCheersGetAllowedTypesResponse> {
	constructor() {
		super("CMsgGCHAppCheersGetAllowedTypesResponse", [
			{
				no: 1,
				name: "cheer_types_valid_all_users",
				kind: "scalar",
				localName: "cheer_types_valid_all_users",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "cheer_remaps",
				kind: "message",
				localName: "cheer_remaps",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps,
			},
			{
				no: 3,
				name: "cache_duration",
				kind: "scalar",
				localName: "cache_duration",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgGCHAppCheersGetAllowedTypesResponse>): CMsgGCHAppCheersGetAllowedTypesResponse {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.cheer_types_valid_all_users = [];
		message.cheer_remaps = [];
		if (value !== undefined) reflectionMergePartial<CMsgGCHAppCheersGetAllowedTypesResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCHAppCheersGetAllowedTypesResponse,
	): CMsgGCHAppCheersGetAllowedTypesResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated uint32 cheer_types_valid_all_users */ 1:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; )
							message.cheer_types_valid_all_users.push(reader.uint32());
					else message.cheer_types_valid_all_users.push(reader.uint32());
					break;
				case /* repeated CMsgGCHAppCheersGetAllowedTypesResponse.CheerRemaps cheer_remaps */ 2:
					message.cheer_remaps.push(
						CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				case /* optional uint32 cache_duration */ 3:
					message.cache_duration = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCHAppCheersGetAllowedTypesResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated uint32 cheer_types_valid_all_users = 1; */
		for (let i = 0; i < message.cheer_types_valid_all_users.length; i++)
			writer.tag(1, WireType.Varint).uint32(message.cheer_types_valid_all_users[i]);
		/* repeated CMsgGCHAppCheersGetAllowedTypesResponse.CheerRemaps cheer_remaps = 2; */
		for (let i = 0; i < message.cheer_remaps.length; i++)
			CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps.internalBinaryWrite(
				message.cheer_remaps[i],
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional uint32 cache_duration = 3; */
		if (message.cache_duration !== undefined) writer.tag(3, WireType.Varint).uint32(message.cache_duration);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCHAppCheersGetAllowedTypesResponse
 */
export const CMsgGCHAppCheersGetAllowedTypesResponse = new CMsgGCHAppCheersGetAllowedTypesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps$Type extends MessageType<CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps> {
	constructor() {
		super("CMsgGCHAppCheersGetAllowedTypesResponse.CheerRemaps", [
			{
				no: 1,
				name: "original_cheer_type",
				kind: "scalar",
				localName: "original_cheer_type",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "remapped_cheer_type",
				kind: "scalar",
				localName: "remapped_cheer_type",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "account_ids",
				kind: "scalar",
				localName: "account_ids",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps>,
	): CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.account_ids = [];
		if (value !== undefined)
			reflectionMergePartial<CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps,
	): CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 original_cheer_type */ 1:
					message.original_cheer_type = reader.uint32();
					break;
				case /* optional uint32 remapped_cheer_type */ 2:
					message.remapped_cheer_type = reader.uint32();
					break;
				case /* repeated uint32 account_ids */ 3:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; ) message.account_ids.push(reader.uint32());
					else message.account_ids.push(reader.uint32());
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 original_cheer_type = 1; */
		if (message.original_cheer_type !== undefined) writer.tag(1, WireType.Varint).uint32(message.original_cheer_type);
		/* optional uint32 remapped_cheer_type = 2; */
		if (message.remapped_cheer_type !== undefined) writer.tag(2, WireType.Varint).uint32(message.remapped_cheer_type);
		/* repeated uint32 account_ids = 3; */
		for (let i = 0; i < message.account_ids.length; i++) writer.tag(3, WireType.Varint).uint32(message.account_ids[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgGCHAppCheersGetAllowedTypesResponse.CheerRemaps
 */
export const CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps =
	new CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_AddSpecialPayment_Request$Type extends MessageType<CWorkshop_AddSpecialPayment_Request> {
	constructor() {
		super("CWorkshop_AddSpecialPayment_Request", [
			{
				no: 1,
				name: "appid",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "gameitemid",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "date",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 4,
				name: "payment_us_usd",
				kind: "scalar",
				localName: "payment_us_usd",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 5,
				name: "payment_row_usd",
				kind: "scalar",
				localName: "payment_row_usd",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		]);
	}
	create(value?: PartialMessage<CWorkshop_AddSpecialPayment_Request>): CWorkshop_AddSpecialPayment_Request {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CWorkshop_AddSpecialPayment_Request>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CWorkshop_AddSpecialPayment_Request,
	): CWorkshop_AddSpecialPayment_Request {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 appid */ 1:
					message.appid = reader.uint32();
					break;
				case /* optional uint32 gameitemid */ 2:
					message.gameitemid = reader.uint32();
					break;
				case /* optional string date */ 3:
					message.date = reader.string();
					break;
				case /* optional uint64 payment_us_usd */ 4:
					message.payment_us_usd = reader.uint64().toBigInt();
					break;
				case /* optional uint64 payment_row_usd */ 5:
					message.payment_row_usd = reader.uint64().toBigInt();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CWorkshop_AddSpecialPayment_Request,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 appid = 1; */
		if (message.appid !== undefined) writer.tag(1, WireType.Varint).uint32(message.appid);
		/* optional uint32 gameitemid = 2; */
		if (message.gameitemid !== undefined) writer.tag(2, WireType.Varint).uint32(message.gameitemid);
		/* optional string date = 3; */
		if (message.date !== undefined) writer.tag(3, WireType.LengthDelimited).string(message.date);
		/* optional uint64 payment_us_usd = 4; */
		if (message.payment_us_usd !== undefined) writer.tag(4, WireType.Varint).uint64(message.payment_us_usd);
		/* optional uint64 payment_row_usd = 5; */
		if (message.payment_row_usd !== undefined) writer.tag(5, WireType.Varint).uint64(message.payment_row_usd);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CWorkshop_AddSpecialPayment_Request
 */
export const CWorkshop_AddSpecialPayment_Request = new CWorkshop_AddSpecialPayment_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_AddSpecialPayment_Response$Type extends MessageType<CWorkshop_AddSpecialPayment_Response> {
	constructor() {
		super("CWorkshop_AddSpecialPayment_Response", []);
	}
	create(value?: PartialMessage<CWorkshop_AddSpecialPayment_Response>): CWorkshop_AddSpecialPayment_Response {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CWorkshop_AddSpecialPayment_Response>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CWorkshop_AddSpecialPayment_Response,
	): CWorkshop_AddSpecialPayment_Response {
		return target ?? this.create();
	}
	internalBinaryWrite(
		message: CWorkshop_AddSpecialPayment_Response,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CWorkshop_AddSpecialPayment_Response
 */
export const CWorkshop_AddSpecialPayment_Response = new CWorkshop_AddSpecialPayment_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_GetSpecialPayments_Request$Type extends MessageType<CWorkshop_GetSpecialPayments_Request> {
	constructor() {
		super("CWorkshop_GetSpecialPayments_Request", [
			{
				no: 1,
				name: "appid",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "gameitemid",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "date",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		]);
	}
	create(value?: PartialMessage<CWorkshop_GetSpecialPayments_Request>): CWorkshop_GetSpecialPayments_Request {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CWorkshop_GetSpecialPayments_Request>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CWorkshop_GetSpecialPayments_Request,
	): CWorkshop_GetSpecialPayments_Request {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 appid */ 1:
					message.appid = reader.uint32();
					break;
				case /* optional uint32 gameitemid */ 2:
					message.gameitemid = reader.uint32();
					break;
				case /* optional string date */ 3:
					message.date = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CWorkshop_GetSpecialPayments_Request,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 appid = 1; */
		if (message.appid !== undefined) writer.tag(1, WireType.Varint).uint32(message.appid);
		/* optional uint32 gameitemid = 2; */
		if (message.gameitemid !== undefined) writer.tag(2, WireType.Varint).uint32(message.gameitemid);
		/* optional string date = 3; */
		if (message.date !== undefined) writer.tag(3, WireType.LengthDelimited).string(message.date);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CWorkshop_GetSpecialPayments_Request
 */
export const CWorkshop_GetSpecialPayments_Request = new CWorkshop_GetSpecialPayments_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_GetSpecialPayments_Response$Type extends MessageType<CWorkshop_GetSpecialPayments_Response> {
	constructor() {
		super("CWorkshop_GetSpecialPayments_Response", [
			{
				no: 1,
				name: "special_payments",
				kind: "message",
				localName: "special_payments",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CWorkshop_GetSpecialPayments_Response_SpecialPayment,
			},
		]);
	}
	create(value?: PartialMessage<CWorkshop_GetSpecialPayments_Response>): CWorkshop_GetSpecialPayments_Response {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.special_payments = [];
		if (value !== undefined) reflectionMergePartial<CWorkshop_GetSpecialPayments_Response>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CWorkshop_GetSpecialPayments_Response,
	): CWorkshop_GetSpecialPayments_Response {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated CWorkshop_GetSpecialPayments_Response.SpecialPayment special_payments */ 1:
					message.special_payments.push(
						CWorkshop_GetSpecialPayments_Response_SpecialPayment.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CWorkshop_GetSpecialPayments_Response,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated CWorkshop_GetSpecialPayments_Response.SpecialPayment special_payments = 1; */
		for (let i = 0; i < message.special_payments.length; i++)
			CWorkshop_GetSpecialPayments_Response_SpecialPayment.internalBinaryWrite(
				message.special_payments[i],
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CWorkshop_GetSpecialPayments_Response
 */
export const CWorkshop_GetSpecialPayments_Response = new CWorkshop_GetSpecialPayments_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_GetSpecialPayments_Response_SpecialPayment$Type extends MessageType<CWorkshop_GetSpecialPayments_Response_SpecialPayment> {
	constructor() {
		super("CWorkshop_GetSpecialPayments_Response.SpecialPayment", [
			{
				no: 1,
				name: "appid",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "gameitemid",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "date",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 4,
				name: "net_payment_us_usd",
				kind: "scalar",
				localName: "net_payment_us_usd",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 5,
				name: "net_payment_row_usd",
				kind: "scalar",
				localName: "net_payment_row_usd",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CWorkshop_GetSpecialPayments_Response_SpecialPayment>,
	): CWorkshop_GetSpecialPayments_Response_SpecialPayment {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined)
			reflectionMergePartial<CWorkshop_GetSpecialPayments_Response_SpecialPayment>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CWorkshop_GetSpecialPayments_Response_SpecialPayment,
	): CWorkshop_GetSpecialPayments_Response_SpecialPayment {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 appid */ 1:
					message.appid = reader.uint32();
					break;
				case /* optional uint32 gameitemid */ 2:
					message.gameitemid = reader.uint32();
					break;
				case /* optional string date */ 3:
					message.date = reader.string();
					break;
				case /* optional uint64 net_payment_us_usd */ 4:
					message.net_payment_us_usd = reader.uint64().toBigInt();
					break;
				case /* optional uint64 net_payment_row_usd */ 5:
					message.net_payment_row_usd = reader.uint64().toBigInt();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CWorkshop_GetSpecialPayments_Response_SpecialPayment,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 appid = 1; */
		if (message.appid !== undefined) writer.tag(1, WireType.Varint).uint32(message.appid);
		/* optional uint32 gameitemid = 2; */
		if (message.gameitemid !== undefined) writer.tag(2, WireType.Varint).uint32(message.gameitemid);
		/* optional string date = 3; */
		if (message.date !== undefined) writer.tag(3, WireType.LengthDelimited).string(message.date);
		/* optional uint64 net_payment_us_usd = 4; */
		if (message.net_payment_us_usd !== undefined) writer.tag(4, WireType.Varint).uint64(message.net_payment_us_usd);
		/* optional uint64 net_payment_row_usd = 5; */
		if (message.net_payment_row_usd !== undefined) writer.tag(5, WireType.Varint).uint64(message.net_payment_row_usd);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CWorkshop_GetSpecialPayments_Response.SpecialPayment
 */
export const CWorkshop_GetSpecialPayments_Response_SpecialPayment =
	new CWorkshop_GetSpecialPayments_Response_SpecialPayment$Type();

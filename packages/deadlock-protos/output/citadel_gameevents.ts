// @generated by protobuf-ts 2.9.4 with parameter use_proto_field_name
// @generated from protobuf file "citadel_gameevents.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CMsgQAngle } from "./networkbasetypes.js";
import { CMsgVector } from "./networkbasetypes.js";
/**
 * @generated from protobuf message CMsgFireBullets
 */
export interface CMsgFireBullets {
	/**
	 * @generated from protobuf field: optional CMsgVector origin = 1;
	 */
	origin?: CMsgVector;
	/**
	 * @generated from protobuf field: optional CMsgQAngle angles = 2;
	 */
	angles?: CMsgQAngle;
	/**
	 * @generated from protobuf field: optional uint32 seed = 4;
	 */
	seed?: number;
	/**
	 * @generated from protobuf field: optional int32 shooter_entity = 5;
	 */
	shooter_entity?: number;
	/**
	 * @generated from protobuf field: optional int32 ability = 7;
	 */
	ability?: number;
	/**
	 * @generated from protobuf field: optional float penetration_percent = 8;
	 */
	penetration_percent?: number;
	/**
	 * @generated from protobuf field: optional float spread = 9;
	 */
	spread?: number;
	/**
	 * @generated from protobuf field: optional bool fired_from_gun = 10;
	 */
	fired_from_gun?: boolean;
	/**
	 * @generated from protobuf field: optional uint32 bullets_override = 11;
	 */
	bullets_override?: number;
	/**
	 * @generated from protobuf field: optional CMsgFireBullets.TracerAssignment tracer_replacement = 12;
	 */
	tracer_replacement?: CMsgFireBullets_TracerAssignment;
	/**
	 * @generated from protobuf field: repeated CMsgFireBullets.TracerAssignment tracer_additional = 13;
	 */
	tracer_additional: CMsgFireBullets_TracerAssignment[];
	/**
	 * @generated from protobuf field: optional CMsgQAngle angles_original = 14;
	 */
	angles_original?: CMsgQAngle;
	/**
	 * @generated from protobuf field: optional uint32 weapon_subclass_id = 15;
	 */
	weapon_subclass_id?: number;
	/**
	 * @generated from protobuf field: optional uint32 shot_number = 16;
	 */
	shot_number?: number;
	/**
	 * @generated from protobuf field: optional int32 ignore_entity = 17;
	 */
	ignore_entity?: number;
	/**
	 * @generated from protobuf field: optional float max_range = 18;
	 */
	max_range?: number;
}
/**
 * @generated from protobuf message CMsgFireBullets.TracerAssignment
 */
export interface CMsgFireBullets_TracerAssignment {
	/**
	 * @generated from protobuf field: optional uint64 tracer_resource_id = 1;
	 */
	tracer_resource_id?: bigint;
	/**
	 * @generated from protobuf field: optional uint32 bullet_indicies = 2;
	 */
	bullet_indicies?: number;
}
/**
 * @generated from protobuf message CMsgBulletImpact
 */
export interface CMsgBulletImpact {
	/**
	 * @generated from protobuf field: optional CMsgVector trace_start = 1;
	 */
	trace_start?: CMsgVector;
	/**
	 * @generated from protobuf field: optional CMsgVector impact_origin = 2;
	 */
	impact_origin?: CMsgVector;
	/**
	 * @generated from protobuf field: optional CMsgVector surface_normal = 3;
	 */
	surface_normal?: CMsgVector;
	/**
	 * @generated from protobuf field: optional uint32 damage = 4;
	 */
	damage?: number;
	/**
	 * @generated from protobuf field: optional uint32 surface_type = 5;
	 */
	surface_type?: number;
	/**
	 * @generated from protobuf field: optional int32 ability_entindex = 7;
	 */
	ability_entindex?: number;
	/**
	 * @generated from protobuf field: optional int32 impacted_entindex = 8;
	 */
	impacted_entindex?: number;
	/**
	 * @generated from protobuf field: optional uint32 impacted_hitbox = 9;
	 */
	impacted_hitbox?: number;
	/**
	 * @generated from protobuf field: optional uint32 weapon_subclass_id = 10;
	 */
	weapon_subclass_id?: number;
	/**
	 * @generated from protobuf field: optional int32 shooter_entindex = 11;
	 */
	shooter_entindex?: number;
}
/**
 * @generated from protobuf message CMsgPlayerAnimEvent
 */
export interface CMsgPlayerAnimEvent {
	/**
	 * @generated from protobuf field: optional fixed32 player = 1;
	 */
	player?: number;
	/**
	 * @generated from protobuf field: optional uint32 event = 2;
	 */
	event?: number;
	/**
	 * @generated from protobuf field: optional int32 data = 3;
	 */
	data?: number;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager
 */
export interface CMsgParticleSystemManager {
	/**
	 * @generated from protobuf field: PARTICLE_SYSTEM_MANAGER_MESSAGE type = 1;
	 */
	type: PARTICLE_SYSTEM_MANAGER_MESSAGE;
	/**
	 * @generated from protobuf field: uint32 index = 2;
	 */
	index: number;
	/**
	 * @generated from protobuf field: optional CMsgParticleSystemManager.CreateParticle create_particle = 3;
	 */
	create_particle?: CMsgParticleSystemManager_CreateParticle;
	/**
	 * @generated from protobuf field: optional CMsgParticleSystemManager.DestroyParticle destroy_particle = 4;
	 */
	destroy_particle?: CMsgParticleSystemManager_DestroyParticle;
	/**
	 * @generated from protobuf field: optional CMsgParticleSystemManager.DestroyParticleInvolving destroy_particle_involving = 5;
	 */
	destroy_particle_involving?: CMsgParticleSystemManager_DestroyParticleInvolving;
	/**
	 * @generated from protobuf field: optional CMsgParticleSystemManager.ReleaseParticleIndex release_particle_index = 6;
	 */
	release_particle_index?: CMsgParticleSystemManager_ReleaseParticleIndex;
	/**
	 * @generated from protobuf field: optional CMsgParticleSystemManager.UpdateParticle update_particle = 7;
	 */
	update_particle?: CMsgParticleSystemManager_UpdateParticle;
	/**
	 * @generated from protobuf field: optional CMsgParticleSystemManager.UpdateParticleFwd update_particle_fwd = 8;
	 */
	update_particle_fwd?: CMsgParticleSystemManager_UpdateParticleFwd;
	/**
	 * @generated from protobuf field: optional CMsgParticleSystemManager.UpdateParticleOrient update_particle_orient = 9;
	 */
	update_particle_orient?: CMsgParticleSystemManager_UpdateParticleOrient;
	/**
	 * @generated from protobuf field: optional CMsgParticleSystemManager.UpdateParticleFallback update_particle_fallback = 10;
	 */
	update_particle_fallback?: CMsgParticleSystemManager_UpdateParticleFallback;
	/**
	 * @generated from protobuf field: optional CMsgParticleSystemManager.UpdateParticleOffset update_particle_offset = 11;
	 */
	update_particle_offset?: CMsgParticleSystemManager_UpdateParticleOffset;
	/**
	 * @generated from protobuf field: optional CMsgParticleSystemManager.UpdateParticleEnt update_particle_ent = 12;
	 */
	update_particle_ent?: CMsgParticleSystemManager_UpdateParticleEnt;
	/**
	 * @generated from protobuf field: optional CMsgParticleSystemManager.UpdateParticleFrozen update_particle_frozen = 13;
	 */
	update_particle_frozen?: CMsgParticleSystemManager_UpdateParticleFrozen;
	/**
	 * @generated from protobuf field: optional CMsgParticleSystemManager.UpdateParticleShouldDraw update_particle_should_draw = 14;
	 */
	update_particle_should_draw?: CMsgParticleSystemManager_UpdateParticleShouldDraw;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.CreateParticle
 */
export interface CMsgParticleSystemManager_CreateParticle {
	/**
	 * @generated from protobuf field: optional fixed64 particle_name_index = 1;
	 */
	particle_name_index?: bigint;
	/**
	 * @generated from protobuf field: optional int32 attach_type = 2;
	 */
	attach_type?: number;
	/**
	 * @generated from protobuf field: optional uint32 entity_handle = 3;
	 */
	entity_handle?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector position = 4;
	 */
	position?: CMsgVector;
	/**
	 * @generated from protobuf field: optional CMsgQAngle angles = 5;
	 */
	angles?: CMsgQAngle;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.DestroyParticle
 */
export interface CMsgParticleSystemManager_DestroyParticle {
	/**
	 * @generated from protobuf field: optional bool destroy_immediately = 1;
	 */
	destroy_immediately?: boolean;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.DestroyParticleInvolving
 */
export interface CMsgParticleSystemManager_DestroyParticleInvolving {
	/**
	 * @generated from protobuf field: optional bool destroy_immediately = 1;
	 */
	destroy_immediately?: boolean;
	/**
	 * @generated from protobuf field: optional uint32 entity_handle = 3;
	 */
	entity_handle?: number;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.ReleaseParticleIndex
 */
export interface CMsgParticleSystemManager_ReleaseParticleIndex {}
/**
 * @generated from protobuf message CMsgParticleSystemManager.UpdateParticle
 */
export interface CMsgParticleSystemManager_UpdateParticle {
	/**
	 * @generated from protobuf field: optional int32 control_point = 1;
	 */
	control_point?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector position = 2;
	 */
	position?: CMsgVector;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.UpdateParticleFwd
 */
export interface CMsgParticleSystemManager_UpdateParticleFwd {
	/**
	 * @generated from protobuf field: optional int32 control_point = 1;
	 */
	control_point?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector forward = 2;
	 */
	forward?: CMsgVector;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.UpdateParticleOrient
 */
export interface CMsgParticleSystemManager_UpdateParticleOrient {
	/**
	 * @generated from protobuf field: optional int32 control_point = 1;
	 */
	control_point?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector forward = 2;
	 */
	forward?: CMsgVector;
	/**
	 * @generated from protobuf field: optional CMsgVector left = 3;
	 */
	left?: CMsgVector;
	/**
	 * @generated from protobuf field: optional CMsgVector up = 4;
	 */
	up?: CMsgVector;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.UpdateParticleFallback
 */
export interface CMsgParticleSystemManager_UpdateParticleFallback {
	/**
	 * @generated from protobuf field: optional int32 control_point = 1;
	 */
	control_point?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector position = 2;
	 */
	position?: CMsgVector;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.UpdateParticleEnt
 */
export interface CMsgParticleSystemManager_UpdateParticleEnt {
	/**
	 * @generated from protobuf field: optional int32 control_point = 1;
	 */
	control_point?: number;
	/**
	 * @generated from protobuf field: optional uint32 entity_handle = 2;
	 */
	entity_handle?: number;
	/**
	 * @generated from protobuf field: optional int32 attach_type = 3;
	 */
	attach_type?: number;
	/**
	 * @generated from protobuf field: optional int32 attachment = 4;
	 */
	attachment?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector fallback_position = 5;
	 */
	fallback_position?: CMsgVector;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.UpdateParticleOffset
 */
export interface CMsgParticleSystemManager_UpdateParticleOffset {
	/**
	 * @generated from protobuf field: optional int32 control_point = 1;
	 */
	control_point?: number;
	/**
	 * @generated from protobuf field: optional CMsgVector origin_offset = 2;
	 */
	origin_offset?: CMsgVector;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.UpdateParticleFrozen
 */
export interface CMsgParticleSystemManager_UpdateParticleFrozen {
	/**
	 * @generated from protobuf field: optional bool set_frozen = 1;
	 */
	set_frozen?: boolean;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.UpdateParticleShouldDraw
 */
export interface CMsgParticleSystemManager_UpdateParticleShouldDraw {
	/**
	 * @generated from protobuf field: optional bool should_draw = 1;
	 */
	should_draw?: boolean;
}
/**
 * @generated from protobuf message CMsgScreenTextPretty
 */
export interface CMsgScreenTextPretty {
	/**
	 * @generated from protobuf field: optional float x_pos = 1;
	 */
	x_pos?: number;
	/**
	 * @generated from protobuf field: optional float y_pos = 2;
	 */
	y_pos?: number;
	/**
	 * @generated from protobuf field: optional int32 line = 3;
	 */
	line?: number;
	/**
	 * @generated from protobuf field: optional string text = 4;
	 */
	text?: string;
	/**
	 * @generated from protobuf field: optional int32 r = 5;
	 */
	r?: number;
	/**
	 * @generated from protobuf field: optional int32 g = 6;
	 */
	g?: number;
	/**
	 * @generated from protobuf field: optional int32 b = 7;
	 */
	b?: number;
	/**
	 * @generated from protobuf field: optional int32 a = 8;
	 */
	a?: number;
	/**
	 * @generated from protobuf field: optional float duration = 9;
	 */
	duration?: number;
	/**
	 * @generated from protobuf field: optional string font_name = 10;
	 */
	font_name?: string;
	/**
	 * @generated from protobuf field: optional int32 font_size = 11;
	 */
	font_size?: number;
	/**
	 * @generated from protobuf field: optional bool bold_font = 12;
	 */
	bold_font?: boolean;
}
/**
 * @generated from protobuf message CMsgServerRequestedTracer
 */
export interface CMsgServerRequestedTracer {
	/**
	 * @generated from protobuf field: optional CMsgVector origin = 1;
	 */
	origin?: CMsgVector;
	/**
	 * @generated from protobuf field: optional CMsgVector end = 2;
	 */
	end?: CMsgVector;
	/**
	 * @generated from protobuf field: optional int32 weaponid = 3;
	 */
	weaponid?: number;
	/**
	 * @generated from protobuf field: optional uint32 entity_handle = 4;
	 */
	entity_handle?: number;
	/**
	 * @generated from protobuf field: optional float dps = 5;
	 */
	dps?: number;
}
/**
 * @generated from protobuf message CMsgEnableSatVolumesEvent
 */
export interface CMsgEnableSatVolumesEvent {
	/**
	 * @generated from protobuf field: optional uint32 mode = 1;
	 */
	mode?: number;
	/**
	 * @generated from protobuf field: optional float desat_amount = 2;
	 */
	desat_amount?: number;
	/**
	 * @generated from protobuf field: optional fixed32 sat_tint = 3;
	 */
	sat_tint?: number;
	/**
	 * @generated from protobuf field: optional fixed32 desat_tint = 4;
	 */
	desat_tint?: number;
	/**
	 * @generated from protobuf field: optional fixed32 outline_color = 5;
	 */
	outline_color?: number;
}
/**
 * @generated from protobuf message CMsgPlaceSatVolumeEvent
 */
export interface CMsgPlaceSatVolumeEvent {
	/**
	 * @generated from protobuf field: optional CMsgVector position = 1;
	 */
	position?: CMsgVector;
	/**
	 * @generated from protobuf field: optional CMsgVector direction = 2;
	 */
	direction?: CMsgVector;
	/**
	 * @generated from protobuf field: optional float radius = 3;
	 */
	radius?: number;
	/**
	 * @generated from protobuf field: optional float falloff_distance = 4;
	 */
	falloff_distance?: number;
	/**
	 * @generated from protobuf field: optional float theta_dot = 5;
	 */
	theta_dot?: number;
	/**
	 * @generated from protobuf field: optional float phi_dot = 6;
	 */
	phi_dot?: number;
	/**
	 * @generated from protobuf field: optional uint32 entity_handle = 7;
	 */
	entity_handle?: number;
	/**
	 * @generated from protobuf field: optional uint32 attachment_handle = 8;
	 */
	attachment_handle?: number;
	/**
	 * @generated from protobuf field: optional uint32 type = 9;
	 */
	type?: number;
	/**
	 * @generated from protobuf field: optional int32 volume_id = 10;
	 */
	volume_id?: number;
}
/**
 * @generated from protobuf message CMsgRemoveSatVolumeEvent
 */
export interface CMsgRemoveSatVolumeEvent {
	/**
	 * @generated from protobuf field: optional int32 volume_id = 1;
	 */
	volume_id?: number;
}
/**
 * @generated from protobuf message CMsgDisableSatVolumesEvent
 */
export interface CMsgDisableSatVolumesEvent {}
/**
 * @generated from protobuf enum ECitadelGameEvents
 */
export enum ECitadelGameEvents {
	/**
	 * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
	 */
	UNSPECIFIED$ = 0,
	/**
	 * @generated from protobuf enum value: GE_FireBullets = 450;
	 */
	GE_FireBullets = 450,
	/**
	 * @generated from protobuf enum value: GE_PlayerAnimEvent = 451;
	 */
	GE_PlayerAnimEvent = 451,
	/**
	 * @generated from protobuf enum value: GE_ParticleSystemManager = 458;
	 */
	GE_ParticleSystemManager = 458,
	/**
	 * @generated from protobuf enum value: GE_ScreenTextPretty = 459;
	 */
	GE_ScreenTextPretty = 459,
	/**
	 * @generated from protobuf enum value: GE_ServerRequestedTracer = 460;
	 */
	GE_ServerRequestedTracer = 460,
	/**
	 * @generated from protobuf enum value: GE_BulletImpact = 461;
	 */
	GE_BulletImpact = 461,
	/**
	 * @generated from protobuf enum value: GE_EnableSatVolumesEvent = 462;
	 */
	GE_EnableSatVolumesEvent = 462,
	/**
	 * @generated from protobuf enum value: GE_PlaceSatVolumeEvent = 463;
	 */
	GE_PlaceSatVolumeEvent = 463,
	/**
	 * @generated from protobuf enum value: GE_DisableSatVolumesEvent = 464;
	 */
	GE_DisableSatVolumesEvent = 464,
	/**
	 * @generated from protobuf enum value: GE_RemoveSatVolumeEvent = 465;
	 */
	GE_RemoveSatVolumeEvent = 465,
}
/**
 * @generated from protobuf enum PARTICLE_SYSTEM_MANAGER_MESSAGE
 */
export enum PARTICLE_SYSTEM_MANAGER_MESSAGE {
	/**
	 * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_CREATE = 0;
	 */
	PARTICLE_SYSTEM_MANAGER_EVENT_CREATE = 0,
	/**
	 * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_DESTROY = 1;
	 */
	PARTICLE_SYSTEM_MANAGER_EVENT_DESTROY = 1,
	/**
	 * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_DESTROY_INVOLVING = 2;
	 */
	PARTICLE_SYSTEM_MANAGER_EVENT_DESTROY_INVOLVING = 2,
	/**
	 * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_RELEASE = 3;
	 */
	PARTICLE_SYSTEM_MANAGER_EVENT_RELEASE = 3,
	/**
	 * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE = 4;
	 */
	PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE = 4,
	/**
	 * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FORWARD = 5;
	 */
	PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FORWARD = 5,
	/**
	 * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_ORIENTATION = 6;
	 */
	PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_ORIENTATION = 6,
	/**
	 * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FALLBACK = 7;
	 */
	PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FALLBACK = 7,
	/**
	 * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_ENT = 8;
	 */
	PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_ENT = 8,
	/**
	 * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_OFFSET = 9;
	 */
	PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_OFFSET = 9,
	/**
	 * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FROZEN = 10;
	 */
	PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FROZEN = 10,
	/**
	 * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_SHOULD_DRAW = 11;
	 */
	PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_SHOULD_DRAW = 11,
}
// @generated message type with reflection information, may provide speed optimized methods
class CMsgFireBullets$Type extends MessageType<CMsgFireBullets> {
	constructor() {
		super("CMsgFireBullets", [
			{ no: 1, name: "origin", kind: "message", T: () => CMsgVector },
			{ no: 2, name: "angles", kind: "message", T: () => CMsgQAngle },
			{
				no: 4,
				name: "seed",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 5,
				name: "shooter_entity",
				kind: "scalar",
				localName: "shooter_entity",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 7,
				name: "ability",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 8,
				name: "penetration_percent",
				kind: "scalar",
				localName: "penetration_percent",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 9,
				name: "spread",
				kind: "scalar",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 10,
				name: "fired_from_gun",
				kind: "scalar",
				localName: "fired_from_gun",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 11,
				name: "bullets_override",
				kind: "scalar",
				localName: "bullets_override",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 12,
				name: "tracer_replacement",
				kind: "message",
				localName: "tracer_replacement",
				T: () => CMsgFireBullets_TracerAssignment,
			},
			{
				no: 13,
				name: "tracer_additional",
				kind: "message",
				localName: "tracer_additional",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CMsgFireBullets_TracerAssignment,
			},
			{
				no: 14,
				name: "angles_original",
				kind: "message",
				localName: "angles_original",
				T: () => CMsgQAngle,
			},
			{
				no: 15,
				name: "weapon_subclass_id",
				kind: "scalar",
				localName: "weapon_subclass_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 16,
				name: "shot_number",
				kind: "scalar",
				localName: "shot_number",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 17,
				name: "ignore_entity",
				kind: "scalar",
				localName: "ignore_entity",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 18,
				name: "max_range",
				kind: "scalar",
				localName: "max_range",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgFireBullets>): CMsgFireBullets {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.tracer_additional = [];
		if (value !== undefined) reflectionMergePartial<CMsgFireBullets>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgFireBullets,
	): CMsgFireBullets {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional CMsgVector origin */ 1:
					message.origin = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.origin);
					break;
				case /* optional CMsgQAngle angles */ 2:
					message.angles = CMsgQAngle.internalBinaryRead(reader, reader.uint32(), options, message.angles);
					break;
				case /* optional uint32 seed */ 4:
					message.seed = reader.uint32();
					break;
				case /* optional int32 shooter_entity */ 5:
					message.shooter_entity = reader.int32();
					break;
				case /* optional int32 ability */ 7:
					message.ability = reader.int32();
					break;
				case /* optional float penetration_percent */ 8:
					message.penetration_percent = reader.float();
					break;
				case /* optional float spread */ 9:
					message.spread = reader.float();
					break;
				case /* optional bool fired_from_gun */ 10:
					message.fired_from_gun = reader.bool();
					break;
				case /* optional uint32 bullets_override */ 11:
					message.bullets_override = reader.uint32();
					break;
				case /* optional CMsgFireBullets.TracerAssignment tracer_replacement */ 12:
					message.tracer_replacement = CMsgFireBullets_TracerAssignment.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.tracer_replacement,
					);
					break;
				case /* repeated CMsgFireBullets.TracerAssignment tracer_additional */ 13:
					message.tracer_additional.push(
						CMsgFireBullets_TracerAssignment.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				case /* optional CMsgQAngle angles_original */ 14:
					message.angles_original = CMsgQAngle.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.angles_original,
					);
					break;
				case /* optional uint32 weapon_subclass_id */ 15:
					message.weapon_subclass_id = reader.uint32();
					break;
				case /* optional uint32 shot_number */ 16:
					message.shot_number = reader.uint32();
					break;
				case /* optional int32 ignore_entity */ 17:
					message.ignore_entity = reader.int32();
					break;
				case /* optional float max_range */ 18:
					message.max_range = reader.float();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CMsgFireBullets, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional CMsgVector origin = 1; */
		if (message.origin)
			CMsgVector.internalBinaryWrite(message.origin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		/* optional CMsgQAngle angles = 2; */
		if (message.angles)
			CMsgQAngle.internalBinaryWrite(message.angles, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
		/* optional uint32 seed = 4; */
		if (message.seed !== undefined) writer.tag(4, WireType.Varint).uint32(message.seed);
		/* optional int32 shooter_entity = 5; */
		if (message.shooter_entity !== undefined) writer.tag(5, WireType.Varint).int32(message.shooter_entity);
		/* optional int32 ability = 7; */
		if (message.ability !== undefined) writer.tag(7, WireType.Varint).int32(message.ability);
		/* optional float penetration_percent = 8; */
		if (message.penetration_percent !== undefined) writer.tag(8, WireType.Bit32).float(message.penetration_percent);
		/* optional float spread = 9; */
		if (message.spread !== undefined) writer.tag(9, WireType.Bit32).float(message.spread);
		/* optional bool fired_from_gun = 10; */
		if (message.fired_from_gun !== undefined) writer.tag(10, WireType.Varint).bool(message.fired_from_gun);
		/* optional uint32 bullets_override = 11; */
		if (message.bullets_override !== undefined) writer.tag(11, WireType.Varint).uint32(message.bullets_override);
		/* optional CMsgFireBullets.TracerAssignment tracer_replacement = 12; */
		if (message.tracer_replacement)
			CMsgFireBullets_TracerAssignment.internalBinaryWrite(
				message.tracer_replacement,
				writer.tag(12, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* repeated CMsgFireBullets.TracerAssignment tracer_additional = 13; */
		for (let i = 0; i < message.tracer_additional.length; i++)
			CMsgFireBullets_TracerAssignment.internalBinaryWrite(
				message.tracer_additional[i],
				writer.tag(13, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgQAngle angles_original = 14; */
		if (message.angles_original)
			CMsgQAngle.internalBinaryWrite(
				message.angles_original,
				writer.tag(14, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional uint32 weapon_subclass_id = 15; */
		if (message.weapon_subclass_id !== undefined) writer.tag(15, WireType.Varint).uint32(message.weapon_subclass_id);
		/* optional uint32 shot_number = 16; */
		if (message.shot_number !== undefined) writer.tag(16, WireType.Varint).uint32(message.shot_number);
		/* optional int32 ignore_entity = 17; */
		if (message.ignore_entity !== undefined) writer.tag(17, WireType.Varint).int32(message.ignore_entity);
		/* optional float max_range = 18; */
		if (message.max_range !== undefined) writer.tag(18, WireType.Bit32).float(message.max_range);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgFireBullets
 */
export const CMsgFireBullets = new CMsgFireBullets$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgFireBullets_TracerAssignment$Type extends MessageType<CMsgFireBullets_TracerAssignment> {
	constructor() {
		super("CMsgFireBullets.TracerAssignment", [
			{
				no: 1,
				name: "tracer_resource_id",
				kind: "scalar",
				localName: "tracer_resource_id",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "bullet_indicies",
				kind: "scalar",
				localName: "bullet_indicies",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgFireBullets_TracerAssignment>): CMsgFireBullets_TracerAssignment {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgFireBullets_TracerAssignment>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgFireBullets_TracerAssignment,
	): CMsgFireBullets_TracerAssignment {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint64 tracer_resource_id */ 1:
					message.tracer_resource_id = reader.uint64().toBigInt();
					break;
				case /* optional uint32 bullet_indicies */ 2:
					message.bullet_indicies = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgFireBullets_TracerAssignment,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint64 tracer_resource_id = 1; */
		if (message.tracer_resource_id !== undefined) writer.tag(1, WireType.Varint).uint64(message.tracer_resource_id);
		/* optional uint32 bullet_indicies = 2; */
		if (message.bullet_indicies !== undefined) writer.tag(2, WireType.Varint).uint32(message.bullet_indicies);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgFireBullets.TracerAssignment
 */
export const CMsgFireBullets_TracerAssignment = new CMsgFireBullets_TracerAssignment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgBulletImpact$Type extends MessageType<CMsgBulletImpact> {
	constructor() {
		super("CMsgBulletImpact", [
			{
				no: 1,
				name: "trace_start",
				kind: "message",
				localName: "trace_start",
				T: () => CMsgVector,
			},
			{
				no: 2,
				name: "impact_origin",
				kind: "message",
				localName: "impact_origin",
				T: () => CMsgVector,
			},
			{
				no: 3,
				name: "surface_normal",
				kind: "message",
				localName: "surface_normal",
				T: () => CMsgVector,
			},
			{
				no: 4,
				name: "damage",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 5,
				name: "surface_type",
				kind: "scalar",
				localName: "surface_type",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 7,
				name: "ability_entindex",
				kind: "scalar",
				localName: "ability_entindex",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 8,
				name: "impacted_entindex",
				kind: "scalar",
				localName: "impacted_entindex",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 9,
				name: "impacted_hitbox",
				kind: "scalar",
				localName: "impacted_hitbox",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 10,
				name: "weapon_subclass_id",
				kind: "scalar",
				localName: "weapon_subclass_id",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 11,
				name: "shooter_entindex",
				kind: "scalar",
				localName: "shooter_entindex",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgBulletImpact>): CMsgBulletImpact {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgBulletImpact>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgBulletImpact,
	): CMsgBulletImpact {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional CMsgVector trace_start */ 1:
					message.trace_start = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.trace_start);
					break;
				case /* optional CMsgVector impact_origin */ 2:
					message.impact_origin = CMsgVector.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.impact_origin,
					);
					break;
				case /* optional CMsgVector surface_normal */ 3:
					message.surface_normal = CMsgVector.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.surface_normal,
					);
					break;
				case /* optional uint32 damage */ 4:
					message.damage = reader.uint32();
					break;
				case /* optional uint32 surface_type */ 5:
					message.surface_type = reader.uint32();
					break;
				case /* optional int32 ability_entindex */ 7:
					message.ability_entindex = reader.int32();
					break;
				case /* optional int32 impacted_entindex */ 8:
					message.impacted_entindex = reader.int32();
					break;
				case /* optional uint32 impacted_hitbox */ 9:
					message.impacted_hitbox = reader.uint32();
					break;
				case /* optional uint32 weapon_subclass_id */ 10:
					message.weapon_subclass_id = reader.uint32();
					break;
				case /* optional int32 shooter_entindex */ 11:
					message.shooter_entindex = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CMsgBulletImpact, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional CMsgVector trace_start = 1; */
		if (message.trace_start)
			CMsgVector.internalBinaryWrite(
				message.trace_start,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgVector impact_origin = 2; */
		if (message.impact_origin)
			CMsgVector.internalBinaryWrite(
				message.impact_origin,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgVector surface_normal = 3; */
		if (message.surface_normal)
			CMsgVector.internalBinaryWrite(
				message.surface_normal,
				writer.tag(3, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional uint32 damage = 4; */
		if (message.damage !== undefined) writer.tag(4, WireType.Varint).uint32(message.damage);
		/* optional uint32 surface_type = 5; */
		if (message.surface_type !== undefined) writer.tag(5, WireType.Varint).uint32(message.surface_type);
		/* optional int32 ability_entindex = 7; */
		if (message.ability_entindex !== undefined) writer.tag(7, WireType.Varint).int32(message.ability_entindex);
		/* optional int32 impacted_entindex = 8; */
		if (message.impacted_entindex !== undefined) writer.tag(8, WireType.Varint).int32(message.impacted_entindex);
		/* optional uint32 impacted_hitbox = 9; */
		if (message.impacted_hitbox !== undefined) writer.tag(9, WireType.Varint).uint32(message.impacted_hitbox);
		/* optional uint32 weapon_subclass_id = 10; */
		if (message.weapon_subclass_id !== undefined) writer.tag(10, WireType.Varint).uint32(message.weapon_subclass_id);
		/* optional int32 shooter_entindex = 11; */
		if (message.shooter_entindex !== undefined) writer.tag(11, WireType.Varint).int32(message.shooter_entindex);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgBulletImpact
 */
export const CMsgBulletImpact = new CMsgBulletImpact$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgPlayerAnimEvent$Type extends MessageType<CMsgPlayerAnimEvent> {
	constructor() {
		super("CMsgPlayerAnimEvent", [
			{
				no: 1,
				name: "player",
				kind: "scalar",
				opt: true,
				T: 7 /*ScalarType.FIXED32*/,
			},
			{
				no: 2,
				name: "event",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "data",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgPlayerAnimEvent>): CMsgPlayerAnimEvent {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgPlayerAnimEvent>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgPlayerAnimEvent,
	): CMsgPlayerAnimEvent {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed32 player */ 1:
					message.player = reader.fixed32();
					break;
				case /* optional uint32 event */ 2:
					message.event = reader.uint32();
					break;
				case /* optional int32 data */ 3:
					message.data = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CMsgPlayerAnimEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional fixed32 player = 1; */
		if (message.player !== undefined) writer.tag(1, WireType.Bit32).fixed32(message.player);
		/* optional uint32 event = 2; */
		if (message.event !== undefined) writer.tag(2, WireType.Varint).uint32(message.event);
		/* optional int32 data = 3; */
		if (message.data !== undefined) writer.tag(3, WireType.Varint).int32(message.data);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgPlayerAnimEvent
 */
export const CMsgPlayerAnimEvent = new CMsgPlayerAnimEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager$Type extends MessageType<CMsgParticleSystemManager> {
	constructor() {
		super("CMsgParticleSystemManager", [
			{
				no: 1,
				name: "type",
				kind: "enum",
				T: () => ["PARTICLE_SYSTEM_MANAGER_MESSAGE", PARTICLE_SYSTEM_MANAGER_MESSAGE],
			},
			{ no: 2, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
			{
				no: 3,
				name: "create_particle",
				kind: "message",
				localName: "create_particle",
				T: () => CMsgParticleSystemManager_CreateParticle,
			},
			{
				no: 4,
				name: "destroy_particle",
				kind: "message",
				localName: "destroy_particle",
				T: () => CMsgParticleSystemManager_DestroyParticle,
			},
			{
				no: 5,
				name: "destroy_particle_involving",
				kind: "message",
				localName: "destroy_particle_involving",
				T: () => CMsgParticleSystemManager_DestroyParticleInvolving,
			},
			{
				no: 6,
				name: "release_particle_index",
				kind: "message",
				localName: "release_particle_index",
				T: () => CMsgParticleSystemManager_ReleaseParticleIndex,
			},
			{
				no: 7,
				name: "update_particle",
				kind: "message",
				localName: "update_particle",
				T: () => CMsgParticleSystemManager_UpdateParticle,
			},
			{
				no: 8,
				name: "update_particle_fwd",
				kind: "message",
				localName: "update_particle_fwd",
				T: () => CMsgParticleSystemManager_UpdateParticleFwd,
			},
			{
				no: 9,
				name: "update_particle_orient",
				kind: "message",
				localName: "update_particle_orient",
				T: () => CMsgParticleSystemManager_UpdateParticleOrient,
			},
			{
				no: 10,
				name: "update_particle_fallback",
				kind: "message",
				localName: "update_particle_fallback",
				T: () => CMsgParticleSystemManager_UpdateParticleFallback,
			},
			{
				no: 11,
				name: "update_particle_offset",
				kind: "message",
				localName: "update_particle_offset",
				T: () => CMsgParticleSystemManager_UpdateParticleOffset,
			},
			{
				no: 12,
				name: "update_particle_ent",
				kind: "message",
				localName: "update_particle_ent",
				T: () => CMsgParticleSystemManager_UpdateParticleEnt,
			},
			{
				no: 13,
				name: "update_particle_frozen",
				kind: "message",
				localName: "update_particle_frozen",
				T: () => CMsgParticleSystemManager_UpdateParticleFrozen,
			},
			{
				no: 14,
				name: "update_particle_should_draw",
				kind: "message",
				localName: "update_particle_should_draw",
				T: () => CMsgParticleSystemManager_UpdateParticleShouldDraw,
			},
		]);
	}
	create(value?: PartialMessage<CMsgParticleSystemManager>): CMsgParticleSystemManager {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.type = 0;
		message.index = 0;
		if (value !== undefined) reflectionMergePartial<CMsgParticleSystemManager>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgParticleSystemManager,
	): CMsgParticleSystemManager {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* PARTICLE_SYSTEM_MANAGER_MESSAGE type */ 1:
					message.type = reader.int32();
					break;
				case /* uint32 index */ 2:
					message.index = reader.uint32();
					break;
				case /* optional CMsgParticleSystemManager.CreateParticle create_particle */ 3:
					message.create_particle = CMsgParticleSystemManager_CreateParticle.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.create_particle,
					);
					break;
				case /* optional CMsgParticleSystemManager.DestroyParticle destroy_particle */ 4:
					message.destroy_particle = CMsgParticleSystemManager_DestroyParticle.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.destroy_particle,
					);
					break;
				case /* optional CMsgParticleSystemManager.DestroyParticleInvolving destroy_particle_involving */ 5:
					message.destroy_particle_involving = CMsgParticleSystemManager_DestroyParticleInvolving.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.destroy_particle_involving,
					);
					break;
				case /* optional CMsgParticleSystemManager.ReleaseParticleIndex release_particle_index */ 6:
					message.release_particle_index = CMsgParticleSystemManager_ReleaseParticleIndex.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.release_particle_index,
					);
					break;
				case /* optional CMsgParticleSystemManager.UpdateParticle update_particle */ 7:
					message.update_particle = CMsgParticleSystemManager_UpdateParticle.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.update_particle,
					);
					break;
				case /* optional CMsgParticleSystemManager.UpdateParticleFwd update_particle_fwd */ 8:
					message.update_particle_fwd = CMsgParticleSystemManager_UpdateParticleFwd.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.update_particle_fwd,
					);
					break;
				case /* optional CMsgParticleSystemManager.UpdateParticleOrient update_particle_orient */ 9:
					message.update_particle_orient = CMsgParticleSystemManager_UpdateParticleOrient.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.update_particle_orient,
					);
					break;
				case /* optional CMsgParticleSystemManager.UpdateParticleFallback update_particle_fallback */ 10:
					message.update_particle_fallback = CMsgParticleSystemManager_UpdateParticleFallback.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.update_particle_fallback,
					);
					break;
				case /* optional CMsgParticleSystemManager.UpdateParticleOffset update_particle_offset */ 11:
					message.update_particle_offset = CMsgParticleSystemManager_UpdateParticleOffset.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.update_particle_offset,
					);
					break;
				case /* optional CMsgParticleSystemManager.UpdateParticleEnt update_particle_ent */ 12:
					message.update_particle_ent = CMsgParticleSystemManager_UpdateParticleEnt.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.update_particle_ent,
					);
					break;
				case /* optional CMsgParticleSystemManager.UpdateParticleFrozen update_particle_frozen */ 13:
					message.update_particle_frozen = CMsgParticleSystemManager_UpdateParticleFrozen.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.update_particle_frozen,
					);
					break;
				case /* optional CMsgParticleSystemManager.UpdateParticleShouldDraw update_particle_should_draw */ 14:
					message.update_particle_should_draw = CMsgParticleSystemManager_UpdateParticleShouldDraw.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.update_particle_should_draw,
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgParticleSystemManager,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* PARTICLE_SYSTEM_MANAGER_MESSAGE type = 1; */
		if (message.type !== 0) writer.tag(1, WireType.Varint).int32(message.type);
		/* uint32 index = 2; */
		if (message.index !== 0) writer.tag(2, WireType.Varint).uint32(message.index);
		/* optional CMsgParticleSystemManager.CreateParticle create_particle = 3; */
		if (message.create_particle)
			CMsgParticleSystemManager_CreateParticle.internalBinaryWrite(
				message.create_particle,
				writer.tag(3, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgParticleSystemManager.DestroyParticle destroy_particle = 4; */
		if (message.destroy_particle)
			CMsgParticleSystemManager_DestroyParticle.internalBinaryWrite(
				message.destroy_particle,
				writer.tag(4, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgParticleSystemManager.DestroyParticleInvolving destroy_particle_involving = 5; */
		if (message.destroy_particle_involving)
			CMsgParticleSystemManager_DestroyParticleInvolving.internalBinaryWrite(
				message.destroy_particle_involving,
				writer.tag(5, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgParticleSystemManager.ReleaseParticleIndex release_particle_index = 6; */
		if (message.release_particle_index)
			CMsgParticleSystemManager_ReleaseParticleIndex.internalBinaryWrite(
				message.release_particle_index,
				writer.tag(6, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgParticleSystemManager.UpdateParticle update_particle = 7; */
		if (message.update_particle)
			CMsgParticleSystemManager_UpdateParticle.internalBinaryWrite(
				message.update_particle,
				writer.tag(7, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgParticleSystemManager.UpdateParticleFwd update_particle_fwd = 8; */
		if (message.update_particle_fwd)
			CMsgParticleSystemManager_UpdateParticleFwd.internalBinaryWrite(
				message.update_particle_fwd,
				writer.tag(8, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgParticleSystemManager.UpdateParticleOrient update_particle_orient = 9; */
		if (message.update_particle_orient)
			CMsgParticleSystemManager_UpdateParticleOrient.internalBinaryWrite(
				message.update_particle_orient,
				writer.tag(9, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgParticleSystemManager.UpdateParticleFallback update_particle_fallback = 10; */
		if (message.update_particle_fallback)
			CMsgParticleSystemManager_UpdateParticleFallback.internalBinaryWrite(
				message.update_particle_fallback,
				writer.tag(10, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgParticleSystemManager.UpdateParticleOffset update_particle_offset = 11; */
		if (message.update_particle_offset)
			CMsgParticleSystemManager_UpdateParticleOffset.internalBinaryWrite(
				message.update_particle_offset,
				writer.tag(11, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgParticleSystemManager.UpdateParticleEnt update_particle_ent = 12; */
		if (message.update_particle_ent)
			CMsgParticleSystemManager_UpdateParticleEnt.internalBinaryWrite(
				message.update_particle_ent,
				writer.tag(12, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgParticleSystemManager.UpdateParticleFrozen update_particle_frozen = 13; */
		if (message.update_particle_frozen)
			CMsgParticleSystemManager_UpdateParticleFrozen.internalBinaryWrite(
				message.update_particle_frozen,
				writer.tag(13, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional CMsgParticleSystemManager.UpdateParticleShouldDraw update_particle_should_draw = 14; */
		if (message.update_particle_should_draw)
			CMsgParticleSystemManager_UpdateParticleShouldDraw.internalBinaryWrite(
				message.update_particle_should_draw,
				writer.tag(14, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager
 */
export const CMsgParticleSystemManager = new CMsgParticleSystemManager$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_CreateParticle$Type extends MessageType<CMsgParticleSystemManager_CreateParticle> {
	constructor() {
		super("CMsgParticleSystemManager.CreateParticle", [
			{
				no: 1,
				name: "particle_name_index",
				kind: "scalar",
				localName: "particle_name_index",
				opt: true,
				T: 6 /*ScalarType.FIXED64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "attach_type",
				kind: "scalar",
				localName: "attach_type",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "entity_handle",
				kind: "scalar",
				localName: "entity_handle",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{ no: 4, name: "position", kind: "message", T: () => CMsgVector },
			{ no: 5, name: "angles", kind: "message", T: () => CMsgQAngle },
		]);
	}
	create(value?: PartialMessage<CMsgParticleSystemManager_CreateParticle>): CMsgParticleSystemManager_CreateParticle {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgParticleSystemManager_CreateParticle>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgParticleSystemManager_CreateParticle,
	): CMsgParticleSystemManager_CreateParticle {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional fixed64 particle_name_index */ 1:
					message.particle_name_index = reader.fixed64().toBigInt();
					break;
				case /* optional int32 attach_type */ 2:
					message.attach_type = reader.int32();
					break;
				case /* optional uint32 entity_handle */ 3:
					message.entity_handle = reader.uint32();
					break;
				case /* optional CMsgVector position */ 4:
					message.position = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.position);
					break;
				case /* optional CMsgQAngle angles */ 5:
					message.angles = CMsgQAngle.internalBinaryRead(reader, reader.uint32(), options, message.angles);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgParticleSystemManager_CreateParticle,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional fixed64 particle_name_index = 1; */
		if (message.particle_name_index !== undefined) writer.tag(1, WireType.Bit64).fixed64(message.particle_name_index);
		/* optional int32 attach_type = 2; */
		if (message.attach_type !== undefined) writer.tag(2, WireType.Varint).int32(message.attach_type);
		/* optional uint32 entity_handle = 3; */
		if (message.entity_handle !== undefined) writer.tag(3, WireType.Varint).uint32(message.entity_handle);
		/* optional CMsgVector position = 4; */
		if (message.position)
			CMsgVector.internalBinaryWrite(message.position, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
		/* optional CMsgQAngle angles = 5; */
		if (message.angles)
			CMsgQAngle.internalBinaryWrite(message.angles, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.CreateParticle
 */
export const CMsgParticleSystemManager_CreateParticle = new CMsgParticleSystemManager_CreateParticle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_DestroyParticle$Type extends MessageType<CMsgParticleSystemManager_DestroyParticle> {
	constructor() {
		super("CMsgParticleSystemManager.DestroyParticle", [
			{
				no: 1,
				name: "destroy_immediately",
				kind: "scalar",
				localName: "destroy_immediately",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgParticleSystemManager_DestroyParticle>): CMsgParticleSystemManager_DestroyParticle {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgParticleSystemManager_DestroyParticle>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgParticleSystemManager_DestroyParticle,
	): CMsgParticleSystemManager_DestroyParticle {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional bool destroy_immediately */ 1:
					message.destroy_immediately = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgParticleSystemManager_DestroyParticle,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional bool destroy_immediately = 1; */
		if (message.destroy_immediately !== undefined) writer.tag(1, WireType.Varint).bool(message.destroy_immediately);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.DestroyParticle
 */
export const CMsgParticleSystemManager_DestroyParticle = new CMsgParticleSystemManager_DestroyParticle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_DestroyParticleInvolving$Type extends MessageType<CMsgParticleSystemManager_DestroyParticleInvolving> {
	constructor() {
		super("CMsgParticleSystemManager.DestroyParticleInvolving", [
			{
				no: 1,
				name: "destroy_immediately",
				kind: "scalar",
				localName: "destroy_immediately",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 3,
				name: "entity_handle",
				kind: "scalar",
				localName: "entity_handle",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CMsgParticleSystemManager_DestroyParticleInvolving>,
	): CMsgParticleSystemManager_DestroyParticleInvolving {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined)
			reflectionMergePartial<CMsgParticleSystemManager_DestroyParticleInvolving>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgParticleSystemManager_DestroyParticleInvolving,
	): CMsgParticleSystemManager_DestroyParticleInvolving {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional bool destroy_immediately */ 1:
					message.destroy_immediately = reader.bool();
					break;
				case /* optional uint32 entity_handle */ 3:
					message.entity_handle = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgParticleSystemManager_DestroyParticleInvolving,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional bool destroy_immediately = 1; */
		if (message.destroy_immediately !== undefined) writer.tag(1, WireType.Varint).bool(message.destroy_immediately);
		/* optional uint32 entity_handle = 3; */
		if (message.entity_handle !== undefined) writer.tag(3, WireType.Varint).uint32(message.entity_handle);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.DestroyParticleInvolving
 */
export const CMsgParticleSystemManager_DestroyParticleInvolving =
	new CMsgParticleSystemManager_DestroyParticleInvolving$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_ReleaseParticleIndex$Type extends MessageType<CMsgParticleSystemManager_ReleaseParticleIndex> {
	constructor() {
		super("CMsgParticleSystemManager.ReleaseParticleIndex", []);
	}
	create(
		value?: PartialMessage<CMsgParticleSystemManager_ReleaseParticleIndex>,
	): CMsgParticleSystemManager_ReleaseParticleIndex {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined)
			reflectionMergePartial<CMsgParticleSystemManager_ReleaseParticleIndex>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgParticleSystemManager_ReleaseParticleIndex,
	): CMsgParticleSystemManager_ReleaseParticleIndex {
		return target ?? this.create();
	}
	internalBinaryWrite(
		message: CMsgParticleSystemManager_ReleaseParticleIndex,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.ReleaseParticleIndex
 */
export const CMsgParticleSystemManager_ReleaseParticleIndex = new CMsgParticleSystemManager_ReleaseParticleIndex$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_UpdateParticle$Type extends MessageType<CMsgParticleSystemManager_UpdateParticle> {
	constructor() {
		super("CMsgParticleSystemManager.UpdateParticle", [
			{
				no: 1,
				name: "control_point",
				kind: "scalar",
				localName: "control_point",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{ no: 2, name: "position", kind: "message", T: () => CMsgVector },
		]);
	}
	create(value?: PartialMessage<CMsgParticleSystemManager_UpdateParticle>): CMsgParticleSystemManager_UpdateParticle {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgParticleSystemManager_UpdateParticle>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgParticleSystemManager_UpdateParticle,
	): CMsgParticleSystemManager_UpdateParticle {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 control_point */ 1:
					message.control_point = reader.int32();
					break;
				case /* optional CMsgVector position */ 2:
					message.position = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.position);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgParticleSystemManager_UpdateParticle,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 control_point = 1; */
		if (message.control_point !== undefined) writer.tag(1, WireType.Varint).int32(message.control_point);
		/* optional CMsgVector position = 2; */
		if (message.position)
			CMsgVector.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.UpdateParticle
 */
export const CMsgParticleSystemManager_UpdateParticle = new CMsgParticleSystemManager_UpdateParticle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_UpdateParticleFwd$Type extends MessageType<CMsgParticleSystemManager_UpdateParticleFwd> {
	constructor() {
		super("CMsgParticleSystemManager.UpdateParticleFwd", [
			{
				no: 1,
				name: "control_point",
				kind: "scalar",
				localName: "control_point",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{ no: 2, name: "forward", kind: "message", T: () => CMsgVector },
		]);
	}
	create(
		value?: PartialMessage<CMsgParticleSystemManager_UpdateParticleFwd>,
	): CMsgParticleSystemManager_UpdateParticleFwd {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgParticleSystemManager_UpdateParticleFwd>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgParticleSystemManager_UpdateParticleFwd,
	): CMsgParticleSystemManager_UpdateParticleFwd {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 control_point */ 1:
					message.control_point = reader.int32();
					break;
				case /* optional CMsgVector forward */ 2:
					message.forward = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.forward);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgParticleSystemManager_UpdateParticleFwd,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 control_point = 1; */
		if (message.control_point !== undefined) writer.tag(1, WireType.Varint).int32(message.control_point);
		/* optional CMsgVector forward = 2; */
		if (message.forward)
			CMsgVector.internalBinaryWrite(message.forward, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.UpdateParticleFwd
 */
export const CMsgParticleSystemManager_UpdateParticleFwd = new CMsgParticleSystemManager_UpdateParticleFwd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_UpdateParticleOrient$Type extends MessageType<CMsgParticleSystemManager_UpdateParticleOrient> {
	constructor() {
		super("CMsgParticleSystemManager.UpdateParticleOrient", [
			{
				no: 1,
				name: "control_point",
				kind: "scalar",
				localName: "control_point",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{ no: 2, name: "forward", kind: "message", T: () => CMsgVector },
			{ no: 3, name: "left", kind: "message", T: () => CMsgVector },
			{ no: 4, name: "up", kind: "message", T: () => CMsgVector },
		]);
	}
	create(
		value?: PartialMessage<CMsgParticleSystemManager_UpdateParticleOrient>,
	): CMsgParticleSystemManager_UpdateParticleOrient {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined)
			reflectionMergePartial<CMsgParticleSystemManager_UpdateParticleOrient>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgParticleSystemManager_UpdateParticleOrient,
	): CMsgParticleSystemManager_UpdateParticleOrient {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 control_point */ 1:
					message.control_point = reader.int32();
					break;
				case /* optional CMsgVector forward */ 2:
					message.forward = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.forward);
					break;
				case /* optional CMsgVector left */ 3:
					message.left = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.left);
					break;
				case /* optional CMsgVector up */ 4:
					message.up = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.up);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgParticleSystemManager_UpdateParticleOrient,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 control_point = 1; */
		if (message.control_point !== undefined) writer.tag(1, WireType.Varint).int32(message.control_point);
		/* optional CMsgVector forward = 2; */
		if (message.forward)
			CMsgVector.internalBinaryWrite(message.forward, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
		/* optional CMsgVector left = 3; */
		if (message.left)
			CMsgVector.internalBinaryWrite(message.left, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
		/* optional CMsgVector up = 4; */
		if (message.up)
			CMsgVector.internalBinaryWrite(message.up, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.UpdateParticleOrient
 */
export const CMsgParticleSystemManager_UpdateParticleOrient = new CMsgParticleSystemManager_UpdateParticleOrient$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_UpdateParticleFallback$Type extends MessageType<CMsgParticleSystemManager_UpdateParticleFallback> {
	constructor() {
		super("CMsgParticleSystemManager.UpdateParticleFallback", [
			{
				no: 1,
				name: "control_point",
				kind: "scalar",
				localName: "control_point",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{ no: 2, name: "position", kind: "message", T: () => CMsgVector },
		]);
	}
	create(
		value?: PartialMessage<CMsgParticleSystemManager_UpdateParticleFallback>,
	): CMsgParticleSystemManager_UpdateParticleFallback {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined)
			reflectionMergePartial<CMsgParticleSystemManager_UpdateParticleFallback>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgParticleSystemManager_UpdateParticleFallback,
	): CMsgParticleSystemManager_UpdateParticleFallback {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 control_point */ 1:
					message.control_point = reader.int32();
					break;
				case /* optional CMsgVector position */ 2:
					message.position = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.position);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgParticleSystemManager_UpdateParticleFallback,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 control_point = 1; */
		if (message.control_point !== undefined) writer.tag(1, WireType.Varint).int32(message.control_point);
		/* optional CMsgVector position = 2; */
		if (message.position)
			CMsgVector.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.UpdateParticleFallback
 */
export const CMsgParticleSystemManager_UpdateParticleFallback =
	new CMsgParticleSystemManager_UpdateParticleFallback$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_UpdateParticleEnt$Type extends MessageType<CMsgParticleSystemManager_UpdateParticleEnt> {
	constructor() {
		super("CMsgParticleSystemManager.UpdateParticleEnt", [
			{
				no: 1,
				name: "control_point",
				kind: "scalar",
				localName: "control_point",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "entity_handle",
				kind: "scalar",
				localName: "entity_handle",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 3,
				name: "attach_type",
				kind: "scalar",
				localName: "attach_type",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 4,
				name: "attachment",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 5,
				name: "fallback_position",
				kind: "message",
				localName: "fallback_position",
				T: () => CMsgVector,
			},
		]);
	}
	create(
		value?: PartialMessage<CMsgParticleSystemManager_UpdateParticleEnt>,
	): CMsgParticleSystemManager_UpdateParticleEnt {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgParticleSystemManager_UpdateParticleEnt>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgParticleSystemManager_UpdateParticleEnt,
	): CMsgParticleSystemManager_UpdateParticleEnt {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 control_point */ 1:
					message.control_point = reader.int32();
					break;
				case /* optional uint32 entity_handle */ 2:
					message.entity_handle = reader.uint32();
					break;
				case /* optional int32 attach_type */ 3:
					message.attach_type = reader.int32();
					break;
				case /* optional int32 attachment */ 4:
					message.attachment = reader.int32();
					break;
				case /* optional CMsgVector fallback_position */ 5:
					message.fallback_position = CMsgVector.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.fallback_position,
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgParticleSystemManager_UpdateParticleEnt,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 control_point = 1; */
		if (message.control_point !== undefined) writer.tag(1, WireType.Varint).int32(message.control_point);
		/* optional uint32 entity_handle = 2; */
		if (message.entity_handle !== undefined) writer.tag(2, WireType.Varint).uint32(message.entity_handle);
		/* optional int32 attach_type = 3; */
		if (message.attach_type !== undefined) writer.tag(3, WireType.Varint).int32(message.attach_type);
		/* optional int32 attachment = 4; */
		if (message.attachment !== undefined) writer.tag(4, WireType.Varint).int32(message.attachment);
		/* optional CMsgVector fallback_position = 5; */
		if (message.fallback_position)
			CMsgVector.internalBinaryWrite(
				message.fallback_position,
				writer.tag(5, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.UpdateParticleEnt
 */
export const CMsgParticleSystemManager_UpdateParticleEnt = new CMsgParticleSystemManager_UpdateParticleEnt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_UpdateParticleOffset$Type extends MessageType<CMsgParticleSystemManager_UpdateParticleOffset> {
	constructor() {
		super("CMsgParticleSystemManager.UpdateParticleOffset", [
			{
				no: 1,
				name: "control_point",
				kind: "scalar",
				localName: "control_point",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "origin_offset",
				kind: "message",
				localName: "origin_offset",
				T: () => CMsgVector,
			},
		]);
	}
	create(
		value?: PartialMessage<CMsgParticleSystemManager_UpdateParticleOffset>,
	): CMsgParticleSystemManager_UpdateParticleOffset {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined)
			reflectionMergePartial<CMsgParticleSystemManager_UpdateParticleOffset>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgParticleSystemManager_UpdateParticleOffset,
	): CMsgParticleSystemManager_UpdateParticleOffset {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 control_point */ 1:
					message.control_point = reader.int32();
					break;
				case /* optional CMsgVector origin_offset */ 2:
					message.origin_offset = CMsgVector.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.origin_offset,
					);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgParticleSystemManager_UpdateParticleOffset,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 control_point = 1; */
		if (message.control_point !== undefined) writer.tag(1, WireType.Varint).int32(message.control_point);
		/* optional CMsgVector origin_offset = 2; */
		if (message.origin_offset)
			CMsgVector.internalBinaryWrite(
				message.origin_offset,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.UpdateParticleOffset
 */
export const CMsgParticleSystemManager_UpdateParticleOffset = new CMsgParticleSystemManager_UpdateParticleOffset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_UpdateParticleFrozen$Type extends MessageType<CMsgParticleSystemManager_UpdateParticleFrozen> {
	constructor() {
		super("CMsgParticleSystemManager.UpdateParticleFrozen", [
			{
				no: 1,
				name: "set_frozen",
				kind: "scalar",
				localName: "set_frozen",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CMsgParticleSystemManager_UpdateParticleFrozen>,
	): CMsgParticleSystemManager_UpdateParticleFrozen {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined)
			reflectionMergePartial<CMsgParticleSystemManager_UpdateParticleFrozen>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgParticleSystemManager_UpdateParticleFrozen,
	): CMsgParticleSystemManager_UpdateParticleFrozen {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional bool set_frozen */ 1:
					message.set_frozen = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgParticleSystemManager_UpdateParticleFrozen,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional bool set_frozen = 1; */
		if (message.set_frozen !== undefined) writer.tag(1, WireType.Varint).bool(message.set_frozen);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.UpdateParticleFrozen
 */
export const CMsgParticleSystemManager_UpdateParticleFrozen = new CMsgParticleSystemManager_UpdateParticleFrozen$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_UpdateParticleShouldDraw$Type extends MessageType<CMsgParticleSystemManager_UpdateParticleShouldDraw> {
	constructor() {
		super("CMsgParticleSystemManager.UpdateParticleShouldDraw", [
			{
				no: 1,
				name: "should_draw",
				kind: "scalar",
				localName: "should_draw",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(
		value?: PartialMessage<CMsgParticleSystemManager_UpdateParticleShouldDraw>,
	): CMsgParticleSystemManager_UpdateParticleShouldDraw {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined)
			reflectionMergePartial<CMsgParticleSystemManager_UpdateParticleShouldDraw>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgParticleSystemManager_UpdateParticleShouldDraw,
	): CMsgParticleSystemManager_UpdateParticleShouldDraw {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional bool should_draw */ 1:
					message.should_draw = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgParticleSystemManager_UpdateParticleShouldDraw,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional bool should_draw = 1; */
		if (message.should_draw !== undefined) writer.tag(1, WireType.Varint).bool(message.should_draw);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.UpdateParticleShouldDraw
 */
export const CMsgParticleSystemManager_UpdateParticleShouldDraw =
	new CMsgParticleSystemManager_UpdateParticleShouldDraw$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgScreenTextPretty$Type extends MessageType<CMsgScreenTextPretty> {
	constructor() {
		super("CMsgScreenTextPretty", [
			{
				no: 1,
				name: "x_pos",
				kind: "scalar",
				localName: "x_pos",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 2,
				name: "y_pos",
				kind: "scalar",
				localName: "y_pos",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 3,
				name: "line",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 4,
				name: "text",
				kind: "scalar",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 5,
				name: "r",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 6,
				name: "g",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 7,
				name: "b",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 8,
				name: "a",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 9,
				name: "duration",
				kind: "scalar",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 10,
				name: "font_name",
				kind: "scalar",
				localName: "font_name",
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 11,
				name: "font_size",
				kind: "scalar",
				localName: "font_size",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 12,
				name: "bold_font",
				kind: "scalar",
				localName: "bold_font",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgScreenTextPretty>): CMsgScreenTextPretty {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgScreenTextPretty>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgScreenTextPretty,
	): CMsgScreenTextPretty {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional float x_pos */ 1:
					message.x_pos = reader.float();
					break;
				case /* optional float y_pos */ 2:
					message.y_pos = reader.float();
					break;
				case /* optional int32 line */ 3:
					message.line = reader.int32();
					break;
				case /* optional string text */ 4:
					message.text = reader.string();
					break;
				case /* optional int32 r */ 5:
					message.r = reader.int32();
					break;
				case /* optional int32 g */ 6:
					message.g = reader.int32();
					break;
				case /* optional int32 b */ 7:
					message.b = reader.int32();
					break;
				case /* optional int32 a */ 8:
					message.a = reader.int32();
					break;
				case /* optional float duration */ 9:
					message.duration = reader.float();
					break;
				case /* optional string font_name */ 10:
					message.font_name = reader.string();
					break;
				case /* optional int32 font_size */ 11:
					message.font_size = reader.int32();
					break;
				case /* optional bool bold_font */ 12:
					message.bold_font = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgScreenTextPretty,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional float x_pos = 1; */
		if (message.x_pos !== undefined) writer.tag(1, WireType.Bit32).float(message.x_pos);
		/* optional float y_pos = 2; */
		if (message.y_pos !== undefined) writer.tag(2, WireType.Bit32).float(message.y_pos);
		/* optional int32 line = 3; */
		if (message.line !== undefined) writer.tag(3, WireType.Varint).int32(message.line);
		/* optional string text = 4; */
		if (message.text !== undefined) writer.tag(4, WireType.LengthDelimited).string(message.text);
		/* optional int32 r = 5; */
		if (message.r !== undefined) writer.tag(5, WireType.Varint).int32(message.r);
		/* optional int32 g = 6; */
		if (message.g !== undefined) writer.tag(6, WireType.Varint).int32(message.g);
		/* optional int32 b = 7; */
		if (message.b !== undefined) writer.tag(7, WireType.Varint).int32(message.b);
		/* optional int32 a = 8; */
		if (message.a !== undefined) writer.tag(8, WireType.Varint).int32(message.a);
		/* optional float duration = 9; */
		if (message.duration !== undefined) writer.tag(9, WireType.Bit32).float(message.duration);
		/* optional string font_name = 10; */
		if (message.font_name !== undefined) writer.tag(10, WireType.LengthDelimited).string(message.font_name);
		/* optional int32 font_size = 11; */
		if (message.font_size !== undefined) writer.tag(11, WireType.Varint).int32(message.font_size);
		/* optional bool bold_font = 12; */
		if (message.bold_font !== undefined) writer.tag(12, WireType.Varint).bool(message.bold_font);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgScreenTextPretty
 */
export const CMsgScreenTextPretty = new CMsgScreenTextPretty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgServerRequestedTracer$Type extends MessageType<CMsgServerRequestedTracer> {
	constructor() {
		super("CMsgServerRequestedTracer", [
			{ no: 1, name: "origin", kind: "message", T: () => CMsgVector },
			{ no: 2, name: "end", kind: "message", T: () => CMsgVector },
			{
				no: 3,
				name: "weaponid",
				kind: "scalar",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 4,
				name: "entity_handle",
				kind: "scalar",
				localName: "entity_handle",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 5,
				name: "dps",
				kind: "scalar",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgServerRequestedTracer>): CMsgServerRequestedTracer {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgServerRequestedTracer>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgServerRequestedTracer,
	): CMsgServerRequestedTracer {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional CMsgVector origin */ 1:
					message.origin = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.origin);
					break;
				case /* optional CMsgVector end */ 2:
					message.end = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.end);
					break;
				case /* optional int32 weaponid */ 3:
					message.weaponid = reader.int32();
					break;
				case /* optional uint32 entity_handle */ 4:
					message.entity_handle = reader.uint32();
					break;
				case /* optional float dps */ 5:
					message.dps = reader.float();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgServerRequestedTracer,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional CMsgVector origin = 1; */
		if (message.origin)
			CMsgVector.internalBinaryWrite(message.origin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		/* optional CMsgVector end = 2; */
		if (message.end)
			CMsgVector.internalBinaryWrite(message.end, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
		/* optional int32 weaponid = 3; */
		if (message.weaponid !== undefined) writer.tag(3, WireType.Varint).int32(message.weaponid);
		/* optional uint32 entity_handle = 4; */
		if (message.entity_handle !== undefined) writer.tag(4, WireType.Varint).uint32(message.entity_handle);
		/* optional float dps = 5; */
		if (message.dps !== undefined) writer.tag(5, WireType.Bit32).float(message.dps);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgServerRequestedTracer
 */
export const CMsgServerRequestedTracer = new CMsgServerRequestedTracer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgEnableSatVolumesEvent$Type extends MessageType<CMsgEnableSatVolumesEvent> {
	constructor() {
		super("CMsgEnableSatVolumesEvent", [
			{
				no: 1,
				name: "mode",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: "desat_amount",
				kind: "scalar",
				localName: "desat_amount",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 3,
				name: "sat_tint",
				kind: "scalar",
				localName: "sat_tint",
				opt: true,
				T: 7 /*ScalarType.FIXED32*/,
			},
			{
				no: 4,
				name: "desat_tint",
				kind: "scalar",
				localName: "desat_tint",
				opt: true,
				T: 7 /*ScalarType.FIXED32*/,
			},
			{
				no: 5,
				name: "outline_color",
				kind: "scalar",
				localName: "outline_color",
				opt: true,
				T: 7 /*ScalarType.FIXED32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgEnableSatVolumesEvent>): CMsgEnableSatVolumesEvent {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgEnableSatVolumesEvent>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgEnableSatVolumesEvent,
	): CMsgEnableSatVolumesEvent {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional uint32 mode */ 1:
					message.mode = reader.uint32();
					break;
				case /* optional float desat_amount */ 2:
					message.desat_amount = reader.float();
					break;
				case /* optional fixed32 sat_tint */ 3:
					message.sat_tint = reader.fixed32();
					break;
				case /* optional fixed32 desat_tint */ 4:
					message.desat_tint = reader.fixed32();
					break;
				case /* optional fixed32 outline_color */ 5:
					message.outline_color = reader.fixed32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgEnableSatVolumesEvent,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional uint32 mode = 1; */
		if (message.mode !== undefined) writer.tag(1, WireType.Varint).uint32(message.mode);
		/* optional float desat_amount = 2; */
		if (message.desat_amount !== undefined) writer.tag(2, WireType.Bit32).float(message.desat_amount);
		/* optional fixed32 sat_tint = 3; */
		if (message.sat_tint !== undefined) writer.tag(3, WireType.Bit32).fixed32(message.sat_tint);
		/* optional fixed32 desat_tint = 4; */
		if (message.desat_tint !== undefined) writer.tag(4, WireType.Bit32).fixed32(message.desat_tint);
		/* optional fixed32 outline_color = 5; */
		if (message.outline_color !== undefined) writer.tag(5, WireType.Bit32).fixed32(message.outline_color);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgEnableSatVolumesEvent
 */
export const CMsgEnableSatVolumesEvent = new CMsgEnableSatVolumesEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgPlaceSatVolumeEvent$Type extends MessageType<CMsgPlaceSatVolumeEvent> {
	constructor() {
		super("CMsgPlaceSatVolumeEvent", [
			{ no: 1, name: "position", kind: "message", T: () => CMsgVector },
			{ no: 2, name: "direction", kind: "message", T: () => CMsgVector },
			{
				no: 3,
				name: "radius",
				kind: "scalar",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 4,
				name: "falloff_distance",
				kind: "scalar",
				localName: "falloff_distance",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 5,
				name: "theta_dot",
				kind: "scalar",
				localName: "theta_dot",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 6,
				name: "phi_dot",
				kind: "scalar",
				localName: "phi_dot",
				opt: true,
				T: 2 /*ScalarType.FLOAT*/,
			},
			{
				no: 7,
				name: "entity_handle",
				kind: "scalar",
				localName: "entity_handle",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 8,
				name: "attachment_handle",
				kind: "scalar",
				localName: "attachment_handle",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 9,
				name: "type",
				kind: "scalar",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 10,
				name: "volume_id",
				kind: "scalar",
				localName: "volume_id",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgPlaceSatVolumeEvent>): CMsgPlaceSatVolumeEvent {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgPlaceSatVolumeEvent>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgPlaceSatVolumeEvent,
	): CMsgPlaceSatVolumeEvent {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional CMsgVector position */ 1:
					message.position = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.position);
					break;
				case /* optional CMsgVector direction */ 2:
					message.direction = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.direction);
					break;
				case /* optional float radius */ 3:
					message.radius = reader.float();
					break;
				case /* optional float falloff_distance */ 4:
					message.falloff_distance = reader.float();
					break;
				case /* optional float theta_dot */ 5:
					message.theta_dot = reader.float();
					break;
				case /* optional float phi_dot */ 6:
					message.phi_dot = reader.float();
					break;
				case /* optional uint32 entity_handle */ 7:
					message.entity_handle = reader.uint32();
					break;
				case /* optional uint32 attachment_handle */ 8:
					message.attachment_handle = reader.uint32();
					break;
				case /* optional uint32 type */ 9:
					message.type = reader.uint32();
					break;
				case /* optional int32 volume_id */ 10:
					message.volume_id = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgPlaceSatVolumeEvent,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional CMsgVector position = 1; */
		if (message.position)
			CMsgVector.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		/* optional CMsgVector direction = 2; */
		if (message.direction)
			CMsgVector.internalBinaryWrite(message.direction, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
		/* optional float radius = 3; */
		if (message.radius !== undefined) writer.tag(3, WireType.Bit32).float(message.radius);
		/* optional float falloff_distance = 4; */
		if (message.falloff_distance !== undefined) writer.tag(4, WireType.Bit32).float(message.falloff_distance);
		/* optional float theta_dot = 5; */
		if (message.theta_dot !== undefined) writer.tag(5, WireType.Bit32).float(message.theta_dot);
		/* optional float phi_dot = 6; */
		if (message.phi_dot !== undefined) writer.tag(6, WireType.Bit32).float(message.phi_dot);
		/* optional uint32 entity_handle = 7; */
		if (message.entity_handle !== undefined) writer.tag(7, WireType.Varint).uint32(message.entity_handle);
		/* optional uint32 attachment_handle = 8; */
		if (message.attachment_handle !== undefined) writer.tag(8, WireType.Varint).uint32(message.attachment_handle);
		/* optional uint32 type = 9; */
		if (message.type !== undefined) writer.tag(9, WireType.Varint).uint32(message.type);
		/* optional int32 volume_id = 10; */
		if (message.volume_id !== undefined) writer.tag(10, WireType.Varint).int32(message.volume_id);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgPlaceSatVolumeEvent
 */
export const CMsgPlaceSatVolumeEvent = new CMsgPlaceSatVolumeEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgRemoveSatVolumeEvent$Type extends MessageType<CMsgRemoveSatVolumeEvent> {
	constructor() {
		super("CMsgRemoveSatVolumeEvent", [
			{
				no: 1,
				name: "volume_id",
				kind: "scalar",
				localName: "volume_id",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CMsgRemoveSatVolumeEvent>): CMsgRemoveSatVolumeEvent {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgRemoveSatVolumeEvent>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgRemoveSatVolumeEvent,
	): CMsgRemoveSatVolumeEvent {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 volume_id */ 1:
					message.volume_id = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CMsgRemoveSatVolumeEvent,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 volume_id = 1; */
		if (message.volume_id !== undefined) writer.tag(1, WireType.Varint).int32(message.volume_id);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgRemoveSatVolumeEvent
 */
export const CMsgRemoveSatVolumeEvent = new CMsgRemoveSatVolumeEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgDisableSatVolumesEvent$Type extends MessageType<CMsgDisableSatVolumesEvent> {
	constructor() {
		super("CMsgDisableSatVolumesEvent", []);
	}
	create(value?: PartialMessage<CMsgDisableSatVolumesEvent>): CMsgDisableSatVolumesEvent {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CMsgDisableSatVolumesEvent>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CMsgDisableSatVolumesEvent,
	): CMsgDisableSatVolumesEvent {
		return target ?? this.create();
	}
	internalBinaryWrite(
		message: CMsgDisableSatVolumesEvent,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CMsgDisableSatVolumesEvent
 */
export const CMsgDisableSatVolumesEvent = new CMsgDisableSatVolumesEvent$Type();

// @generated by protobuf-ts 2.9.4 with parameter use_proto_field_name
// @generated from protobuf file "c_peer2peer_netmessages.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CMsgQAngle } from "./networkbasetypes.js";
import { CMsgVector } from "./networkbasetypes.js";
import { CMsgVoiceAudio } from "./netmessages.js";
/**
 * @generated from protobuf message CP2P_TextMessage
 */
export interface CP2P_TextMessage {
	/**
	 * @generated from protobuf field: optional bytes text = 1;
	 */
	text?: Uint8Array;
}
/**
 * @generated from protobuf message CSteam_Voice_Encoding
 */
export interface CSteam_Voice_Encoding {
	/**
	 * @generated from protobuf field: optional bytes voice_data = 1;
	 */
	voice_data?: Uint8Array;
}
/**
 * @generated from protobuf message CP2P_Voice
 */
export interface CP2P_Voice {
	/**
	 * @generated from protobuf field: optional CMsgVoiceAudio audio = 1;
	 */
	audio?: CMsgVoiceAudio;
	/**
	 * @generated from protobuf field: optional uint32 broadcast_group = 2;
	 */
	broadcast_group?: number;
}
/**
 * @generated from protobuf enum CP2P_Voice.Handler_Flags
 */
export enum CP2P_Voice_Handler_Flags {
	/**
	 * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
	 */
	UNSPECIFIED$ = 0,
	/**
	 * @generated from protobuf enum value: Played_Audio = 1;
	 */
	Played_Audio = 1,
}
/**
 * @generated from protobuf message CP2P_Ping
 */
export interface CP2P_Ping {
	/**
	 * @generated from protobuf field: uint64 send_time = 1;
	 */
	send_time: bigint;
	/**
	 * @generated from protobuf field: bool is_reply = 2;
	 */
	is_reply: boolean;
}
/**
 * @generated from protobuf message CP2P_VRAvatarPosition
 */
export interface CP2P_VRAvatarPosition {
	/**
	 * @generated from protobuf field: repeated CP2P_VRAvatarPosition.COrientation body_parts = 1;
	 */
	body_parts: CP2P_VRAvatarPosition_COrientation[];
	/**
	 * @generated from protobuf field: optional int32 hat_id = 2;
	 */
	hat_id?: number;
	/**
	 * @generated from protobuf field: optional int32 scene_id = 3;
	 */
	scene_id?: number;
	/**
	 * @generated from protobuf field: optional int32 world_scale = 4;
	 */
	world_scale?: number;
}
/**
 * @generated from protobuf message CP2P_VRAvatarPosition.COrientation
 */
export interface CP2P_VRAvatarPosition_COrientation {
	/**
	 * @generated from protobuf field: optional CMsgVector pos = 1;
	 */
	pos?: CMsgVector;
	/**
	 * @generated from protobuf field: optional CMsgQAngle ang = 2;
	 */
	ang?: CMsgQAngle;
}
/**
 * @generated from protobuf message CP2P_WatchSynchronization
 */
export interface CP2P_WatchSynchronization {
	/**
	 * @generated from protobuf field: optional int32 demo_tick = 1;
	 */
	demo_tick?: number;
	/**
	 * @generated from protobuf field: optional bool paused = 2;
	 */
	paused?: boolean;
	/**
	 * @generated from protobuf field: optional uint64 tv_listen_voice_indices = 3;
	 */
	tv_listen_voice_indices?: bigint;
	/**
	 * @generated from protobuf field: optional int32 dota_spectator_mode = 4;
	 */
	dota_spectator_mode?: number;
	/**
	 * @generated from protobuf field: optional bool dota_spectator_watching_broadcaster = 5;
	 */
	dota_spectator_watching_broadcaster?: boolean;
	/**
	 * @generated from protobuf field: optional int32 dota_spectator_hero_index = 6;
	 */
	dota_spectator_hero_index?: number;
	/**
	 * @generated from protobuf field: optional int32 dota_spectator_autospeed = 7;
	 */
	dota_spectator_autospeed?: number;
	/**
	 * @generated from protobuf field: optional int32 dota_replay_speed = 8;
	 */
	dota_replay_speed?: number;
}
/**
 * @generated from protobuf enum P2P_Messages
 */
export enum P2P_Messages {
	/**
	 * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
	 */
	UNSPECIFIED$ = 0,
	/**
	 * @generated from protobuf enum value: p2p_TextMessage = 256;
	 */
	p2p_TextMessage = 256,
	/**
	 * @generated from protobuf enum value: p2p_Voice = 257;
	 */
	p2p_Voice = 257,
	/**
	 * @generated from protobuf enum value: p2p_Ping = 258;
	 */
	p2p_Ping = 258,
	/**
	 * @generated from protobuf enum value: p2p_VRAvatarPosition = 259;
	 */
	p2p_VRAvatarPosition = 259,
	/**
	 * @generated from protobuf enum value: p2p_WatchSynchronization = 260;
	 */
	p2p_WatchSynchronization = 260,
	/**
	 * @generated from protobuf enum value: p2p_FightingGame_GameData = 261;
	 */
	p2p_FightingGame_GameData = 261,
	/**
	 * @generated from protobuf enum value: p2p_FightingGame_Connection = 262;
	 */
	p2p_FightingGame_Connection = 262,
}
// @generated message type with reflection information, may provide speed optimized methods
class CP2P_TextMessage$Type extends MessageType<CP2P_TextMessage> {
	constructor() {
		super("CP2P_TextMessage", [
			{
				no: 1,
				name: "text",
				kind: "scalar",
				opt: true,
				T: 12 /*ScalarType.BYTES*/,
			},
		]);
	}
	create(value?: PartialMessage<CP2P_TextMessage>): CP2P_TextMessage {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CP2P_TextMessage>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CP2P_TextMessage,
	): CP2P_TextMessage {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional bytes text */ 1:
					message.text = reader.bytes();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CP2P_TextMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional bytes text = 1; */
		if (message.text !== undefined) writer.tag(1, WireType.LengthDelimited).bytes(message.text);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CP2P_TextMessage
 */
export const CP2P_TextMessage = new CP2P_TextMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteam_Voice_Encoding$Type extends MessageType<CSteam_Voice_Encoding> {
	constructor() {
		super("CSteam_Voice_Encoding", [
			{
				no: 1,
				name: "voice_data",
				kind: "scalar",
				localName: "voice_data",
				opt: true,
				T: 12 /*ScalarType.BYTES*/,
			},
		]);
	}
	create(value?: PartialMessage<CSteam_Voice_Encoding>): CSteam_Voice_Encoding {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CSteam_Voice_Encoding>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CSteam_Voice_Encoding,
	): CSteam_Voice_Encoding {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional bytes voice_data */ 1:
					message.voice_data = reader.bytes();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CSteam_Voice_Encoding,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional bytes voice_data = 1; */
		if (message.voice_data !== undefined) writer.tag(1, WireType.LengthDelimited).bytes(message.voice_data);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CSteam_Voice_Encoding
 */
export const CSteam_Voice_Encoding = new CSteam_Voice_Encoding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CP2P_Voice$Type extends MessageType<CP2P_Voice> {
	constructor() {
		super("CP2P_Voice", [
			{ no: 1, name: "audio", kind: "message", T: () => CMsgVoiceAudio },
			{
				no: 2,
				name: "broadcast_group",
				kind: "scalar",
				localName: "broadcast_group",
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CP2P_Voice>): CP2P_Voice {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CP2P_Voice>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CP2P_Voice,
	): CP2P_Voice {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional CMsgVoiceAudio audio */ 1:
					message.audio = CMsgVoiceAudio.internalBinaryRead(reader, reader.uint32(), options, message.audio);
					break;
				case /* optional uint32 broadcast_group */ 2:
					message.broadcast_group = reader.uint32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CP2P_Voice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* optional CMsgVoiceAudio audio = 1; */
		if (message.audio)
			CMsgVoiceAudio.internalBinaryWrite(message.audio, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		/* optional uint32 broadcast_group = 2; */
		if (message.broadcast_group !== undefined) writer.tag(2, WireType.Varint).uint32(message.broadcast_group);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CP2P_Voice
 */
export const CP2P_Voice = new CP2P_Voice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CP2P_Ping$Type extends MessageType<CP2P_Ping> {
	constructor() {
		super("CP2P_Ping", [
			{
				no: 1,
				name: "send_time",
				kind: "scalar",
				localName: "send_time",
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: "is_reply",
				kind: "scalar",
				localName: "is_reply",
				T: 8 /*ScalarType.BOOL*/,
			},
		]);
	}
	create(value?: PartialMessage<CP2P_Ping>): CP2P_Ping {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.send_time = 0n;
		message.is_reply = false;
		if (value !== undefined) reflectionMergePartial<CP2P_Ping>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CP2P_Ping): CP2P_Ping {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* uint64 send_time */ 1:
					message.send_time = reader.uint64().toBigInt();
					break;
				case /* bool is_reply */ 2:
					message.is_reply = reader.bool();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CP2P_Ping, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* uint64 send_time = 1; */
		if (message.send_time !== 0n) writer.tag(1, WireType.Varint).uint64(message.send_time);
		/* bool is_reply = 2; */
		if (message.is_reply !== false) writer.tag(2, WireType.Varint).bool(message.is_reply);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CP2P_Ping
 */
export const CP2P_Ping = new CP2P_Ping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CP2P_VRAvatarPosition$Type extends MessageType<CP2P_VRAvatarPosition> {
	constructor() {
		super("CP2P_VRAvatarPosition", [
			{
				no: 1,
				name: "body_parts",
				kind: "message",
				localName: "body_parts",
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => CP2P_VRAvatarPosition_COrientation,
			},
			{
				no: 2,
				name: "hat_id",
				kind: "scalar",
				localName: "hat_id",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 3,
				name: "scene_id",
				kind: "scalar",
				localName: "scene_id",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 4,
				name: "world_scale",
				kind: "scalar",
				localName: "world_scale",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CP2P_VRAvatarPosition>): CP2P_VRAvatarPosition {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.body_parts = [];
		if (value !== undefined) reflectionMergePartial<CP2P_VRAvatarPosition>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CP2P_VRAvatarPosition,
	): CP2P_VRAvatarPosition {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated CP2P_VRAvatarPosition.COrientation body_parts */ 1:
					message.body_parts.push(
						CP2P_VRAvatarPosition_COrientation.internalBinaryRead(reader, reader.uint32(), options),
					);
					break;
				case /* optional int32 hat_id */ 2:
					message.hat_id = reader.int32();
					break;
				case /* optional int32 scene_id */ 3:
					message.scene_id = reader.int32();
					break;
				case /* optional int32 world_scale */ 4:
					message.world_scale = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CP2P_VRAvatarPosition,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated CP2P_VRAvatarPosition.COrientation body_parts = 1; */
		for (let i = 0; i < message.body_parts.length; i++)
			CP2P_VRAvatarPosition_COrientation.internalBinaryWrite(
				message.body_parts[i],
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join();
		/* optional int32 hat_id = 2; */
		if (message.hat_id !== undefined) writer.tag(2, WireType.Varint).int32(message.hat_id);
		/* optional int32 scene_id = 3; */
		if (message.scene_id !== undefined) writer.tag(3, WireType.Varint).int32(message.scene_id);
		/* optional int32 world_scale = 4; */
		if (message.world_scale !== undefined) writer.tag(4, WireType.Varint).int32(message.world_scale);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CP2P_VRAvatarPosition
 */
export const CP2P_VRAvatarPosition = new CP2P_VRAvatarPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CP2P_VRAvatarPosition_COrientation$Type extends MessageType<CP2P_VRAvatarPosition_COrientation> {
	constructor() {
		super("CP2P_VRAvatarPosition.COrientation", [
			{ no: 1, name: "pos", kind: "message", T: () => CMsgVector },
			{ no: 2, name: "ang", kind: "message", T: () => CMsgQAngle },
		]);
	}
	create(value?: PartialMessage<CP2P_VRAvatarPosition_COrientation>): CP2P_VRAvatarPosition_COrientation {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CP2P_VRAvatarPosition_COrientation>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CP2P_VRAvatarPosition_COrientation,
	): CP2P_VRAvatarPosition_COrientation {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional CMsgVector pos */ 1:
					message.pos = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
					break;
				case /* optional CMsgQAngle ang */ 2:
					message.ang = CMsgQAngle.internalBinaryRead(reader, reader.uint32(), options, message.ang);
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CP2P_VRAvatarPosition_COrientation,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional CMsgVector pos = 1; */
		if (message.pos)
			CMsgVector.internalBinaryWrite(message.pos, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		/* optional CMsgQAngle ang = 2; */
		if (message.ang)
			CMsgQAngle.internalBinaryWrite(message.ang, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CP2P_VRAvatarPosition.COrientation
 */
export const CP2P_VRAvatarPosition_COrientation = new CP2P_VRAvatarPosition_COrientation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CP2P_WatchSynchronization$Type extends MessageType<CP2P_WatchSynchronization> {
	constructor() {
		super("CP2P_WatchSynchronization", [
			{
				no: 1,
				name: "demo_tick",
				kind: "scalar",
				localName: "demo_tick",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 2,
				name: "paused",
				kind: "scalar",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 3,
				name: "tv_listen_voice_indices",
				kind: "scalar",
				localName: "tv_listen_voice_indices",
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 4,
				name: "dota_spectator_mode",
				kind: "scalar",
				localName: "dota_spectator_mode",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 5,
				name: "dota_spectator_watching_broadcaster",
				kind: "scalar",
				localName: "dota_spectator_watching_broadcaster",
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 6,
				name: "dota_spectator_hero_index",
				kind: "scalar",
				localName: "dota_spectator_hero_index",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 7,
				name: "dota_spectator_autospeed",
				kind: "scalar",
				localName: "dota_spectator_autospeed",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
			{
				no: 8,
				name: "dota_replay_speed",
				kind: "scalar",
				localName: "dota_replay_speed",
				opt: true,
				T: 5 /*ScalarType.INT32*/,
			},
		]);
	}
	create(value?: PartialMessage<CP2P_WatchSynchronization>): CP2P_WatchSynchronization {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<CP2P_WatchSynchronization>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CP2P_WatchSynchronization,
	): CP2P_WatchSynchronization {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* optional int32 demo_tick */ 1:
					message.demo_tick = reader.int32();
					break;
				case /* optional bool paused */ 2:
					message.paused = reader.bool();
					break;
				case /* optional uint64 tv_listen_voice_indices */ 3:
					message.tv_listen_voice_indices = reader.uint64().toBigInt();
					break;
				case /* optional int32 dota_spectator_mode */ 4:
					message.dota_spectator_mode = reader.int32();
					break;
				case /* optional bool dota_spectator_watching_broadcaster */ 5:
					message.dota_spectator_watching_broadcaster = reader.bool();
					break;
				case /* optional int32 dota_spectator_hero_index */ 6:
					message.dota_spectator_hero_index = reader.int32();
					break;
				case /* optional int32 dota_spectator_autospeed */ 7:
					message.dota_spectator_autospeed = reader.int32();
					break;
				case /* optional int32 dota_replay_speed */ 8:
					message.dota_replay_speed = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === "throw")
						throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CP2P_WatchSynchronization,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* optional int32 demo_tick = 1; */
		if (message.demo_tick !== undefined) writer.tag(1, WireType.Varint).int32(message.demo_tick);
		/* optional bool paused = 2; */
		if (message.paused !== undefined) writer.tag(2, WireType.Varint).bool(message.paused);
		/* optional uint64 tv_listen_voice_indices = 3; */
		if (message.tv_listen_voice_indices !== undefined)
			writer.tag(3, WireType.Varint).uint64(message.tv_listen_voice_indices);
		/* optional int32 dota_spectator_mode = 4; */
		if (message.dota_spectator_mode !== undefined) writer.tag(4, WireType.Varint).int32(message.dota_spectator_mode);
		/* optional bool dota_spectator_watching_broadcaster = 5; */
		if (message.dota_spectator_watching_broadcaster !== undefined)
			writer.tag(5, WireType.Varint).bool(message.dota_spectator_watching_broadcaster);
		/* optional int32 dota_spectator_hero_index = 6; */
		if (message.dota_spectator_hero_index !== undefined)
			writer.tag(6, WireType.Varint).int32(message.dota_spectator_hero_index);
		/* optional int32 dota_spectator_autospeed = 7; */
		if (message.dota_spectator_autospeed !== undefined)
			writer.tag(7, WireType.Varint).int32(message.dota_spectator_autospeed);
		/* optional int32 dota_replay_speed = 8; */
		if (message.dota_replay_speed !== undefined) writer.tag(8, WireType.Varint).int32(message.dota_replay_speed);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message CP2P_WatchSynchronization
 */
export const CP2P_WatchSynchronization = new CP2P_WatchSynchronization$Type();
